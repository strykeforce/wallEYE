[[["ChangeSet", ["Renaming <updateTeam> to <update_team>", [["ChangeContents", ["publisher/network_table_publisher.py", "import ntcore\nimport logging\n\n\nclass NetworkIO:\n    logger = logging.getLogger(__name__)\n\n    # Create a Network Tables Client with given info\n    def __init__(self, test, team, table_name, num_cams):\n        # Grab the default network table instance and grab the table name\n        self.inst = ntcore.NetworkTableInstance.getDefault()\n        self.table = self.inst.getTable(table_name)\n\n        # Start the WallEye_Client and set server depending on testing\n        self.inst.startClient4(\"WallEye_Client\")\n        self.update_num = []\n        self.connection = []\n        self.pose1_sub = []\n        self.pose2_sub = []\n        self.timestamp_sub = []\n        self.ambiguity_sub = []\n        self.tag_sub = []\n        if test:\n            self.inst.setServer(\"127.0.0.1\", 5810)\n        else:\n            self.inst.setServerTeam(team)\n\n        # Set all the publishers and update publishers\n        self.publishers = []\n\n        # Update publisher\n        self.publish_update = []\n\n        # image publisher ie has recieved a new image\n        self.publish_connection = []\n\n        # Pose publisher\n        for index in range(num_cams):\n            self.publishers.append(self.table.getSubTable(\"Result\" + str(index)))\n\n            self.pose1_sub.append(\n                self.publishers[index]\n                .getDoubleArrayTopic(\"Pose1\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.timestamp_sub.append(\n                self.publishers[index]\n                .getDoubleTopic(\"timestamp\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.pose2_sub.append(\n                self.publishers[index]\n                .getDoubleArrayTopic(\"Pose2\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.ambiguity_sub.append(\n                self.publishers[index]\n                .getDoubleTopic(\"ambiguity\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.tag_sub.append(\n                self.publishers[index]\n                .getIntegerArrayTopic(\"tags\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.publish_update.append(\n                self.table.getIntegerTopic(\"Update\" + str(index)).publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n            self.publish_connection.append(\n                self.table.getBooleanTopic(\"Connected\" + str(index)).publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.update_num.append(0)\n            self.connection.append(False)\n\n    def get_time(self):\n        return ntcore._now()\n\n    def set_table(self, name):\n        self.table = self.inst.getTable(name)\n\n    # Publishes the supplied pose information in the corresponding publisher\n    def publish(self, index, time, pose, tags, ambig):\n        pose1 = pose[0]\n        pose2 = pose[1]\n        t1 = pose1.translation()\n        r1 = pose1.rotation()\n        t2 = pose2.translation()\n        r2 = pose2.rotation()\n\n        self.pose1_sub[index].set([t1.X(), t1.Y(), t1.Z(), r1.X(), r1.Y(), r1.Z()])\n        self.pose2_sub[index].set([t2.X(), t2.Y(), t2.Z(), r2.X(), r2.Y(), r2.Z()])\n        self.ambiguity_sub[index].set(ambig)\n        self.tag_sub[index].set(tags)\n        self.timestamp_sub[index].set(ntcore._now() - time)\n\n        self.update_num[index] += 1\n        self.publish_update[index].set(self.update_num[index])\n\n    # Publish a new update number\n    def increase_update_num(self):\n        self.update_num += 1\n        self.publish_update.set(self.update_num)\n\n    def setConnectionValue_XxX_CamelSnakePep8_PreserveName_XxX_6(self, index, val):\n        self.connection[index] = val\n        self.publish_connection[index].set(val)\n\n    def getConnectionValue_XxX_CamelSnakePep8_PreserveName_XxX_7(self, index):\n        return self.connection[index]\n\n    def destroy(self):\n        self.inst.stopClient()\n\n    def update_team(self, num):\n        self.inst.setServerTeam(num)\n\n    def updateName(self, name):\n        self.inst.getTable(name)\n", "import ntcore\nimport logging\n\n\nclass NetworkIO:\n    logger = logging.getLogger(__name__)\n\n    # Create a Network Tables Client with given info\n    def __init__(self, test, team, table_name, num_cams):\n        # Grab the default network table instance and grab the table name\n        self.inst = ntcore.NetworkTableInstance.getDefault()\n        self.table = self.inst.getTable(table_name)\n\n        # Start the WallEye_Client and set server depending on testing\n        self.inst.startClient4(\"WallEye_Client\")\n        self.update_num = []\n        self.connection = []\n        self.pose1_sub = []\n        self.pose2_sub = []\n        self.timestamp_sub = []\n        self.ambiguity_sub = []\n        self.tag_sub = []\n        if test:\n            self.inst.setServer(\"127.0.0.1\", 5810)\n        else:\n            self.inst.setServerTeam(team)\n\n        # Set all the publishers and update publishers\n        self.publishers = []\n\n        # Update publisher\n        self.publish_update = []\n\n        # image publisher ie has recieved a new image\n        self.publish_connection = []\n\n        # Pose publisher\n        for index in range(num_cams):\n            self.publishers.append(self.table.getSubTable(\"Result\" + str(index)))\n\n            self.pose1_sub.append(\n                self.publishers[index]\n                .getDoubleArrayTopic(\"Pose1\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.timestamp_sub.append(\n                self.publishers[index]\n                .getDoubleTopic(\"timestamp\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.pose2_sub.append(\n                self.publishers[index]\n                .getDoubleArrayTopic(\"Pose2\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.ambiguity_sub.append(\n                self.publishers[index]\n                .getDoubleTopic(\"ambiguity\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.tag_sub.append(\n                self.publishers[index]\n                .getIntegerArrayTopic(\"tags\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.publish_update.append(\n                self.table.getIntegerTopic(\"Update\" + str(index)).publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n            self.publish_connection.append(\n                self.table.getBooleanTopic(\"Connected\" + str(index)).publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.update_num.append(0)\n            self.connection.append(False)\n\n    def get_time(self):\n        return ntcore._now()\n\n    def set_table(self, name):\n        self.table = self.inst.getTable(name)\n\n    # Publishes the supplied pose information in the corresponding publisher\n    def publish(self, index, time, pose, tags, ambig):\n        pose1 = pose[0]\n        pose2 = pose[1]\n        t1 = pose1.translation()\n        r1 = pose1.rotation()\n        t2 = pose2.translation()\n        r2 = pose2.rotation()\n\n        self.pose1_sub[index].set([t1.X(), t1.Y(), t1.Z(), r1.X(), r1.Y(), r1.Z()])\n        self.pose2_sub[index].set([t2.X(), t2.Y(), t2.Z(), r2.X(), r2.Y(), r2.Z()])\n        self.ambiguity_sub[index].set(ambig)\n        self.tag_sub[index].set(tags)\n        self.timestamp_sub[index].set(ntcore._now() - time)\n\n        self.update_num[index] += 1\n        self.publish_update[index].set(self.update_num[index])\n\n    # Publish a new update number\n    def increase_update_num(self):\n        self.update_num += 1\n        self.publish_update.set(self.update_num)\n\n    def setConnectionValue_XxX_CamelSnakePep8_PreserveName_XxX_6(self, index, val):\n        self.connection[index] = val\n        self.publish_connection[index].set(val)\n\n    def getConnectionValue_XxX_CamelSnakePep8_PreserveName_XxX_7(self, index):\n        return self.connection[index]\n\n    def destroy(self):\n        self.inst.stopClient()\n\n    def updateTeam(self, num):\n        self.inst.setServerTeam(num)\n\n    def updateName(self, name):\n        self.inst.getTable(name)\n"]]], 1715210916.4229207]], ["ChangeSet", ["Renaming <updateName> to <update_name>", [["ChangeContents", ["publisher/network_table_publisher.py", "import ntcore\nimport logging\n\n\nclass NetworkIO:\n    logger = logging.getLogger(__name__)\n\n    # Create a Network Tables Client with given info\n    def __init__(self, test, team, table_name, num_cams):\n        # Grab the default network table instance and grab the table name\n        self.inst = ntcore.NetworkTableInstance.getDefault()\n        self.table = self.inst.getTable(table_name)\n\n        # Start the WallEye_Client and set server depending on testing\n        self.inst.startClient4(\"WallEye_Client\")\n        self.update_num = []\n        self.connection = []\n        self.pose1_sub = []\n        self.pose2_sub = []\n        self.timestamp_sub = []\n        self.ambiguity_sub = []\n        self.tag_sub = []\n        if test:\n            self.inst.setServer(\"127.0.0.1\", 5810)\n        else:\n            self.inst.setServerTeam(team)\n\n        # Set all the publishers and update publishers\n        self.publishers = []\n\n        # Update publisher\n        self.publish_update = []\n\n        # image publisher ie has recieved a new image\n        self.publish_connection = []\n\n        # Pose publisher\n        for index in range(num_cams):\n            self.publishers.append(self.table.getSubTable(\"Result\" + str(index)))\n\n            self.pose1_sub.append(\n                self.publishers[index]\n                .getDoubleArrayTopic(\"Pose1\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.timestamp_sub.append(\n                self.publishers[index]\n                .getDoubleTopic(\"timestamp\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.pose2_sub.append(\n                self.publishers[index]\n                .getDoubleArrayTopic(\"Pose2\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.ambiguity_sub.append(\n                self.publishers[index]\n                .getDoubleTopic(\"ambiguity\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.tag_sub.append(\n                self.publishers[index]\n                .getIntegerArrayTopic(\"tags\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.publish_update.append(\n                self.table.getIntegerTopic(\"Update\" + str(index)).publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n            self.publish_connection.append(\n                self.table.getBooleanTopic(\"Connected\" + str(index)).publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.update_num.append(0)\n            self.connection.append(False)\n\n    def get_time(self):\n        return ntcore._now()\n\n    def set_table(self, name):\n        self.table = self.inst.getTable(name)\n\n    # Publishes the supplied pose information in the corresponding publisher\n    def publish(self, index, time, pose, tags, ambig):\n        pose1 = pose[0]\n        pose2 = pose[1]\n        t1 = pose1.translation()\n        r1 = pose1.rotation()\n        t2 = pose2.translation()\n        r2 = pose2.rotation()\n\n        self.pose1_sub[index].set([t1.X(), t1.Y(), t1.Z(), r1.X(), r1.Y(), r1.Z()])\n        self.pose2_sub[index].set([t2.X(), t2.Y(), t2.Z(), r2.X(), r2.Y(), r2.Z()])\n        self.ambiguity_sub[index].set(ambig)\n        self.tag_sub[index].set(tags)\n        self.timestamp_sub[index].set(ntcore._now() - time)\n\n        self.update_num[index] += 1\n        self.publish_update[index].set(self.update_num[index])\n\n    # Publish a new update number\n    def increase_update_num(self):\n        self.update_num += 1\n        self.publish_update.set(self.update_num)\n\n    def setConnectionValue_XxX_CamelSnakePep8_PreserveName_XxX_6(self, index, val):\n        self.connection[index] = val\n        self.publish_connection[index].set(val)\n\n    def getConnectionValue_XxX_CamelSnakePep8_PreserveName_XxX_7(self, index):\n        return self.connection[index]\n\n    def destroy(self):\n        self.inst.stopClient()\n\n    def update_team(self, num):\n        self.inst.setServerTeam(num)\n\n    def update_name(self, name):\n        self.inst.getTable(name)\n", "import ntcore\nimport logging\n\n\nclass NetworkIO:\n    logger = logging.getLogger(__name__)\n\n    # Create a Network Tables Client with given info\n    def __init__(self, test, team, table_name, num_cams):\n        # Grab the default network table instance and grab the table name\n        self.inst = ntcore.NetworkTableInstance.getDefault()\n        self.table = self.inst.getTable(table_name)\n\n        # Start the WallEye_Client and set server depending on testing\n        self.inst.startClient4(\"WallEye_Client\")\n        self.update_num = []\n        self.connection = []\n        self.pose1_sub = []\n        self.pose2_sub = []\n        self.timestamp_sub = []\n        self.ambiguity_sub = []\n        self.tag_sub = []\n        if test:\n            self.inst.setServer(\"127.0.0.1\", 5810)\n        else:\n            self.inst.setServerTeam(team)\n\n        # Set all the publishers and update publishers\n        self.publishers = []\n\n        # Update publisher\n        self.publish_update = []\n\n        # image publisher ie has recieved a new image\n        self.publish_connection = []\n\n        # Pose publisher\n        for index in range(num_cams):\n            self.publishers.append(self.table.getSubTable(\"Result\" + str(index)))\n\n            self.pose1_sub.append(\n                self.publishers[index]\n                .getDoubleArrayTopic(\"Pose1\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.timestamp_sub.append(\n                self.publishers[index]\n                .getDoubleTopic(\"timestamp\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.pose2_sub.append(\n                self.publishers[index]\n                .getDoubleArrayTopic(\"Pose2\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.ambiguity_sub.append(\n                self.publishers[index]\n                .getDoubleTopic(\"ambiguity\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.tag_sub.append(\n                self.publishers[index]\n                .getIntegerArrayTopic(\"tags\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.publish_update.append(\n                self.table.getIntegerTopic(\"Update\" + str(index)).publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n            self.publish_connection.append(\n                self.table.getBooleanTopic(\"Connected\" + str(index)).publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.update_num.append(0)\n            self.connection.append(False)\n\n    def get_time(self):\n        return ntcore._now()\n\n    def set_table(self, name):\n        self.table = self.inst.getTable(name)\n\n    # Publishes the supplied pose information in the corresponding publisher\n    def publish(self, index, time, pose, tags, ambig):\n        pose1 = pose[0]\n        pose2 = pose[1]\n        t1 = pose1.translation()\n        r1 = pose1.rotation()\n        t2 = pose2.translation()\n        r2 = pose2.rotation()\n\n        self.pose1_sub[index].set([t1.X(), t1.Y(), t1.Z(), r1.X(), r1.Y(), r1.Z()])\n        self.pose2_sub[index].set([t2.X(), t2.Y(), t2.Z(), r2.X(), r2.Y(), r2.Z()])\n        self.ambiguity_sub[index].set(ambig)\n        self.tag_sub[index].set(tags)\n        self.timestamp_sub[index].set(ntcore._now() - time)\n\n        self.update_num[index] += 1\n        self.publish_update[index].set(self.update_num[index])\n\n    # Publish a new update number\n    def increase_update_num(self):\n        self.update_num += 1\n        self.publish_update.set(self.update_num)\n\n    def setConnectionValue_XxX_CamelSnakePep8_PreserveName_XxX_6(self, index, val):\n        self.connection[index] = val\n        self.publish_connection[index].set(val)\n\n    def getConnectionValue_XxX_CamelSnakePep8_PreserveName_XxX_7(self, index):\n        return self.connection[index]\n\n    def destroy(self):\n        self.inst.stopClient()\n\n    def update_team(self, num):\n        self.inst.setServerTeam(num)\n\n    def updateName(self, name):\n        self.inst.getTable(name)\n"]]], 1715210918.1558342]], ["ChangeSet", ["Renaming <outputFrame> to <output_frame>", [["ChangeContents", ["web_interface/image_streams.py", "import cv2\nimport logging\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.image as mpimg\nimport json\nimport simplejpeg\nimport time\nimport asyncio\n\nlogger = logging.getLogger(__name__)\n\n\nclass Buffer:\n    output_frame = b\"\"\n    lastNone = False\n\n    def update(self, img):\n        if img is None:\n            if not self.lastNone:\n                logger.error(\"Updated image is None - Skipping\")\n            self.lastNone = True\n            return\n        if self.lastNone:\n            logger.info(\"Updated image is NOT none!\")\n        self.lastNone = False\n        self.output_frame = cv2.imencode(\".jpg\", img)[1].tobytes()\n        # encoded = simplejpeg.encode_jpeg(img)\n        # if (img == encoded).all():\n        #     logger.warning(\"Frame did not update!\")\n        # self.outputFrame = encoded\n\n    def output(self):\n        # await asyncio.sleep(0.1)\n        while True:\n            yield (\n                b\"--frame\\r\\n\"\n                b\"Content-Type: image/jpeg\\r\\n\\r\\n\" + self.output_frame + b\"\\r\\n\"\n            )\n\n\nclass LivePlotBuffer(Buffer):\n    FIELD_DIMS = (16.54, 8.02)\n\n    def __init__(self):\n        super(LivePlotBuffer, self).__init__()\n\n        with open(\"./processing/april_tag_layout.json\", \"r\") as f:\n            self.tagLayout = json.load(f)\n            logger.info(\"Tag layout loaded\")\n        self.tagLayout = self.tagLayout[\"tags\"]\n        self.fig = plt.figure()\n        self.ax = self.fig.add_subplot(111, projection=\"3d\")\n        self.ax.view_init(elev=35, azim=-80, roll=0)\n        self.x, self.y, self.z = [], [], []\n        (self.poses2D,) = self.ax.plot3D(\n            self.x,\n            self.y,\n            np.atleast_1d(0),\n            marker=\">\",\n            markevery=[-1],\n            zorder=10,\n            animated=True,\n        )\n        (self.poses,) = self.ax.plot3D(\n            self.x,\n            self.y,\n            self.z,\n            marker=\"o\",\n            markevery=[-1],\n            zorder=100,\n            animated=True,\n        )\n        (self.tags,) = self.ax.plot3D(\n            [],\n            [],\n            0,\n            \"s\",\n            zorder=200,\n            animated=True,\n        )\n        self.ax.set_xlim(0, LivePlotBuffer.FIELD_DIMS[0])\n        self.ax.set_ylim(0, LivePlotBuffer.FIELD_DIMS[1])\n        self.ax.set_zlim(0, 2)\n        plt.locator_params(axis=\"z\", nbins=2)\n        self.ax.set_aspect(\"equal\")\n        self.fig.tight_layout()\n        self.fig.subplots_adjust(left=-0.26, right=1.21, bottom=-0.08, top=1.08)\n\n        img = mpimg.imread(\"./web_interface/field.png\")\n        x = np.linspace(0, LivePlotBuffer.FIELD_DIMS[0], img.shape[1])\n        y = np.linspace(0, LivePlotBuffer.FIELD_DIMS[1], img.shape[0])\n        x, y = np.meshgrid(x, y)\n        self.ax.plot_surface(\n            x, y, np.atleast_2d(0), rstride=5, cstride=5, facecolors=img\n        )\n\n        plt.pause(0.1)\n\n        self.bg = self.fig.canvas.copy_from_bbox(self.fig.bbox)\n        self.ax.draw_artist(self.poses)\n        self.ax.draw_artist(self.poses2D)\n        self.ax.draw_artist(self.tags)\n        self.fig.canvas.blit(self.fig.bbox)\n\n    def update(self, pose, tags):\n        self.fig.canvas.restore_region(self.bg)\n\n        if pose != (2767, 2767, 2767):\n            self.x.append(pose[0])\n            self.y.append(pose[1])\n            self.z.append(pose[2])\n\n        self.x = self.x[-50:]\n        self.y = self.y[-50:]\n        self.z = self.z[-50:]\n        self.poses.set_data(self.x, self.y)\n        self.poses.set_3d_properties(self.z)\n        self.poses2D.set_data(self.x, self.y)\n        self.poses2D.set_3d_properties(np.atleast_1d(0))\n\n        tagsX = [\n            (\n                self.tagLayout[tag - 1][\"pose\"][\"translation\"][\"x\"]\n                if (tag < 9 and tag > 0)\n                else 2767\n            )\n            for tag in tags\n        ]\n        tagsY = [\n            (\n                self.tagLayout[tag - 1][\"pose\"][\"translation\"][\"y\"]\n                if (tag < 9 and tag > 0)\n                else 2767\n            )\n            for tag in tags\n        ]\n\n        self.tags.set_data(tagsX, tagsY)\n        self.tags.set_3d_properties(np.atleast_1d(0))\n\n        self.ax.draw_artist(self.poses2D)\n        self.ax.draw_artist(self.poses)\n        self.ax.draw_artist(self.tags)\n        self.fig.canvas.blit(self.fig.bbox)\n        self.fig.canvas.flush_events()\n\n        plot = np.frombuffer(self.fig.canvas.tostring_rgb(), dtype=np.uint8)\n        img = plot.reshape(self.fig.canvas.get_width_height()[::-1] + (3,))\n        self.outputFrame = simplejpeg.encode_jpeg(img)\n", "import cv2\nimport logging\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.image as mpimg\nimport json\nimport simplejpeg\nimport time\nimport asyncio\n\nlogger = logging.getLogger(__name__)\n\n\nclass Buffer:\n    outputFrame = b\"\"\n    lastNone = False\n\n    def update(self, img):\n        if img is None:\n            if not self.lastNone:\n                logger.error(\"Updated image is None - Skipping\")\n            self.lastNone = True\n            return\n        if self.lastNone:\n            logger.info(\"Updated image is NOT none!\")\n        self.lastNone = False\n        self.outputFrame = cv2.imencode(\".jpg\", img)[1].tobytes()\n        # encoded = simplejpeg.encode_jpeg(img)\n        # if (img == encoded).all():\n        #     logger.warning(\"Frame did not update!\")\n        # self.outputFrame = encoded\n\n    def output(self):\n        # await asyncio.sleep(0.1)\n        while True:\n            yield (\n                b\"--frame\\r\\n\"\n                b\"Content-Type: image/jpeg\\r\\n\\r\\n\" + self.outputFrame + b\"\\r\\n\"\n            )\n\n\nclass LivePlotBuffer(Buffer):\n    FIELD_DIMS = (16.54, 8.02)\n\n    def __init__(self):\n        super(LivePlotBuffer, self).__init__()\n\n        with open(\"./processing/april_tag_layout.json\", \"r\") as f:\n            self.tagLayout = json.load(f)\n            logger.info(\"Tag layout loaded\")\n        self.tagLayout = self.tagLayout[\"tags\"]\n        self.fig = plt.figure()\n        self.ax = self.fig.add_subplot(111, projection=\"3d\")\n        self.ax.view_init(elev=35, azim=-80, roll=0)\n        self.x, self.y, self.z = [], [], []\n        (self.poses2D,) = self.ax.plot3D(\n            self.x,\n            self.y,\n            np.atleast_1d(0),\n            marker=\">\",\n            markevery=[-1],\n            zorder=10,\n            animated=True,\n        )\n        (self.poses,) = self.ax.plot3D(\n            self.x,\n            self.y,\n            self.z,\n            marker=\"o\",\n            markevery=[-1],\n            zorder=100,\n            animated=True,\n        )\n        (self.tags,) = self.ax.plot3D(\n            [],\n            [],\n            0,\n            \"s\",\n            zorder=200,\n            animated=True,\n        )\n        self.ax.set_xlim(0, LivePlotBuffer.FIELD_DIMS[0])\n        self.ax.set_ylim(0, LivePlotBuffer.FIELD_DIMS[1])\n        self.ax.set_zlim(0, 2)\n        plt.locator_params(axis=\"z\", nbins=2)\n        self.ax.set_aspect(\"equal\")\n        self.fig.tight_layout()\n        self.fig.subplots_adjust(left=-0.26, right=1.21, bottom=-0.08, top=1.08)\n\n        img = mpimg.imread(\"./web_interface/field.png\")\n        x = np.linspace(0, LivePlotBuffer.FIELD_DIMS[0], img.shape[1])\n        y = np.linspace(0, LivePlotBuffer.FIELD_DIMS[1], img.shape[0])\n        x, y = np.meshgrid(x, y)\n        self.ax.plot_surface(\n            x, y, np.atleast_2d(0), rstride=5, cstride=5, facecolors=img\n        )\n\n        plt.pause(0.1)\n\n        self.bg = self.fig.canvas.copy_from_bbox(self.fig.bbox)\n        self.ax.draw_artist(self.poses)\n        self.ax.draw_artist(self.poses2D)\n        self.ax.draw_artist(self.tags)\n        self.fig.canvas.blit(self.fig.bbox)\n\n    def update(self, pose, tags):\n        self.fig.canvas.restore_region(self.bg)\n\n        if pose != (2767, 2767, 2767):\n            self.x.append(pose[0])\n            self.y.append(pose[1])\n            self.z.append(pose[2])\n\n        self.x = self.x[-50:]\n        self.y = self.y[-50:]\n        self.z = self.z[-50:]\n        self.poses.set_data(self.x, self.y)\n        self.poses.set_3d_properties(self.z)\n        self.poses2D.set_data(self.x, self.y)\n        self.poses2D.set_3d_properties(np.atleast_1d(0))\n\n        tagsX = [\n            (\n                self.tagLayout[tag - 1][\"pose\"][\"translation\"][\"x\"]\n                if (tag < 9 and tag > 0)\n                else 2767\n            )\n            for tag in tags\n        ]\n        tagsY = [\n            (\n                self.tagLayout[tag - 1][\"pose\"][\"translation\"][\"y\"]\n                if (tag < 9 and tag > 0)\n                else 2767\n            )\n            for tag in tags\n        ]\n\n        self.tags.set_data(tagsX, tagsY)\n        self.tags.set_3d_properties(np.atleast_1d(0))\n\n        self.ax.draw_artist(self.poses2D)\n        self.ax.draw_artist(self.poses)\n        self.ax.draw_artist(self.tags)\n        self.fig.canvas.blit(self.fig.bbox)\n        self.fig.canvas.flush_events()\n\n        plot = np.frombuffer(self.fig.canvas.tostring_rgb(), dtype=np.uint8)\n        img = plot.reshape(self.fig.canvas.get_width_height()[::-1] + (3,))\n        self.outputFrame = simplejpeg.encode_jpeg(img)\n"]]], 1715210920.7553725]], ["ChangeSet", ["Renaming <lastNone> to <last_none>", [["ChangeContents", ["web_interface/image_streams.py", "import cv2\nimport logging\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.image as mpimg\nimport json\nimport simplejpeg\nimport time\nimport asyncio\n\nlogger = logging.getLogger(__name__)\n\n\nclass Buffer:\n    output_frame = b\"\"\n    last_none = False\n\n    def update(self, img):\n        if img is None:\n            if not self.last_none:\n                logger.error(\"Updated image is None - Skipping\")\n            self.last_none = True\n            return\n        if self.last_none:\n            logger.info(\"Updated image is NOT none!\")\n        self.last_none = False\n        self.output_frame = cv2.imencode(\".jpg\", img)[1].tobytes()\n        # encoded = simplejpeg.encode_jpeg(img)\n        # if (img == encoded).all():\n        #     logger.warning(\"Frame did not update!\")\n        # self.outputFrame = encoded\n\n    def output(self):\n        # await asyncio.sleep(0.1)\n        while True:\n            yield (\n                b\"--frame\\r\\n\"\n                b\"Content-Type: image/jpeg\\r\\n\\r\\n\" + self.output_frame + b\"\\r\\n\"\n            )\n\n\nclass LivePlotBuffer(Buffer):\n    FIELD_DIMS = (16.54, 8.02)\n\n    def __init__(self):\n        super(LivePlotBuffer, self).__init__()\n\n        with open(\"./processing/april_tag_layout.json\", \"r\") as f:\n            self.tagLayout = json.load(f)\n            logger.info(\"Tag layout loaded\")\n        self.tagLayout = self.tagLayout[\"tags\"]\n        self.fig = plt.figure()\n        self.ax = self.fig.add_subplot(111, projection=\"3d\")\n        self.ax.view_init(elev=35, azim=-80, roll=0)\n        self.x, self.y, self.z = [], [], []\n        (self.poses2D,) = self.ax.plot3D(\n            self.x,\n            self.y,\n            np.atleast_1d(0),\n            marker=\">\",\n            markevery=[-1],\n            zorder=10,\n            animated=True,\n        )\n        (self.poses,) = self.ax.plot3D(\n            self.x,\n            self.y,\n            self.z,\n            marker=\"o\",\n            markevery=[-1],\n            zorder=100,\n            animated=True,\n        )\n        (self.tags,) = self.ax.plot3D(\n            [],\n            [],\n            0,\n            \"s\",\n            zorder=200,\n            animated=True,\n        )\n        self.ax.set_xlim(0, LivePlotBuffer.FIELD_DIMS[0])\n        self.ax.set_ylim(0, LivePlotBuffer.FIELD_DIMS[1])\n        self.ax.set_zlim(0, 2)\n        plt.locator_params(axis=\"z\", nbins=2)\n        self.ax.set_aspect(\"equal\")\n        self.fig.tight_layout()\n        self.fig.subplots_adjust(left=-0.26, right=1.21, bottom=-0.08, top=1.08)\n\n        img = mpimg.imread(\"./web_interface/field.png\")\n        x = np.linspace(0, LivePlotBuffer.FIELD_DIMS[0], img.shape[1])\n        y = np.linspace(0, LivePlotBuffer.FIELD_DIMS[1], img.shape[0])\n        x, y = np.meshgrid(x, y)\n        self.ax.plot_surface(\n            x, y, np.atleast_2d(0), rstride=5, cstride=5, facecolors=img\n        )\n\n        plt.pause(0.1)\n\n        self.bg = self.fig.canvas.copy_from_bbox(self.fig.bbox)\n        self.ax.draw_artist(self.poses)\n        self.ax.draw_artist(self.poses2D)\n        self.ax.draw_artist(self.tags)\n        self.fig.canvas.blit(self.fig.bbox)\n\n    def update(self, pose, tags):\n        self.fig.canvas.restore_region(self.bg)\n\n        if pose != (2767, 2767, 2767):\n            self.x.append(pose[0])\n            self.y.append(pose[1])\n            self.z.append(pose[2])\n\n        self.x = self.x[-50:]\n        self.y = self.y[-50:]\n        self.z = self.z[-50:]\n        self.poses.set_data(self.x, self.y)\n        self.poses.set_3d_properties(self.z)\n        self.poses2D.set_data(self.x, self.y)\n        self.poses2D.set_3d_properties(np.atleast_1d(0))\n\n        tagsX = [\n            (\n                self.tagLayout[tag - 1][\"pose\"][\"translation\"][\"x\"]\n                if (tag < 9 and tag > 0)\n                else 2767\n            )\n            for tag in tags\n        ]\n        tagsY = [\n            (\n                self.tagLayout[tag - 1][\"pose\"][\"translation\"][\"y\"]\n                if (tag < 9 and tag > 0)\n                else 2767\n            )\n            for tag in tags\n        ]\n\n        self.tags.set_data(tagsX, tagsY)\n        self.tags.set_3d_properties(np.atleast_1d(0))\n\n        self.ax.draw_artist(self.poses2D)\n        self.ax.draw_artist(self.poses)\n        self.ax.draw_artist(self.tags)\n        self.fig.canvas.blit(self.fig.bbox)\n        self.fig.canvas.flush_events()\n\n        plot = np.frombuffer(self.fig.canvas.tostring_rgb(), dtype=np.uint8)\n        img = plot.reshape(self.fig.canvas.get_width_height()[::-1] + (3,))\n        self.outputFrame = simplejpeg.encode_jpeg(img)\n", "import cv2\nimport logging\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.image as mpimg\nimport json\nimport simplejpeg\nimport time\nimport asyncio\n\nlogger = logging.getLogger(__name__)\n\n\nclass Buffer:\n    output_frame = b\"\"\n    lastNone = False\n\n    def update(self, img):\n        if img is None:\n            if not self.lastNone:\n                logger.error(\"Updated image is None - Skipping\")\n            self.lastNone = True\n            return\n        if self.lastNone:\n            logger.info(\"Updated image is NOT none!\")\n        self.lastNone = False\n        self.output_frame = cv2.imencode(\".jpg\", img)[1].tobytes()\n        # encoded = simplejpeg.encode_jpeg(img)\n        # if (img == encoded).all():\n        #     logger.warning(\"Frame did not update!\")\n        # self.outputFrame = encoded\n\n    def output(self):\n        # await asyncio.sleep(0.1)\n        while True:\n            yield (\n                b\"--frame\\r\\n\"\n                b\"Content-Type: image/jpeg\\r\\n\\r\\n\" + self.output_frame + b\"\\r\\n\"\n            )\n\n\nclass LivePlotBuffer(Buffer):\n    FIELD_DIMS = (16.54, 8.02)\n\n    def __init__(self):\n        super(LivePlotBuffer, self).__init__()\n\n        with open(\"./processing/april_tag_layout.json\", \"r\") as f:\n            self.tagLayout = json.load(f)\n            logger.info(\"Tag layout loaded\")\n        self.tagLayout = self.tagLayout[\"tags\"]\n        self.fig = plt.figure()\n        self.ax = self.fig.add_subplot(111, projection=\"3d\")\n        self.ax.view_init(elev=35, azim=-80, roll=0)\n        self.x, self.y, self.z = [], [], []\n        (self.poses2D,) = self.ax.plot3D(\n            self.x,\n            self.y,\n            np.atleast_1d(0),\n            marker=\">\",\n            markevery=[-1],\n            zorder=10,\n            animated=True,\n        )\n        (self.poses,) = self.ax.plot3D(\n            self.x,\n            self.y,\n            self.z,\n            marker=\"o\",\n            markevery=[-1],\n            zorder=100,\n            animated=True,\n        )\n        (self.tags,) = self.ax.plot3D(\n            [],\n            [],\n            0,\n            \"s\",\n            zorder=200,\n            animated=True,\n        )\n        self.ax.set_xlim(0, LivePlotBuffer.FIELD_DIMS[0])\n        self.ax.set_ylim(0, LivePlotBuffer.FIELD_DIMS[1])\n        self.ax.set_zlim(0, 2)\n        plt.locator_params(axis=\"z\", nbins=2)\n        self.ax.set_aspect(\"equal\")\n        self.fig.tight_layout()\n        self.fig.subplots_adjust(left=-0.26, right=1.21, bottom=-0.08, top=1.08)\n\n        img = mpimg.imread(\"./web_interface/field.png\")\n        x = np.linspace(0, LivePlotBuffer.FIELD_DIMS[0], img.shape[1])\n        y = np.linspace(0, LivePlotBuffer.FIELD_DIMS[1], img.shape[0])\n        x, y = np.meshgrid(x, y)\n        self.ax.plot_surface(\n            x, y, np.atleast_2d(0), rstride=5, cstride=5, facecolors=img\n        )\n\n        plt.pause(0.1)\n\n        self.bg = self.fig.canvas.copy_from_bbox(self.fig.bbox)\n        self.ax.draw_artist(self.poses)\n        self.ax.draw_artist(self.poses2D)\n        self.ax.draw_artist(self.tags)\n        self.fig.canvas.blit(self.fig.bbox)\n\n    def update(self, pose, tags):\n        self.fig.canvas.restore_region(self.bg)\n\n        if pose != (2767, 2767, 2767):\n            self.x.append(pose[0])\n            self.y.append(pose[1])\n            self.z.append(pose[2])\n\n        self.x = self.x[-50:]\n        self.y = self.y[-50:]\n        self.z = self.z[-50:]\n        self.poses.set_data(self.x, self.y)\n        self.poses.set_3d_properties(self.z)\n        self.poses2D.set_data(self.x, self.y)\n        self.poses2D.set_3d_properties(np.atleast_1d(0))\n\n        tagsX = [\n            (\n                self.tagLayout[tag - 1][\"pose\"][\"translation\"][\"x\"]\n                if (tag < 9 and tag > 0)\n                else 2767\n            )\n            for tag in tags\n        ]\n        tagsY = [\n            (\n                self.tagLayout[tag - 1][\"pose\"][\"translation\"][\"y\"]\n                if (tag < 9 and tag > 0)\n                else 2767\n            )\n            for tag in tags\n        ]\n\n        self.tags.set_data(tagsX, tagsY)\n        self.tags.set_3d_properties(np.atleast_1d(0))\n\n        self.ax.draw_artist(self.poses2D)\n        self.ax.draw_artist(self.poses)\n        self.ax.draw_artist(self.tags)\n        self.fig.canvas.blit(self.fig.bbox)\n        self.fig.canvas.flush_events()\n\n        plot = np.frombuffer(self.fig.canvas.tostring_rgb(), dtype=np.uint8)\n        img = plot.reshape(self.fig.canvas.get_width_height()[::-1] + (3,))\n        self.outputFrame = simplejpeg.encode_jpeg(img)\n"]]], 1715210923.0575235]], ["ChangeSet", ["Renaming <tagLayout> to <tag_layout>", [["ChangeContents", ["web_interface/image_streams.py", "import cv2\nimport logging\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.image as mpimg\nimport json\nimport simplejpeg\nimport time\nimport asyncio\n\nlogger = logging.getLogger(__name__)\n\n\nclass Buffer:\n    output_frame = b\"\"\n    last_none = False\n\n    def update(self, img):\n        if img is None:\n            if not self.last_none:\n                logger.error(\"Updated image is None - Skipping\")\n            self.last_none = True\n            return\n        if self.last_none:\n            logger.info(\"Updated image is NOT none!\")\n        self.last_none = False\n        self.output_frame = cv2.imencode(\".jpg\", img)[1].tobytes()\n        # encoded = simplejpeg.encode_jpeg(img)\n        # if (img == encoded).all():\n        #     logger.warning(\"Frame did not update!\")\n        # self.outputFrame = encoded\n\n    def output(self):\n        # await asyncio.sleep(0.1)\n        while True:\n            yield (\n                b\"--frame\\r\\n\"\n                b\"Content-Type: image/jpeg\\r\\n\\r\\n\" + self.output_frame + b\"\\r\\n\"\n            )\n\n\nclass LivePlotBuffer(Buffer):\n    FIELD_DIMS = (16.54, 8.02)\n\n    def __init__(self):\n        super(LivePlotBuffer, self).__init__()\n\n        with open(\"./processing/april_tag_layout.json\", \"r\") as f:\n            self.tag_layout = json.load(f)\n            logger.info(\"Tag layout loaded\")\n        self.tag_layout = self.tag_layout[\"tags\"]\n        self.fig = plt.figure()\n        self.ax = self.fig.add_subplot(111, projection=\"3d\")\n        self.ax.view_init(elev=35, azim=-80, roll=0)\n        self.x, self.y, self.z = [], [], []\n        (self.poses2D,) = self.ax.plot3D(\n            self.x,\n            self.y,\n            np.atleast_1d(0),\n            marker=\">\",\n            markevery=[-1],\n            zorder=10,\n            animated=True,\n        )\n        (self.poses,) = self.ax.plot3D(\n            self.x,\n            self.y,\n            self.z,\n            marker=\"o\",\n            markevery=[-1],\n            zorder=100,\n            animated=True,\n        )\n        (self.tags,) = self.ax.plot3D(\n            [],\n            [],\n            0,\n            \"s\",\n            zorder=200,\n            animated=True,\n        )\n        self.ax.set_xlim(0, LivePlotBuffer.FIELD_DIMS[0])\n        self.ax.set_ylim(0, LivePlotBuffer.FIELD_DIMS[1])\n        self.ax.set_zlim(0, 2)\n        plt.locator_params(axis=\"z\", nbins=2)\n        self.ax.set_aspect(\"equal\")\n        self.fig.tight_layout()\n        self.fig.subplots_adjust(left=-0.26, right=1.21, bottom=-0.08, top=1.08)\n\n        img = mpimg.imread(\"./web_interface/field.png\")\n        x = np.linspace(0, LivePlotBuffer.FIELD_DIMS[0], img.shape[1])\n        y = np.linspace(0, LivePlotBuffer.FIELD_DIMS[1], img.shape[0])\n        x, y = np.meshgrid(x, y)\n        self.ax.plot_surface(\n            x, y, np.atleast_2d(0), rstride=5, cstride=5, facecolors=img\n        )\n\n        plt.pause(0.1)\n\n        self.bg = self.fig.canvas.copy_from_bbox(self.fig.bbox)\n        self.ax.draw_artist(self.poses)\n        self.ax.draw_artist(self.poses2D)\n        self.ax.draw_artist(self.tags)\n        self.fig.canvas.blit(self.fig.bbox)\n\n    def update(self, pose, tags):\n        self.fig.canvas.restore_region(self.bg)\n\n        if pose != (2767, 2767, 2767):\n            self.x.append(pose[0])\n            self.y.append(pose[1])\n            self.z.append(pose[2])\n\n        self.x = self.x[-50:]\n        self.y = self.y[-50:]\n        self.z = self.z[-50:]\n        self.poses.set_data(self.x, self.y)\n        self.poses.set_3d_properties(self.z)\n        self.poses2D.set_data(self.x, self.y)\n        self.poses2D.set_3d_properties(np.atleast_1d(0))\n\n        tagsX = [\n            (\n                self.tag_layout[tag - 1][\"pose\"][\"translation\"][\"x\"]\n                if (tag < 9 and tag > 0)\n                else 2767\n            )\n            for tag in tags\n        ]\n        tagsY = [\n            (\n                self.tag_layout[tag - 1][\"pose\"][\"translation\"][\"y\"]\n                if (tag < 9 and tag > 0)\n                else 2767\n            )\n            for tag in tags\n        ]\n\n        self.tags.set_data(tagsX, tagsY)\n        self.tags.set_3d_properties(np.atleast_1d(0))\n\n        self.ax.draw_artist(self.poses2D)\n        self.ax.draw_artist(self.poses)\n        self.ax.draw_artist(self.tags)\n        self.fig.canvas.blit(self.fig.bbox)\n        self.fig.canvas.flush_events()\n\n        plot = np.frombuffer(self.fig.canvas.tostring_rgb(), dtype=np.uint8)\n        img = plot.reshape(self.fig.canvas.get_width_height()[::-1] + (3,))\n        self.outputFrame = simplejpeg.encode_jpeg(img)\n", "import cv2\nimport logging\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.image as mpimg\nimport json\nimport simplejpeg\nimport time\nimport asyncio\n\nlogger = logging.getLogger(__name__)\n\n\nclass Buffer:\n    output_frame = b\"\"\n    last_none = False\n\n    def update(self, img):\n        if img is None:\n            if not self.last_none:\n                logger.error(\"Updated image is None - Skipping\")\n            self.last_none = True\n            return\n        if self.last_none:\n            logger.info(\"Updated image is NOT none!\")\n        self.last_none = False\n        self.output_frame = cv2.imencode(\".jpg\", img)[1].tobytes()\n        # encoded = simplejpeg.encode_jpeg(img)\n        # if (img == encoded).all():\n        #     logger.warning(\"Frame did not update!\")\n        # self.outputFrame = encoded\n\n    def output(self):\n        # await asyncio.sleep(0.1)\n        while True:\n            yield (\n                b\"--frame\\r\\n\"\n                b\"Content-Type: image/jpeg\\r\\n\\r\\n\" + self.output_frame + b\"\\r\\n\"\n            )\n\n\nclass LivePlotBuffer(Buffer):\n    FIELD_DIMS = (16.54, 8.02)\n\n    def __init__(self):\n        super(LivePlotBuffer, self).__init__()\n\n        with open(\"./processing/april_tag_layout.json\", \"r\") as f:\n            self.tagLayout = json.load(f)\n            logger.info(\"Tag layout loaded\")\n        self.tagLayout = self.tagLayout[\"tags\"]\n        self.fig = plt.figure()\n        self.ax = self.fig.add_subplot(111, projection=\"3d\")\n        self.ax.view_init(elev=35, azim=-80, roll=0)\n        self.x, self.y, self.z = [], [], []\n        (self.poses2D,) = self.ax.plot3D(\n            self.x,\n            self.y,\n            np.atleast_1d(0),\n            marker=\">\",\n            markevery=[-1],\n            zorder=10,\n            animated=True,\n        )\n        (self.poses,) = self.ax.plot3D(\n            self.x,\n            self.y,\n            self.z,\n            marker=\"o\",\n            markevery=[-1],\n            zorder=100,\n            animated=True,\n        )\n        (self.tags,) = self.ax.plot3D(\n            [],\n            [],\n            0,\n            \"s\",\n            zorder=200,\n            animated=True,\n        )\n        self.ax.set_xlim(0, LivePlotBuffer.FIELD_DIMS[0])\n        self.ax.set_ylim(0, LivePlotBuffer.FIELD_DIMS[1])\n        self.ax.set_zlim(0, 2)\n        plt.locator_params(axis=\"z\", nbins=2)\n        self.ax.set_aspect(\"equal\")\n        self.fig.tight_layout()\n        self.fig.subplots_adjust(left=-0.26, right=1.21, bottom=-0.08, top=1.08)\n\n        img = mpimg.imread(\"./web_interface/field.png\")\n        x = np.linspace(0, LivePlotBuffer.FIELD_DIMS[0], img.shape[1])\n        y = np.linspace(0, LivePlotBuffer.FIELD_DIMS[1], img.shape[0])\n        x, y = np.meshgrid(x, y)\n        self.ax.plot_surface(\n            x, y, np.atleast_2d(0), rstride=5, cstride=5, facecolors=img\n        )\n\n        plt.pause(0.1)\n\n        self.bg = self.fig.canvas.copy_from_bbox(self.fig.bbox)\n        self.ax.draw_artist(self.poses)\n        self.ax.draw_artist(self.poses2D)\n        self.ax.draw_artist(self.tags)\n        self.fig.canvas.blit(self.fig.bbox)\n\n    def update(self, pose, tags):\n        self.fig.canvas.restore_region(self.bg)\n\n        if pose != (2767, 2767, 2767):\n            self.x.append(pose[0])\n            self.y.append(pose[1])\n            self.z.append(pose[2])\n\n        self.x = self.x[-50:]\n        self.y = self.y[-50:]\n        self.z = self.z[-50:]\n        self.poses.set_data(self.x, self.y)\n        self.poses.set_3d_properties(self.z)\n        self.poses2D.set_data(self.x, self.y)\n        self.poses2D.set_3d_properties(np.atleast_1d(0))\n\n        tagsX = [\n            (\n                self.tagLayout[tag - 1][\"pose\"][\"translation\"][\"x\"]\n                if (tag < 9 and tag > 0)\n                else 2767\n            )\n            for tag in tags\n        ]\n        tagsY = [\n            (\n                self.tagLayout[tag - 1][\"pose\"][\"translation\"][\"y\"]\n                if (tag < 9 and tag > 0)\n                else 2767\n            )\n            for tag in tags\n        ]\n\n        self.tags.set_data(tagsX, tagsY)\n        self.tags.set_3d_properties(np.atleast_1d(0))\n\n        self.ax.draw_artist(self.poses2D)\n        self.ax.draw_artist(self.poses)\n        self.ax.draw_artist(self.tags)\n        self.fig.canvas.blit(self.fig.bbox)\n        self.fig.canvas.flush_events()\n\n        plot = np.frombuffer(self.fig.canvas.tostring_rgb(), dtype=np.uint8)\n        img = plot.reshape(self.fig.canvas.get_width_height()[::-1] + (3,))\n        self.outputFrame = simplejpeg.encode_jpeg(img)\n"]]], 1715210925.5994358]], ["ChangeSet", ["Renaming <poses2D> to <poses2_d>", [["ChangeContents", ["web_interface/image_streams.py", "import cv2\nimport logging\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.image as mpimg\nimport json\nimport simplejpeg\nimport time\nimport asyncio\n\nlogger = logging.getLogger(__name__)\n\n\nclass Buffer:\n    output_frame = b\"\"\n    last_none = False\n\n    def update(self, img):\n        if img is None:\n            if not self.last_none:\n                logger.error(\"Updated image is None - Skipping\")\n            self.last_none = True\n            return\n        if self.last_none:\n            logger.info(\"Updated image is NOT none!\")\n        self.last_none = False\n        self.output_frame = cv2.imencode(\".jpg\", img)[1].tobytes()\n        # encoded = simplejpeg.encode_jpeg(img)\n        # if (img == encoded).all():\n        #     logger.warning(\"Frame did not update!\")\n        # self.outputFrame = encoded\n\n    def output(self):\n        # await asyncio.sleep(0.1)\n        while True:\n            yield (\n                b\"--frame\\r\\n\"\n                b\"Content-Type: image/jpeg\\r\\n\\r\\n\" + self.output_frame + b\"\\r\\n\"\n            )\n\n\nclass LivePlotBuffer(Buffer):\n    FIELD_DIMS = (16.54, 8.02)\n\n    def __init__(self):\n        super(LivePlotBuffer, self).__init__()\n\n        with open(\"./processing/april_tag_layout.json\", \"r\") as f:\n            self.tag_layout = json.load(f)\n            logger.info(\"Tag layout loaded\")\n        self.tag_layout = self.tag_layout[\"tags\"]\n        self.fig = plt.figure()\n        self.ax = self.fig.add_subplot(111, projection=\"3d\")\n        self.ax.view_init(elev=35, azim=-80, roll=0)\n        self.x, self.y, self.z = [], [], []\n        (self.poses2_d,) = self.ax.plot3D(\n            self.x,\n            self.y,\n            np.atleast_1d(0),\n            marker=\">\",\n            markevery=[-1],\n            zorder=10,\n            animated=True,\n        )\n        (self.poses,) = self.ax.plot3D(\n            self.x,\n            self.y,\n            self.z,\n            marker=\"o\",\n            markevery=[-1],\n            zorder=100,\n            animated=True,\n        )\n        (self.tags,) = self.ax.plot3D(\n            [],\n            [],\n            0,\n            \"s\",\n            zorder=200,\n            animated=True,\n        )\n        self.ax.set_xlim(0, LivePlotBuffer.FIELD_DIMS[0])\n        self.ax.set_ylim(0, LivePlotBuffer.FIELD_DIMS[1])\n        self.ax.set_zlim(0, 2)\n        plt.locator_params(axis=\"z\", nbins=2)\n        self.ax.set_aspect(\"equal\")\n        self.fig.tight_layout()\n        self.fig.subplots_adjust(left=-0.26, right=1.21, bottom=-0.08, top=1.08)\n\n        img = mpimg.imread(\"./web_interface/field.png\")\n        x = np.linspace(0, LivePlotBuffer.FIELD_DIMS[0], img.shape[1])\n        y = np.linspace(0, LivePlotBuffer.FIELD_DIMS[1], img.shape[0])\n        x, y = np.meshgrid(x, y)\n        self.ax.plot_surface(\n            x, y, np.atleast_2d(0), rstride=5, cstride=5, facecolors=img\n        )\n\n        plt.pause(0.1)\n\n        self.bg = self.fig.canvas.copy_from_bbox(self.fig.bbox)\n        self.ax.draw_artist(self.poses)\n        self.ax.draw_artist(self.poses2_d)\n        self.ax.draw_artist(self.tags)\n        self.fig.canvas.blit(self.fig.bbox)\n\n    def update(self, pose, tags):\n        self.fig.canvas.restore_region(self.bg)\n\n        if pose != (2767, 2767, 2767):\n            self.x.append(pose[0])\n            self.y.append(pose[1])\n            self.z.append(pose[2])\n\n        self.x = self.x[-50:]\n        self.y = self.y[-50:]\n        self.z = self.z[-50:]\n        self.poses.set_data(self.x, self.y)\n        self.poses.set_3d_properties(self.z)\n        self.poses2_d.set_data(self.x, self.y)\n        self.poses2_d.set_3d_properties(np.atleast_1d(0))\n\n        tagsX = [\n            (\n                self.tag_layout[tag - 1][\"pose\"][\"translation\"][\"x\"]\n                if (tag < 9 and tag > 0)\n                else 2767\n            )\n            for tag in tags\n        ]\n        tagsY = [\n            (\n                self.tag_layout[tag - 1][\"pose\"][\"translation\"][\"y\"]\n                if (tag < 9 and tag > 0)\n                else 2767\n            )\n            for tag in tags\n        ]\n\n        self.tags.set_data(tagsX, tagsY)\n        self.tags.set_3d_properties(np.atleast_1d(0))\n\n        self.ax.draw_artist(self.poses2_d)\n        self.ax.draw_artist(self.poses)\n        self.ax.draw_artist(self.tags)\n        self.fig.canvas.blit(self.fig.bbox)\n        self.fig.canvas.flush_events()\n\n        plot = np.frombuffer(self.fig.canvas.tostring_rgb(), dtype=np.uint8)\n        img = plot.reshape(self.fig.canvas.get_width_height()[::-1] + (3,))\n        self.outputFrame = simplejpeg.encode_jpeg(img)\n", "import cv2\nimport logging\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.image as mpimg\nimport json\nimport simplejpeg\nimport time\nimport asyncio\n\nlogger = logging.getLogger(__name__)\n\n\nclass Buffer:\n    output_frame = b\"\"\n    last_none = False\n\n    def update(self, img):\n        if img is None:\n            if not self.last_none:\n                logger.error(\"Updated image is None - Skipping\")\n            self.last_none = True\n            return\n        if self.last_none:\n            logger.info(\"Updated image is NOT none!\")\n        self.last_none = False\n        self.output_frame = cv2.imencode(\".jpg\", img)[1].tobytes()\n        # encoded = simplejpeg.encode_jpeg(img)\n        # if (img == encoded).all():\n        #     logger.warning(\"Frame did not update!\")\n        # self.outputFrame = encoded\n\n    def output(self):\n        # await asyncio.sleep(0.1)\n        while True:\n            yield (\n                b\"--frame\\r\\n\"\n                b\"Content-Type: image/jpeg\\r\\n\\r\\n\" + self.output_frame + b\"\\r\\n\"\n            )\n\n\nclass LivePlotBuffer(Buffer):\n    FIELD_DIMS = (16.54, 8.02)\n\n    def __init__(self):\n        super(LivePlotBuffer, self).__init__()\n\n        with open(\"./processing/april_tag_layout.json\", \"r\") as f:\n            self.tag_layout = json.load(f)\n            logger.info(\"Tag layout loaded\")\n        self.tag_layout = self.tag_layout[\"tags\"]\n        self.fig = plt.figure()\n        self.ax = self.fig.add_subplot(111, projection=\"3d\")\n        self.ax.view_init(elev=35, azim=-80, roll=0)\n        self.x, self.y, self.z = [], [], []\n        (self.poses2D,) = self.ax.plot3D(\n            self.x,\n            self.y,\n            np.atleast_1d(0),\n            marker=\">\",\n            markevery=[-1],\n            zorder=10,\n            animated=True,\n        )\n        (self.poses,) = self.ax.plot3D(\n            self.x,\n            self.y,\n            self.z,\n            marker=\"o\",\n            markevery=[-1],\n            zorder=100,\n            animated=True,\n        )\n        (self.tags,) = self.ax.plot3D(\n            [],\n            [],\n            0,\n            \"s\",\n            zorder=200,\n            animated=True,\n        )\n        self.ax.set_xlim(0, LivePlotBuffer.FIELD_DIMS[0])\n        self.ax.set_ylim(0, LivePlotBuffer.FIELD_DIMS[1])\n        self.ax.set_zlim(0, 2)\n        plt.locator_params(axis=\"z\", nbins=2)\n        self.ax.set_aspect(\"equal\")\n        self.fig.tight_layout()\n        self.fig.subplots_adjust(left=-0.26, right=1.21, bottom=-0.08, top=1.08)\n\n        img = mpimg.imread(\"./web_interface/field.png\")\n        x = np.linspace(0, LivePlotBuffer.FIELD_DIMS[0], img.shape[1])\n        y = np.linspace(0, LivePlotBuffer.FIELD_DIMS[1], img.shape[0])\n        x, y = np.meshgrid(x, y)\n        self.ax.plot_surface(\n            x, y, np.atleast_2d(0), rstride=5, cstride=5, facecolors=img\n        )\n\n        plt.pause(0.1)\n\n        self.bg = self.fig.canvas.copy_from_bbox(self.fig.bbox)\n        self.ax.draw_artist(self.poses)\n        self.ax.draw_artist(self.poses2D)\n        self.ax.draw_artist(self.tags)\n        self.fig.canvas.blit(self.fig.bbox)\n\n    def update(self, pose, tags):\n        self.fig.canvas.restore_region(self.bg)\n\n        if pose != (2767, 2767, 2767):\n            self.x.append(pose[0])\n            self.y.append(pose[1])\n            self.z.append(pose[2])\n\n        self.x = self.x[-50:]\n        self.y = self.y[-50:]\n        self.z = self.z[-50:]\n        self.poses.set_data(self.x, self.y)\n        self.poses.set_3d_properties(self.z)\n        self.poses2D.set_data(self.x, self.y)\n        self.poses2D.set_3d_properties(np.atleast_1d(0))\n\n        tagsX = [\n            (\n                self.tag_layout[tag - 1][\"pose\"][\"translation\"][\"x\"]\n                if (tag < 9 and tag > 0)\n                else 2767\n            )\n            for tag in tags\n        ]\n        tagsY = [\n            (\n                self.tag_layout[tag - 1][\"pose\"][\"translation\"][\"y\"]\n                if (tag < 9 and tag > 0)\n                else 2767\n            )\n            for tag in tags\n        ]\n\n        self.tags.set_data(tagsX, tagsY)\n        self.tags.set_3d_properties(np.atleast_1d(0))\n\n        self.ax.draw_artist(self.poses2D)\n        self.ax.draw_artist(self.poses)\n        self.ax.draw_artist(self.tags)\n        self.fig.canvas.blit(self.fig.bbox)\n        self.fig.canvas.flush_events()\n\n        plot = np.frombuffer(self.fig.canvas.tostring_rgb(), dtype=np.uint8)\n        img = plot.reshape(self.fig.canvas.get_width_height()[::-1] + (3,))\n        self.outputFrame = simplejpeg.encode_jpeg(img)\n"]]], 1715210931.1415443]], ["ChangeSet", ["Renaming <tagsX> to <tags_x>", [["ChangeContents", ["web_interface/image_streams.py", "import cv2\nimport logging\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.image as mpimg\nimport json\nimport simplejpeg\nimport time\nimport asyncio\n\nlogger = logging.getLogger(__name__)\n\n\nclass Buffer:\n    output_frame = b\"\"\n    last_none = False\n\n    def update(self, img):\n        if img is None:\n            if not self.last_none:\n                logger.error(\"Updated image is None - Skipping\")\n            self.last_none = True\n            return\n        if self.last_none:\n            logger.info(\"Updated image is NOT none!\")\n        self.last_none = False\n        self.output_frame = cv2.imencode(\".jpg\", img)[1].tobytes()\n        # encoded = simplejpeg.encode_jpeg(img)\n        # if (img == encoded).all():\n        #     logger.warning(\"Frame did not update!\")\n        # self.outputFrame = encoded\n\n    def output(self):\n        # await asyncio.sleep(0.1)\n        while True:\n            yield (\n                b\"--frame\\r\\n\"\n                b\"Content-Type: image/jpeg\\r\\n\\r\\n\" + self.output_frame + b\"\\r\\n\"\n            )\n\n\nclass LivePlotBuffer(Buffer):\n    FIELD_DIMS = (16.54, 8.02)\n\n    def __init__(self):\n        super(LivePlotBuffer, self).__init__()\n\n        with open(\"./processing/april_tag_layout.json\", \"r\") as f:\n            self.tag_layout = json.load(f)\n            logger.info(\"Tag layout loaded\")\n        self.tag_layout = self.tag_layout[\"tags\"]\n        self.fig = plt.figure()\n        self.ax = self.fig.add_subplot(111, projection=\"3d\")\n        self.ax.view_init(elev=35, azim=-80, roll=0)\n        self.x, self.y, self.z = [], [], []\n        (self.poses2_d,) = self.ax.plot3D(\n            self.x,\n            self.y,\n            np.atleast_1d(0),\n            marker=\">\",\n            markevery=[-1],\n            zorder=10,\n            animated=True,\n        )\n        (self.poses,) = self.ax.plot3D(\n            self.x,\n            self.y,\n            self.z,\n            marker=\"o\",\n            markevery=[-1],\n            zorder=100,\n            animated=True,\n        )\n        (self.tags,) = self.ax.plot3D(\n            [],\n            [],\n            0,\n            \"s\",\n            zorder=200,\n            animated=True,\n        )\n        self.ax.set_xlim(0, LivePlotBuffer.FIELD_DIMS[0])\n        self.ax.set_ylim(0, LivePlotBuffer.FIELD_DIMS[1])\n        self.ax.set_zlim(0, 2)\n        plt.locator_params(axis=\"z\", nbins=2)\n        self.ax.set_aspect(\"equal\")\n        self.fig.tight_layout()\n        self.fig.subplots_adjust(left=-0.26, right=1.21, bottom=-0.08, top=1.08)\n\n        img = mpimg.imread(\"./web_interface/field.png\")\n        x = np.linspace(0, LivePlotBuffer.FIELD_DIMS[0], img.shape[1])\n        y = np.linspace(0, LivePlotBuffer.FIELD_DIMS[1], img.shape[0])\n        x, y = np.meshgrid(x, y)\n        self.ax.plot_surface(\n            x, y, np.atleast_2d(0), rstride=5, cstride=5, facecolors=img\n        )\n\n        plt.pause(0.1)\n\n        self.bg = self.fig.canvas.copy_from_bbox(self.fig.bbox)\n        self.ax.draw_artist(self.poses)\n        self.ax.draw_artist(self.poses2_d)\n        self.ax.draw_artist(self.tags)\n        self.fig.canvas.blit(self.fig.bbox)\n\n    def update(self, pose, tags):\n        self.fig.canvas.restore_region(self.bg)\n\n        if pose != (2767, 2767, 2767):\n            self.x.append(pose[0])\n            self.y.append(pose[1])\n            self.z.append(pose[2])\n\n        self.x = self.x[-50:]\n        self.y = self.y[-50:]\n        self.z = self.z[-50:]\n        self.poses.set_data(self.x, self.y)\n        self.poses.set_3d_properties(self.z)\n        self.poses2_d.set_data(self.x, self.y)\n        self.poses2_d.set_3d_properties(np.atleast_1d(0))\n\n        tags_x = [\n            (\n                self.tag_layout[tag - 1][\"pose\"][\"translation\"][\"x\"]\n                if (tag < 9 and tag > 0)\n                else 2767\n            )\n            for tag in tags\n        ]\n        tagsY = [\n            (\n                self.tag_layout[tag - 1][\"pose\"][\"translation\"][\"y\"]\n                if (tag < 9 and tag > 0)\n                else 2767\n            )\n            for tag in tags\n        ]\n\n        self.tags.set_data(tags_x, tagsY)\n        self.tags.set_3d_properties(np.atleast_1d(0))\n\n        self.ax.draw_artist(self.poses2_d)\n        self.ax.draw_artist(self.poses)\n        self.ax.draw_artist(self.tags)\n        self.fig.canvas.blit(self.fig.bbox)\n        self.fig.canvas.flush_events()\n\n        plot = np.frombuffer(self.fig.canvas.tostring_rgb(), dtype=np.uint8)\n        img = plot.reshape(self.fig.canvas.get_width_height()[::-1] + (3,))\n        self.outputFrame = simplejpeg.encode_jpeg(img)\n", "import cv2\nimport logging\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.image as mpimg\nimport json\nimport simplejpeg\nimport time\nimport asyncio\n\nlogger = logging.getLogger(__name__)\n\n\nclass Buffer:\n    output_frame = b\"\"\n    last_none = False\n\n    def update(self, img):\n        if img is None:\n            if not self.last_none:\n                logger.error(\"Updated image is None - Skipping\")\n            self.last_none = True\n            return\n        if self.last_none:\n            logger.info(\"Updated image is NOT none!\")\n        self.last_none = False\n        self.output_frame = cv2.imencode(\".jpg\", img)[1].tobytes()\n        # encoded = simplejpeg.encode_jpeg(img)\n        # if (img == encoded).all():\n        #     logger.warning(\"Frame did not update!\")\n        # self.outputFrame = encoded\n\n    def output(self):\n        # await asyncio.sleep(0.1)\n        while True:\n            yield (\n                b\"--frame\\r\\n\"\n                b\"Content-Type: image/jpeg\\r\\n\\r\\n\" + self.output_frame + b\"\\r\\n\"\n            )\n\n\nclass LivePlotBuffer(Buffer):\n    FIELD_DIMS = (16.54, 8.02)\n\n    def __init__(self):\n        super(LivePlotBuffer, self).__init__()\n\n        with open(\"./processing/april_tag_layout.json\", \"r\") as f:\n            self.tag_layout = json.load(f)\n            logger.info(\"Tag layout loaded\")\n        self.tag_layout = self.tag_layout[\"tags\"]\n        self.fig = plt.figure()\n        self.ax = self.fig.add_subplot(111, projection=\"3d\")\n        self.ax.view_init(elev=35, azim=-80, roll=0)\n        self.x, self.y, self.z = [], [], []\n        (self.poses2_d,) = self.ax.plot3D(\n            self.x,\n            self.y,\n            np.atleast_1d(0),\n            marker=\">\",\n            markevery=[-1],\n            zorder=10,\n            animated=True,\n        )\n        (self.poses,) = self.ax.plot3D(\n            self.x,\n            self.y,\n            self.z,\n            marker=\"o\",\n            markevery=[-1],\n            zorder=100,\n            animated=True,\n        )\n        (self.tags,) = self.ax.plot3D(\n            [],\n            [],\n            0,\n            \"s\",\n            zorder=200,\n            animated=True,\n        )\n        self.ax.set_xlim(0, LivePlotBuffer.FIELD_DIMS[0])\n        self.ax.set_ylim(0, LivePlotBuffer.FIELD_DIMS[1])\n        self.ax.set_zlim(0, 2)\n        plt.locator_params(axis=\"z\", nbins=2)\n        self.ax.set_aspect(\"equal\")\n        self.fig.tight_layout()\n        self.fig.subplots_adjust(left=-0.26, right=1.21, bottom=-0.08, top=1.08)\n\n        img = mpimg.imread(\"./web_interface/field.png\")\n        x = np.linspace(0, LivePlotBuffer.FIELD_DIMS[0], img.shape[1])\n        y = np.linspace(0, LivePlotBuffer.FIELD_DIMS[1], img.shape[0])\n        x, y = np.meshgrid(x, y)\n        self.ax.plot_surface(\n            x, y, np.atleast_2d(0), rstride=5, cstride=5, facecolors=img\n        )\n\n        plt.pause(0.1)\n\n        self.bg = self.fig.canvas.copy_from_bbox(self.fig.bbox)\n        self.ax.draw_artist(self.poses)\n        self.ax.draw_artist(self.poses2_d)\n        self.ax.draw_artist(self.tags)\n        self.fig.canvas.blit(self.fig.bbox)\n\n    def update(self, pose, tags):\n        self.fig.canvas.restore_region(self.bg)\n\n        if pose != (2767, 2767, 2767):\n            self.x.append(pose[0])\n            self.y.append(pose[1])\n            self.z.append(pose[2])\n\n        self.x = self.x[-50:]\n        self.y = self.y[-50:]\n        self.z = self.z[-50:]\n        self.poses.set_data(self.x, self.y)\n        self.poses.set_3d_properties(self.z)\n        self.poses2_d.set_data(self.x, self.y)\n        self.poses2_d.set_3d_properties(np.atleast_1d(0))\n\n        tagsX = [\n            (\n                self.tag_layout[tag - 1][\"pose\"][\"translation\"][\"x\"]\n                if (tag < 9 and tag > 0)\n                else 2767\n            )\n            for tag in tags\n        ]\n        tagsY = [\n            (\n                self.tag_layout[tag - 1][\"pose\"][\"translation\"][\"y\"]\n                if (tag < 9 and tag > 0)\n                else 2767\n            )\n            for tag in tags\n        ]\n\n        self.tags.set_data(tagsX, tagsY)\n        self.tags.set_3d_properties(np.atleast_1d(0))\n\n        self.ax.draw_artist(self.poses2_d)\n        self.ax.draw_artist(self.poses)\n        self.ax.draw_artist(self.tags)\n        self.fig.canvas.blit(self.fig.bbox)\n        self.fig.canvas.flush_events()\n\n        plot = np.frombuffer(self.fig.canvas.tostring_rgb(), dtype=np.uint8)\n        img = plot.reshape(self.fig.canvas.get_width_height()[::-1] + (3,))\n        self.outputFrame = simplejpeg.encode_jpeg(img)\n"]]], 1715210935.1149232]], ["ChangeSet", ["Renaming <tagsY> to <tags_y>", [["ChangeContents", ["web_interface/image_streams.py", "import cv2\nimport logging\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.image as mpimg\nimport json\nimport simplejpeg\nimport time\nimport asyncio\n\nlogger = logging.getLogger(__name__)\n\n\nclass Buffer:\n    output_frame = b\"\"\n    last_none = False\n\n    def update(self, img):\n        if img is None:\n            if not self.last_none:\n                logger.error(\"Updated image is None - Skipping\")\n            self.last_none = True\n            return\n        if self.last_none:\n            logger.info(\"Updated image is NOT none!\")\n        self.last_none = False\n        self.output_frame = cv2.imencode(\".jpg\", img)[1].tobytes()\n        # encoded = simplejpeg.encode_jpeg(img)\n        # if (img == encoded).all():\n        #     logger.warning(\"Frame did not update!\")\n        # self.outputFrame = encoded\n\n    def output(self):\n        # await asyncio.sleep(0.1)\n        while True:\n            yield (\n                b\"--frame\\r\\n\"\n                b\"Content-Type: image/jpeg\\r\\n\\r\\n\" + self.output_frame + b\"\\r\\n\"\n            )\n\n\nclass LivePlotBuffer(Buffer):\n    FIELD_DIMS = (16.54, 8.02)\n\n    def __init__(self):\n        super(LivePlotBuffer, self).__init__()\n\n        with open(\"./processing/april_tag_layout.json\", \"r\") as f:\n            self.tag_layout = json.load(f)\n            logger.info(\"Tag layout loaded\")\n        self.tag_layout = self.tag_layout[\"tags\"]\n        self.fig = plt.figure()\n        self.ax = self.fig.add_subplot(111, projection=\"3d\")\n        self.ax.view_init(elev=35, azim=-80, roll=0)\n        self.x, self.y, self.z = [], [], []\n        (self.poses2_d,) = self.ax.plot3D(\n            self.x,\n            self.y,\n            np.atleast_1d(0),\n            marker=\">\",\n            markevery=[-1],\n            zorder=10,\n            animated=True,\n        )\n        (self.poses,) = self.ax.plot3D(\n            self.x,\n            self.y,\n            self.z,\n            marker=\"o\",\n            markevery=[-1],\n            zorder=100,\n            animated=True,\n        )\n        (self.tags,) = self.ax.plot3D(\n            [],\n            [],\n            0,\n            \"s\",\n            zorder=200,\n            animated=True,\n        )\n        self.ax.set_xlim(0, LivePlotBuffer.FIELD_DIMS[0])\n        self.ax.set_ylim(0, LivePlotBuffer.FIELD_DIMS[1])\n        self.ax.set_zlim(0, 2)\n        plt.locator_params(axis=\"z\", nbins=2)\n        self.ax.set_aspect(\"equal\")\n        self.fig.tight_layout()\n        self.fig.subplots_adjust(left=-0.26, right=1.21, bottom=-0.08, top=1.08)\n\n        img = mpimg.imread(\"./web_interface/field.png\")\n        x = np.linspace(0, LivePlotBuffer.FIELD_DIMS[0], img.shape[1])\n        y = np.linspace(0, LivePlotBuffer.FIELD_DIMS[1], img.shape[0])\n        x, y = np.meshgrid(x, y)\n        self.ax.plot_surface(\n            x, y, np.atleast_2d(0), rstride=5, cstride=5, facecolors=img\n        )\n\n        plt.pause(0.1)\n\n        self.bg = self.fig.canvas.copy_from_bbox(self.fig.bbox)\n        self.ax.draw_artist(self.poses)\n        self.ax.draw_artist(self.poses2_d)\n        self.ax.draw_artist(self.tags)\n        self.fig.canvas.blit(self.fig.bbox)\n\n    def update(self, pose, tags):\n        self.fig.canvas.restore_region(self.bg)\n\n        if pose != (2767, 2767, 2767):\n            self.x.append(pose[0])\n            self.y.append(pose[1])\n            self.z.append(pose[2])\n\n        self.x = self.x[-50:]\n        self.y = self.y[-50:]\n        self.z = self.z[-50:]\n        self.poses.set_data(self.x, self.y)\n        self.poses.set_3d_properties(self.z)\n        self.poses2_d.set_data(self.x, self.y)\n        self.poses2_d.set_3d_properties(np.atleast_1d(0))\n\n        tags_x = [\n            (\n                self.tag_layout[tag - 1][\"pose\"][\"translation\"][\"x\"]\n                if (tag < 9 and tag > 0)\n                else 2767\n            )\n            for tag in tags\n        ]\n        tags_y = [\n            (\n                self.tag_layout[tag - 1][\"pose\"][\"translation\"][\"y\"]\n                if (tag < 9 and tag > 0)\n                else 2767\n            )\n            for tag in tags\n        ]\n\n        self.tags.set_data(tags_x, tags_y)\n        self.tags.set_3d_properties(np.atleast_1d(0))\n\n        self.ax.draw_artist(self.poses2_d)\n        self.ax.draw_artist(self.poses)\n        self.ax.draw_artist(self.tags)\n        self.fig.canvas.blit(self.fig.bbox)\n        self.fig.canvas.flush_events()\n\n        plot = np.frombuffer(self.fig.canvas.tostring_rgb(), dtype=np.uint8)\n        img = plot.reshape(self.fig.canvas.get_width_height()[::-1] + (3,))\n        self.outputFrame = simplejpeg.encode_jpeg(img)\n", "import cv2\nimport logging\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.image as mpimg\nimport json\nimport simplejpeg\nimport time\nimport asyncio\n\nlogger = logging.getLogger(__name__)\n\n\nclass Buffer:\n    output_frame = b\"\"\n    last_none = False\n\n    def update(self, img):\n        if img is None:\n            if not self.last_none:\n                logger.error(\"Updated image is None - Skipping\")\n            self.last_none = True\n            return\n        if self.last_none:\n            logger.info(\"Updated image is NOT none!\")\n        self.last_none = False\n        self.output_frame = cv2.imencode(\".jpg\", img)[1].tobytes()\n        # encoded = simplejpeg.encode_jpeg(img)\n        # if (img == encoded).all():\n        #     logger.warning(\"Frame did not update!\")\n        # self.outputFrame = encoded\n\n    def output(self):\n        # await asyncio.sleep(0.1)\n        while True:\n            yield (\n                b\"--frame\\r\\n\"\n                b\"Content-Type: image/jpeg\\r\\n\\r\\n\" + self.output_frame + b\"\\r\\n\"\n            )\n\n\nclass LivePlotBuffer(Buffer):\n    FIELD_DIMS = (16.54, 8.02)\n\n    def __init__(self):\n        super(LivePlotBuffer, self).__init__()\n\n        with open(\"./processing/april_tag_layout.json\", \"r\") as f:\n            self.tag_layout = json.load(f)\n            logger.info(\"Tag layout loaded\")\n        self.tag_layout = self.tag_layout[\"tags\"]\n        self.fig = plt.figure()\n        self.ax = self.fig.add_subplot(111, projection=\"3d\")\n        self.ax.view_init(elev=35, azim=-80, roll=0)\n        self.x, self.y, self.z = [], [], []\n        (self.poses2_d,) = self.ax.plot3D(\n            self.x,\n            self.y,\n            np.atleast_1d(0),\n            marker=\">\",\n            markevery=[-1],\n            zorder=10,\n            animated=True,\n        )\n        (self.poses,) = self.ax.plot3D(\n            self.x,\n            self.y,\n            self.z,\n            marker=\"o\",\n            markevery=[-1],\n            zorder=100,\n            animated=True,\n        )\n        (self.tags,) = self.ax.plot3D(\n            [],\n            [],\n            0,\n            \"s\",\n            zorder=200,\n            animated=True,\n        )\n        self.ax.set_xlim(0, LivePlotBuffer.FIELD_DIMS[0])\n        self.ax.set_ylim(0, LivePlotBuffer.FIELD_DIMS[1])\n        self.ax.set_zlim(0, 2)\n        plt.locator_params(axis=\"z\", nbins=2)\n        self.ax.set_aspect(\"equal\")\n        self.fig.tight_layout()\n        self.fig.subplots_adjust(left=-0.26, right=1.21, bottom=-0.08, top=1.08)\n\n        img = mpimg.imread(\"./web_interface/field.png\")\n        x = np.linspace(0, LivePlotBuffer.FIELD_DIMS[0], img.shape[1])\n        y = np.linspace(0, LivePlotBuffer.FIELD_DIMS[1], img.shape[0])\n        x, y = np.meshgrid(x, y)\n        self.ax.plot_surface(\n            x, y, np.atleast_2d(0), rstride=5, cstride=5, facecolors=img\n        )\n\n        plt.pause(0.1)\n\n        self.bg = self.fig.canvas.copy_from_bbox(self.fig.bbox)\n        self.ax.draw_artist(self.poses)\n        self.ax.draw_artist(self.poses2_d)\n        self.ax.draw_artist(self.tags)\n        self.fig.canvas.blit(self.fig.bbox)\n\n    def update(self, pose, tags):\n        self.fig.canvas.restore_region(self.bg)\n\n        if pose != (2767, 2767, 2767):\n            self.x.append(pose[0])\n            self.y.append(pose[1])\n            self.z.append(pose[2])\n\n        self.x = self.x[-50:]\n        self.y = self.y[-50:]\n        self.z = self.z[-50:]\n        self.poses.set_data(self.x, self.y)\n        self.poses.set_3d_properties(self.z)\n        self.poses2_d.set_data(self.x, self.y)\n        self.poses2_d.set_3d_properties(np.atleast_1d(0))\n\n        tags_x = [\n            (\n                self.tag_layout[tag - 1][\"pose\"][\"translation\"][\"x\"]\n                if (tag < 9 and tag > 0)\n                else 2767\n            )\n            for tag in tags\n        ]\n        tagsY = [\n            (\n                self.tag_layout[tag - 1][\"pose\"][\"translation\"][\"y\"]\n                if (tag < 9 and tag > 0)\n                else 2767\n            )\n            for tag in tags\n        ]\n\n        self.tags.set_data(tags_x, tagsY)\n        self.tags.set_3d_properties(np.atleast_1d(0))\n\n        self.ax.draw_artist(self.poses2_d)\n        self.ax.draw_artist(self.poses)\n        self.ax.draw_artist(self.tags)\n        self.fig.canvas.blit(self.fig.bbox)\n        self.fig.canvas.flush_events()\n\n        plot = np.frombuffer(self.fig.canvas.tostring_rgb(), dtype=np.uint8)\n        img = plot.reshape(self.fig.canvas.get_width_height()[::-1] + (3,))\n        self.outputFrame = simplejpeg.encode_jpeg(img)\n"]]], 1715210936.210368]], ["ChangeSet", ["Renaming <outputFrame> to <output_frame>", [["ChangeContents", ["web_interface/image_streams.py", "import cv2\nimport logging\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.image as mpimg\nimport json\nimport simplejpeg\nimport time\nimport asyncio\n\nlogger = logging.getLogger(__name__)\n\n\nclass Buffer:\n    output_frame = b\"\"\n    last_none = False\n\n    def update(self, img):\n        if img is None:\n            if not self.last_none:\n                logger.error(\"Updated image is None - Skipping\")\n            self.last_none = True\n            return\n        if self.last_none:\n            logger.info(\"Updated image is NOT none!\")\n        self.last_none = False\n        self.output_frame = cv2.imencode(\".jpg\", img)[1].tobytes()\n        # encoded = simplejpeg.encode_jpeg(img)\n        # if (img == encoded).all():\n        #     logger.warning(\"Frame did not update!\")\n        # self.outputFrame = encoded\n\n    def output(self):\n        # await asyncio.sleep(0.1)\n        while True:\n            yield (\n                b\"--frame\\r\\n\"\n                b\"Content-Type: image/jpeg\\r\\n\\r\\n\" + self.output_frame + b\"\\r\\n\"\n            )\n\n\nclass LivePlotBuffer(Buffer):\n    FIELD_DIMS = (16.54, 8.02)\n\n    def __init__(self):\n        super(LivePlotBuffer, self).__init__()\n\n        with open(\"./processing/april_tag_layout.json\", \"r\") as f:\n            self.tag_layout = json.load(f)\n            logger.info(\"Tag layout loaded\")\n        self.tag_layout = self.tag_layout[\"tags\"]\n        self.fig = plt.figure()\n        self.ax = self.fig.add_subplot(111, projection=\"3d\")\n        self.ax.view_init(elev=35, azim=-80, roll=0)\n        self.x, self.y, self.z = [], [], []\n        (self.poses2_d,) = self.ax.plot3D(\n            self.x,\n            self.y,\n            np.atleast_1d(0),\n            marker=\">\",\n            markevery=[-1],\n            zorder=10,\n            animated=True,\n        )\n        (self.poses,) = self.ax.plot3D(\n            self.x,\n            self.y,\n            self.z,\n            marker=\"o\",\n            markevery=[-1],\n            zorder=100,\n            animated=True,\n        )\n        (self.tags,) = self.ax.plot3D(\n            [],\n            [],\n            0,\n            \"s\",\n            zorder=200,\n            animated=True,\n        )\n        self.ax.set_xlim(0, LivePlotBuffer.FIELD_DIMS[0])\n        self.ax.set_ylim(0, LivePlotBuffer.FIELD_DIMS[1])\n        self.ax.set_zlim(0, 2)\n        plt.locator_params(axis=\"z\", nbins=2)\n        self.ax.set_aspect(\"equal\")\n        self.fig.tight_layout()\n        self.fig.subplots_adjust(left=-0.26, right=1.21, bottom=-0.08, top=1.08)\n\n        img = mpimg.imread(\"./web_interface/field.png\")\n        x = np.linspace(0, LivePlotBuffer.FIELD_DIMS[0], img.shape[1])\n        y = np.linspace(0, LivePlotBuffer.FIELD_DIMS[1], img.shape[0])\n        x, y = np.meshgrid(x, y)\n        self.ax.plot_surface(\n            x, y, np.atleast_2d(0), rstride=5, cstride=5, facecolors=img\n        )\n\n        plt.pause(0.1)\n\n        self.bg = self.fig.canvas.copy_from_bbox(self.fig.bbox)\n        self.ax.draw_artist(self.poses)\n        self.ax.draw_artist(self.poses2_d)\n        self.ax.draw_artist(self.tags)\n        self.fig.canvas.blit(self.fig.bbox)\n\n    def update(self, pose, tags):\n        self.fig.canvas.restore_region(self.bg)\n\n        if pose != (2767, 2767, 2767):\n            self.x.append(pose[0])\n            self.y.append(pose[1])\n            self.z.append(pose[2])\n\n        self.x = self.x[-50:]\n        self.y = self.y[-50:]\n        self.z = self.z[-50:]\n        self.poses.set_data(self.x, self.y)\n        self.poses.set_3d_properties(self.z)\n        self.poses2_d.set_data(self.x, self.y)\n        self.poses2_d.set_3d_properties(np.atleast_1d(0))\n\n        tags_x = [\n            (\n                self.tag_layout[tag - 1][\"pose\"][\"translation\"][\"x\"]\n                if (tag < 9 and tag > 0)\n                else 2767\n            )\n            for tag in tags\n        ]\n        tags_y = [\n            (\n                self.tag_layout[tag - 1][\"pose\"][\"translation\"][\"y\"]\n                if (tag < 9 and tag > 0)\n                else 2767\n            )\n            for tag in tags\n        ]\n\n        self.tags.set_data(tags_x, tags_y)\n        self.tags.set_3d_properties(np.atleast_1d(0))\n\n        self.ax.draw_artist(self.poses2_d)\n        self.ax.draw_artist(self.poses)\n        self.ax.draw_artist(self.tags)\n        self.fig.canvas.blit(self.fig.bbox)\n        self.fig.canvas.flush_events()\n\n        plot = np.frombuffer(self.fig.canvas.tostring_rgb(), dtype=np.uint8)\n        img = plot.reshape(self.fig.canvas.get_width_height()[::-1] + (3,))\n        self.output_frame = simplejpeg.encode_jpeg(img)\n", "import cv2\nimport logging\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.image as mpimg\nimport json\nimport simplejpeg\nimport time\nimport asyncio\n\nlogger = logging.getLogger(__name__)\n\n\nclass Buffer:\n    output_frame = b\"\"\n    last_none = False\n\n    def update(self, img):\n        if img is None:\n            if not self.last_none:\n                logger.error(\"Updated image is None - Skipping\")\n            self.last_none = True\n            return\n        if self.last_none:\n            logger.info(\"Updated image is NOT none!\")\n        self.last_none = False\n        self.output_frame = cv2.imencode(\".jpg\", img)[1].tobytes()\n        # encoded = simplejpeg.encode_jpeg(img)\n        # if (img == encoded).all():\n        #     logger.warning(\"Frame did not update!\")\n        # self.outputFrame = encoded\n\n    def output(self):\n        # await asyncio.sleep(0.1)\n        while True:\n            yield (\n                b\"--frame\\r\\n\"\n                b\"Content-Type: image/jpeg\\r\\n\\r\\n\" + self.output_frame + b\"\\r\\n\"\n            )\n\n\nclass LivePlotBuffer(Buffer):\n    FIELD_DIMS = (16.54, 8.02)\n\n    def __init__(self):\n        super(LivePlotBuffer, self).__init__()\n\n        with open(\"./processing/april_tag_layout.json\", \"r\") as f:\n            self.tag_layout = json.load(f)\n            logger.info(\"Tag layout loaded\")\n        self.tag_layout = self.tag_layout[\"tags\"]\n        self.fig = plt.figure()\n        self.ax = self.fig.add_subplot(111, projection=\"3d\")\n        self.ax.view_init(elev=35, azim=-80, roll=0)\n        self.x, self.y, self.z = [], [], []\n        (self.poses2_d,) = self.ax.plot3D(\n            self.x,\n            self.y,\n            np.atleast_1d(0),\n            marker=\">\",\n            markevery=[-1],\n            zorder=10,\n            animated=True,\n        )\n        (self.poses,) = self.ax.plot3D(\n            self.x,\n            self.y,\n            self.z,\n            marker=\"o\",\n            markevery=[-1],\n            zorder=100,\n            animated=True,\n        )\n        (self.tags,) = self.ax.plot3D(\n            [],\n            [],\n            0,\n            \"s\",\n            zorder=200,\n            animated=True,\n        )\n        self.ax.set_xlim(0, LivePlotBuffer.FIELD_DIMS[0])\n        self.ax.set_ylim(0, LivePlotBuffer.FIELD_DIMS[1])\n        self.ax.set_zlim(0, 2)\n        plt.locator_params(axis=\"z\", nbins=2)\n        self.ax.set_aspect(\"equal\")\n        self.fig.tight_layout()\n        self.fig.subplots_adjust(left=-0.26, right=1.21, bottom=-0.08, top=1.08)\n\n        img = mpimg.imread(\"./web_interface/field.png\")\n        x = np.linspace(0, LivePlotBuffer.FIELD_DIMS[0], img.shape[1])\n        y = np.linspace(0, LivePlotBuffer.FIELD_DIMS[1], img.shape[0])\n        x, y = np.meshgrid(x, y)\n        self.ax.plot_surface(\n            x, y, np.atleast_2d(0), rstride=5, cstride=5, facecolors=img\n        )\n\n        plt.pause(0.1)\n\n        self.bg = self.fig.canvas.copy_from_bbox(self.fig.bbox)\n        self.ax.draw_artist(self.poses)\n        self.ax.draw_artist(self.poses2_d)\n        self.ax.draw_artist(self.tags)\n        self.fig.canvas.blit(self.fig.bbox)\n\n    def update(self, pose, tags):\n        self.fig.canvas.restore_region(self.bg)\n\n        if pose != (2767, 2767, 2767):\n            self.x.append(pose[0])\n            self.y.append(pose[1])\n            self.z.append(pose[2])\n\n        self.x = self.x[-50:]\n        self.y = self.y[-50:]\n        self.z = self.z[-50:]\n        self.poses.set_data(self.x, self.y)\n        self.poses.set_3d_properties(self.z)\n        self.poses2_d.set_data(self.x, self.y)\n        self.poses2_d.set_3d_properties(np.atleast_1d(0))\n\n        tags_x = [\n            (\n                self.tag_layout[tag - 1][\"pose\"][\"translation\"][\"x\"]\n                if (tag < 9 and tag > 0)\n                else 2767\n            )\n            for tag in tags\n        ]\n        tags_y = [\n            (\n                self.tag_layout[tag - 1][\"pose\"][\"translation\"][\"y\"]\n                if (tag < 9 and tag > 0)\n                else 2767\n            )\n            for tag in tags\n        ]\n\n        self.tags.set_data(tags_x, tags_y)\n        self.tags.set_3d_properties(np.atleast_1d(0))\n\n        self.ax.draw_artist(self.poses2_d)\n        self.ax.draw_artist(self.poses)\n        self.ax.draw_artist(self.tags)\n        self.fig.canvas.blit(self.fig.bbox)\n        self.fig.canvas.flush_events()\n\n        plot = np.frombuffer(self.fig.canvas.tostring_rgb(), dtype=np.uint8)\n        img = plot.reshape(self.fig.canvas.get_width_height()[::-1] + (3,))\n        self.outputFrame = simplejpeg.encode_jpeg(img)\n"]]], 1715210938.4663312]], ["ChangeSet", ["Renaming <camBuffers> to <cam_buffers>", [["ChangeContents", ["web_interface/web_interface.py", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualizationBuffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(camID, newValue):\n    walleye_data.cameras.setBrightness(camID, float(newValue))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(camID, newValue):\n    walleye_data.cameras.setExposure(camID, float(newValue))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(camID, newValue):\n    w, h = map(int, newValue[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(camID, (w, h)):\n        walleye_data.status = f\"Resolution set to {newValue}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {newValue}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(camID):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = camID\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {camID}\")\n        walleye_data.status = f\"Starting calibration capture for {camID}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(camID):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = camID\n    walleye_data.cameras.info[camID].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(camID, file):\n    with open(\n        calibration_path_by_cam(camID, walleye_data.cameras.info[camID].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        calData = json.loads(file.decode())\n        calData[\"camPath\"] = camID\n        json.dump(calData, outFile)\n\n        # Load\n        calData[\"K\"] = np.asarray(calData[\"K\"])\n        calData[\"dist\"] = np.asarray(calData[\"dist\"])\n        walleye_data.cameras.setCalibration(camID, calData[\"K\"], calData[\"dist\"])\n        walleye_data.cameras.info[camID].calibrationPath = calibration_path_by_cam(\n            camID, walleye_data.cameras.info[camID].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {camID}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for camID in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(camID)\n            logger.info(f\"Camera config imported for {camID}\")\n\n    logger.info(f\"Configs sucessfully imported for {camID}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[camID].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    return Response(\n        visualizationBuffers[camID].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncamBuffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualizationBuffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(camID, newValue):\n    walleye_data.cameras.setBrightness(camID, float(newValue))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(camID, newValue):\n    walleye_data.cameras.setExposure(camID, float(newValue))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(camID, newValue):\n    w, h = map(int, newValue[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(camID, (w, h)):\n        walleye_data.status = f\"Resolution set to {newValue}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {newValue}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(camID):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = camID\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {camID}\")\n        walleye_data.status = f\"Starting calibration capture for {camID}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(camID):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = camID\n    walleye_data.cameras.info[camID].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(camID, file):\n    with open(\n        calibration_path_by_cam(camID, walleye_data.cameras.info[camID].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        calData = json.loads(file.decode())\n        calData[\"camPath\"] = camID\n        json.dump(calData, outFile)\n\n        # Load\n        calData[\"K\"] = np.asarray(calData[\"K\"])\n        calData[\"dist\"] = np.asarray(calData[\"dist\"])\n        walleye_data.cameras.setCalibration(camID, calData[\"K\"], calData[\"dist\"])\n        walleye_data.cameras.info[camID].calibrationPath = calibration_path_by_cam(\n            camID, walleye_data.cameras.info[camID].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {camID}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for camID in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(camID)\n            logger.info(f\"Camera config imported for {camID}\")\n\n    logger.info(f\"Configs sucessfully imported for {camID}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(camID):\n    if camID not in camBuffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        camBuffers[camID].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(camID):\n    if camID not in camBuffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    return Response(\n        visualizationBuffers[camID].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n"]], ["ChangeContents", ["init.py", "import sys\nimport logging\nfrom logging.handlers import RotatingFileHandler\nfrom directory import calibration_image_folder, calibration_path_by_cam, LOG\n\n# Create logger and set settings\nLOG_FORMAT = \"[%(asctime)s - %(levelname)s - %(filename)s:%(lineno)s - %(funcName)s()]  %(message)s\"\nlogging.basicConfig(\n    format=LOG_FORMAT,\n    handlers=[\n        logging.StreamHandler(sys.stdout),\n        RotatingFileHandler(LOG, maxBytes_XxX_CamelSnakePep8_PreserveName_XxX_2=1024 * 1024, backupCount_XxX_CamelSnakePep8_PreserveName_XxX_3=5),\n    ],\n    datefmt=\"%d-%b-%y %H:%M:%S\",\n    level=logging.INFO,\n)\n\nlogger = logging.getLogger(__name__)\n\nlogger.info(\"----------- Starting Up -----------\")\n\nfrom state import walleye_data, States, CALIBRATION_STATES\nfrom processing.processing import Processor\nimport threading\nfrom camera.camera import Cameras\nfrom calibration.calibration import Calibration, CalibType_XxX_CamelSnakePep8_PreserveName_XxX_4\nimport time\n\n\n# Create and intialize cameras\nwalleye_data.cameras = Cameras()\n\nfrom web_interface.web_interface import (\n    cam_buffers,\n    socketio,\n    app,\n    visualizationBuffers\n)  # After walleye_data.cameras is set\n\nweb_server = threading.Thread(\n    target=lambda: socketio.run(\n        app,\n        host=\"0.0.0.0\",\n        port=5800,\n        debug=False,\n        use_reloader=False,\n        log_output=False,\n    ),\n    daemon=True,\n)\ntry:\n    # Start the web server\n    web_server.start()\n\n    logging.getLogger(\"geventwebsocket.handler\").setLevel(logging.ERROR)\n    logging.getLogger(\"socketio\").setLevel(logging.ERROR)\n    logging.getLogger(\"socketio.server\").setLevel(logging.ERROR)\n    logging.getLogger(\"engineio\").setLevel(logging.ERROR)\n\n\n    logger.info(\"Web server ready\")\n\n    images = {}\n    calibrators = {}\n\n    # Create network tables publisher and AprilTag Processor\n    pose_estimator = Processor(walleye_data.tag_size)\n    # Publisher already created during construction of walleye_data\n    # walleye_data.make_publisher(walleye_data.team_number, walleye_data.table_name)\n    walleye_data.current_state = States.PROCESSING\n\n    logger.info(\"Starting main loop\")\n\n    last_loop_time = time.time()\n\n    # Main loop (Runs everything)\n    while True:\n        # Calculate loop time\n        curr_time = time.time()\n        walleye_data.loop_time = round(curr_time - last_loop_time, 3)\n        last_loop_time = curr_time\n\n        # State changes\n        # Pre-Calibration\n        if walleye_data.current_state == States.BEGIN_CALIBRATION:\n            logger.info(\"Beginning calibration\")\n\n            # Prepare a calibration object for the camera that is being calibrated with pre-set data\n            # only if cal object does not exist yet\n            if (\n                walleye_data.camera_in_calibration not in calibrators\n                or calibrators[walleye_data.camera_in_calibration] is None\n            ):\n                calibrators[walleye_data.camera_in_calibration] = Calibration(\n                    walleye_data.cal_delay,\n                    walleye_data.board_dims,\n                    walleye_data.camera_in_calibration,\n                    calibration_image_folder(walleye_data.camera_in_calibration),\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].resolution,\n                )\n            walleye_data.current_state = States.CALIBRATION_CAPTURE\n\n        # Take calibration images\n        elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n            # Read in frames\n            ret, img = walleye_data.cameras.info[\n                walleye_data.camera_in_calibration\n            ].cam.read()\n\n            if not ret:\n                logger.error(\n                    f\"Failed to capture image: {walleye_data.camera_in_calibration}\"\n                )\n            else:\n                # Process frames with the calibration object created prior\n                returned, used, path_saved = calibrators[\n                    walleye_data.camera_in_calibration\n                ].processFrame(img)\n\n                # If the image is a part of the accepted images save it\n                if used:\n                    walleye_data.cal_img_paths.append(path_saved)\n\n                # Keep a buffer with the images\n                cam_buffers[walleye_data.camera_in_calibration].update(returned)\n\n        # Finished Calibration, generate calibration\n        elif walleye_data.current_state == States.GENERATE_CALIBRATION:\n            # Get file path for the calibration to be saved\n            walleye_data.cameras.info[\n                walleye_data.camera_in_calibration\n            ].calibrationPath = calibration_path_by_cam(\n                walleye_data.camera_in_calibration,\n                walleye_data.cameras.info[walleye_data.camera_in_calibration].resolution,\n            )\n\n            if calibrators[walleye_data.camera_in_calibration] is not None:\n                # Generate a calibration file to the file path\n                has_generated = calibrators[\n                    walleye_data.camera_in_calibration\n                ].generateCalibration(\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].calibrationPath\n                )\n\n                if has_generated:\n                    # Get reproj error\n                    walleye_data.reprojection_error = calibrators[\n                        walleye_data.camera_in_calibration\n                    ].getReprojectionError()\n\n                    # Set the cameras calibration, save off the file path, and\n                    # go to idle\n                    walleye_data.cameras.setCalibration(\n                        walleye_data.camera_in_calibration,\n                        calibrators[walleye_data.camera_in_calibration].calibrationData[\n                            \"K\"\n                        ],\n                        calibrators[walleye_data.camera_in_calibration].calibrationData[\n                            \"dist\"\n                        ],\n                    )\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].calibrationPath = calibration_path_by_cam(\n                        walleye_data.camera_in_calibration,\n                        walleye_data.cameras.info[\n                            walleye_data.camera_in_calibration\n                        ].resolution,\n                    )\n                else:\n                    walleye_data.status = \"Could not generate calibration\"\n            else:\n                walleye_data.status = \"Calibrator for current calibration camera is None\"\n            walleye_data.current_state = States.IDLE\n            calibrators[walleye_data.camera_in_calibration] = None\n\n        # AprilTag processing state\n        elif walleye_data.current_state == States.PROCESSING:\n            # Set tag size, grab camera frames, and grab image timestamp\n            pose_estimator.set_tag_size(walleye_data.tag_size)\n\n            image_time = walleye_data.robot_publisher.get_time() \n\n            connections, images, delay = walleye_data.cameras.getFramesForProcessing()\n\n            for idx, val in enumerate(connections.values()):\n                if not val and walleye_data.robot_publisher.getConnectionValue_XxX_CamelSnakePep8_PreserveName_XxX_7(idx):\n                    logger.info(\"Camera disconnected\")\n\n                walleye_data.robot_publisher.setConnectionValue_XxX_CamelSnakePep8_PreserveName_XxX_6(idx, val)\n\n            # Use the pose_estimator class to find the pose, tags, and ambiguity\n            poses, tags, ambig = pose_estimator.get_pose(\n                images.values(),\n                walleye_data.cameras.listK(),\n                walleye_data.cameras.listD(),\n            )\n\n            # Publish camera number, timestamp, poses, tags, ambiguity and increase the update number\n            # logger.info(f\"Poses at {image_time}: {poses}\")\n\n            for i in range(len(poses)):\n                if poses[i][0].X() < 2000:\n                    walleye_data.robot_publisher.publish(\n                        i, image_time - delay[i], poses[i], tags[i], ambig[i]\n                    )\n\n            # Update the pose visualization\n            for i, (identifier, img) in enumerate(images.items()):\n                if i >= len(poses):\n                    break\n                cam_buffers[identifier].update(img)\n                walleye_data.set_pose(identifier, poses[i][0])\n                if walleye_data.visualizing_poses:\n                    visualizationBuffers[identifier].update(\n                        (poses[i][0].X(), poses[i][0].Y(), poses[i][0].Z()), tags[i][1:]\n                    )\n\n        # Ends the WallEye program through the web interface\n        elif walleye_data.current_state == States.SHUTDOWN:\n            logger.info(\"Shutting down\")\n            logging.shutdown()\n            socketio.stop()\n            break\n\n        # Update cameras no matter what state\n        if walleye_data.current_state != States.PROCESSING:\n            for camera_info in walleye_data.cameras.info.values():\n                if (\n                    camera_info.identifier == walleye_data.camera_in_calibration\n                    and walleye_data.current_state in CALIBRATION_STATES\n                ):\n                    continue\n\n                ret, img = camera_info.cam.read()\n\n                cam_buffers[camera_info.identifier].update(img)\n\nexcept Exception as e:\n    # Something bad happened\n    logging.critical(e, exc_info=True)\n    logger.info(\"Shutting down\")\n    socketio.stop()\n    logging.shutdown()\n", "import sys\nimport logging\nfrom logging.handlers import RotatingFileHandler\nfrom directory import calibration_image_folder, calibration_path_by_cam, LOG\n\n# Create logger and set settings\nLOG_FORMAT = \"[%(asctime)s - %(levelname)s - %(filename)s:%(lineno)s - %(funcName)s()]  %(message)s\"\nlogging.basicConfig(\n    format=LOG_FORMAT,\n    handlers=[\n        logging.StreamHandler(sys.stdout),\n        RotatingFileHandler(LOG, maxBytes_XxX_CamelSnakePep8_PreserveName_XxX_2=1024 * 1024, backupCount_XxX_CamelSnakePep8_PreserveName_XxX_3=5),\n    ],\n    datefmt=\"%d-%b-%y %H:%M:%S\",\n    level=logging.INFO,\n)\n\nlogger = logging.getLogger(__name__)\n\nlogger.info(\"----------- Starting Up -----------\")\n\nfrom state import walleye_data, States, CALIBRATION_STATES\nfrom processing.processing import Processor\nimport threading\nfrom camera.camera import Cameras\nfrom calibration.calibration import Calibration, CalibType_XxX_CamelSnakePep8_PreserveName_XxX_4\nimport time\n\n\n# Create and intialize cameras\nwalleye_data.cameras = Cameras()\n\nfrom web_interface.web_interface import (\n    camBuffers,\n    socketio,\n    app,\n    visualizationBuffers\n)  # After walleye_data.cameras is set\n\nweb_server = threading.Thread(\n    target=lambda: socketio.run(\n        app,\n        host=\"0.0.0.0\",\n        port=5800,\n        debug=False,\n        use_reloader=False,\n        log_output=False,\n    ),\n    daemon=True,\n)\ntry:\n    # Start the web server\n    web_server.start()\n\n    logging.getLogger(\"geventwebsocket.handler\").setLevel(logging.ERROR)\n    logging.getLogger(\"socketio\").setLevel(logging.ERROR)\n    logging.getLogger(\"socketio.server\").setLevel(logging.ERROR)\n    logging.getLogger(\"engineio\").setLevel(logging.ERROR)\n\n\n    logger.info(\"Web server ready\")\n\n    images = {}\n    calibrators = {}\n\n    # Create network tables publisher and AprilTag Processor\n    pose_estimator = Processor(walleye_data.tag_size)\n    # Publisher already created during construction of walleye_data\n    # walleye_data.make_publisher(walleye_data.team_number, walleye_data.table_name)\n    walleye_data.current_state = States.PROCESSING\n\n    logger.info(\"Starting main loop\")\n\n    last_loop_time = time.time()\n\n    # Main loop (Runs everything)\n    while True:\n        # Calculate loop time\n        curr_time = time.time()\n        walleye_data.loop_time = round(curr_time - last_loop_time, 3)\n        last_loop_time = curr_time\n\n        # State changes\n        # Pre-Calibration\n        if walleye_data.current_state == States.BEGIN_CALIBRATION:\n            logger.info(\"Beginning calibration\")\n\n            # Prepare a calibration object for the camera that is being calibrated with pre-set data\n            # only if cal object does not exist yet\n            if (\n                walleye_data.camera_in_calibration not in calibrators\n                or calibrators[walleye_data.camera_in_calibration] is None\n            ):\n                calibrators[walleye_data.camera_in_calibration] = Calibration(\n                    walleye_data.cal_delay,\n                    walleye_data.board_dims,\n                    walleye_data.camera_in_calibration,\n                    calibration_image_folder(walleye_data.camera_in_calibration),\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].resolution,\n                )\n            walleye_data.current_state = States.CALIBRATION_CAPTURE\n\n        # Take calibration images\n        elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n            # Read in frames\n            ret, img = walleye_data.cameras.info[\n                walleye_data.camera_in_calibration\n            ].cam.read()\n\n            if not ret:\n                logger.error(\n                    f\"Failed to capture image: {walleye_data.camera_in_calibration}\"\n                )\n            else:\n                # Process frames with the calibration object created prior\n                returned, used, path_saved = calibrators[\n                    walleye_data.camera_in_calibration\n                ].processFrame(img)\n\n                # If the image is a part of the accepted images save it\n                if used:\n                    walleye_data.cal_img_paths.append(path_saved)\n\n                # Keep a buffer with the images\n                camBuffers[walleye_data.camera_in_calibration].update(returned)\n\n        # Finished Calibration, generate calibration\n        elif walleye_data.current_state == States.GENERATE_CALIBRATION:\n            # Get file path for the calibration to be saved\n            walleye_data.cameras.info[\n                walleye_data.camera_in_calibration\n            ].calibrationPath = calibration_path_by_cam(\n                walleye_data.camera_in_calibration,\n                walleye_data.cameras.info[walleye_data.camera_in_calibration].resolution,\n            )\n\n            if calibrators[walleye_data.camera_in_calibration] is not None:\n                # Generate a calibration file to the file path\n                has_generated = calibrators[\n                    walleye_data.camera_in_calibration\n                ].generateCalibration(\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].calibrationPath\n                )\n\n                if has_generated:\n                    # Get reproj error\n                    walleye_data.reprojection_error = calibrators[\n                        walleye_data.camera_in_calibration\n                    ].getReprojectionError()\n\n                    # Set the cameras calibration, save off the file path, and\n                    # go to idle\n                    walleye_data.cameras.setCalibration(\n                        walleye_data.camera_in_calibration,\n                        calibrators[walleye_data.camera_in_calibration].calibrationData[\n                            \"K\"\n                        ],\n                        calibrators[walleye_data.camera_in_calibration].calibrationData[\n                            \"dist\"\n                        ],\n                    )\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].calibrationPath = calibration_path_by_cam(\n                        walleye_data.camera_in_calibration,\n                        walleye_data.cameras.info[\n                            walleye_data.camera_in_calibration\n                        ].resolution,\n                    )\n                else:\n                    walleye_data.status = \"Could not generate calibration\"\n            else:\n                walleye_data.status = \"Calibrator for current calibration camera is None\"\n            walleye_data.current_state = States.IDLE\n            calibrators[walleye_data.camera_in_calibration] = None\n\n        # AprilTag processing state\n        elif walleye_data.current_state == States.PROCESSING:\n            # Set tag size, grab camera frames, and grab image timestamp\n            pose_estimator.set_tag_size(walleye_data.tag_size)\n\n            image_time = walleye_data.robot_publisher.get_time() \n\n            connections, images, delay = walleye_data.cameras.getFramesForProcessing()\n\n            for idx, val in enumerate(connections.values()):\n                if not val and walleye_data.robot_publisher.getConnectionValue_XxX_CamelSnakePep8_PreserveName_XxX_7(idx):\n                    logger.info(\"Camera disconnected\")\n\n                walleye_data.robot_publisher.setConnectionValue_XxX_CamelSnakePep8_PreserveName_XxX_6(idx, val)\n\n            # Use the pose_estimator class to find the pose, tags, and ambiguity\n            poses, tags, ambig = pose_estimator.get_pose(\n                images.values(),\n                walleye_data.cameras.listK(),\n                walleye_data.cameras.listD(),\n            )\n\n            # Publish camera number, timestamp, poses, tags, ambiguity and increase the update number\n            # logger.info(f\"Poses at {image_time}: {poses}\")\n\n            for i in range(len(poses)):\n                if poses[i][0].X() < 2000:\n                    walleye_data.robot_publisher.publish(\n                        i, image_time - delay[i], poses[i], tags[i], ambig[i]\n                    )\n\n            # Update the pose visualization\n            for i, (identifier, img) in enumerate(images.items()):\n                if i >= len(poses):\n                    break\n                camBuffers[identifier].update(img)\n                walleye_data.set_pose(identifier, poses[i][0])\n                if walleye_data.visualizing_poses:\n                    visualizationBuffers[identifier].update(\n                        (poses[i][0].X(), poses[i][0].Y(), poses[i][0].Z()), tags[i][1:]\n                    )\n\n        # Ends the WallEye program through the web interface\n        elif walleye_data.current_state == States.SHUTDOWN:\n            logger.info(\"Shutting down\")\n            logging.shutdown()\n            socketio.stop()\n            break\n\n        # Update cameras no matter what state\n        if walleye_data.current_state != States.PROCESSING:\n            for camera_info in walleye_data.cameras.info.values():\n                if (\n                    camera_info.identifier == walleye_data.camera_in_calibration\n                    and walleye_data.current_state in CALIBRATION_STATES\n                ):\n                    continue\n\n                ret, img = camera_info.cam.read()\n\n                camBuffers[camera_info.identifier].update(img)\n\nexcept Exception as e:\n    # Something bad happened\n    logging.critical(e, exc_info=True)\n    logger.info(\"Shutting down\")\n    socketio.stop()\n    logging.shutdown()\n"]]], 1715210942.9620485]], ["ChangeSet", ["Renaming <visualizationBuffers> to <visualization_buffers>", [["ChangeContents", ["web_interface/web_interface.py", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualization_buffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(camID, newValue):\n    walleye_data.cameras.setBrightness(camID, float(newValue))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(camID, newValue):\n    walleye_data.cameras.setExposure(camID, float(newValue))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(camID, newValue):\n    w, h = map(int, newValue[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(camID, (w, h)):\n        walleye_data.status = f\"Resolution set to {newValue}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {newValue}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(camID):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = camID\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {camID}\")\n        walleye_data.status = f\"Starting calibration capture for {camID}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(camID):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = camID\n    walleye_data.cameras.info[camID].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(camID, file):\n    with open(\n        calibration_path_by_cam(camID, walleye_data.cameras.info[camID].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        calData = json.loads(file.decode())\n        calData[\"camPath\"] = camID\n        json.dump(calData, outFile)\n\n        # Load\n        calData[\"K\"] = np.asarray(calData[\"K\"])\n        calData[\"dist\"] = np.asarray(calData[\"dist\"])\n        walleye_data.cameras.setCalibration(camID, calData[\"K\"], calData[\"dist\"])\n        walleye_data.cameras.info[camID].calibrationPath = calibration_path_by_cam(\n            camID, walleye_data.cameras.info[camID].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {camID}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for camID in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(camID)\n            logger.info(f\"Camera config imported for {camID}\")\n\n    logger.info(f\"Configs sucessfully imported for {camID}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[camID].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    return Response(\n        visualization_buffers[camID].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualizationBuffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(camID, newValue):\n    walleye_data.cameras.setBrightness(camID, float(newValue))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(camID, newValue):\n    walleye_data.cameras.setExposure(camID, float(newValue))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(camID, newValue):\n    w, h = map(int, newValue[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(camID, (w, h)):\n        walleye_data.status = f\"Resolution set to {newValue}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {newValue}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(camID):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = camID\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {camID}\")\n        walleye_data.status = f\"Starting calibration capture for {camID}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(camID):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = camID\n    walleye_data.cameras.info[camID].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(camID, file):\n    with open(\n        calibration_path_by_cam(camID, walleye_data.cameras.info[camID].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        calData = json.loads(file.decode())\n        calData[\"camPath\"] = camID\n        json.dump(calData, outFile)\n\n        # Load\n        calData[\"K\"] = np.asarray(calData[\"K\"])\n        calData[\"dist\"] = np.asarray(calData[\"dist\"])\n        walleye_data.cameras.setCalibration(camID, calData[\"K\"], calData[\"dist\"])\n        walleye_data.cameras.info[camID].calibrationPath = calibration_path_by_cam(\n            camID, walleye_data.cameras.info[camID].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {camID}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for camID in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(camID)\n            logger.info(f\"Camera config imported for {camID}\")\n\n    logger.info(f\"Configs sucessfully imported for {camID}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[camID].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    return Response(\n        visualizationBuffers[camID].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n"]], ["ChangeContents", ["init.py", "import sys\nimport logging\nfrom logging.handlers import RotatingFileHandler\nfrom directory import calibration_image_folder, calibration_path_by_cam, LOG\n\n# Create logger and set settings\nLOG_FORMAT = \"[%(asctime)s - %(levelname)s - %(filename)s:%(lineno)s - %(funcName)s()]  %(message)s\"\nlogging.basicConfig(\n    format=LOG_FORMAT,\n    handlers=[\n        logging.StreamHandler(sys.stdout),\n        RotatingFileHandler(LOG, maxBytes_XxX_CamelSnakePep8_PreserveName_XxX_2=1024 * 1024, backupCount_XxX_CamelSnakePep8_PreserveName_XxX_3=5),\n    ],\n    datefmt=\"%d-%b-%y %H:%M:%S\",\n    level=logging.INFO,\n)\n\nlogger = logging.getLogger(__name__)\n\nlogger.info(\"----------- Starting Up -----------\")\n\nfrom state import walleye_data, States, CALIBRATION_STATES\nfrom processing.processing import Processor\nimport threading\nfrom camera.camera import Cameras\nfrom calibration.calibration import Calibration, CalibType_XxX_CamelSnakePep8_PreserveName_XxX_4\nimport time\n\n\n# Create and intialize cameras\nwalleye_data.cameras = Cameras()\n\nfrom web_interface.web_interface import (\n    cam_buffers,\n    socketio,\n    app,\n    visualization_buffers\n)  # After walleye_data.cameras is set\n\nweb_server = threading.Thread(\n    target=lambda: socketio.run(\n        app,\n        host=\"0.0.0.0\",\n        port=5800,\n        debug=False,\n        use_reloader=False,\n        log_output=False,\n    ),\n    daemon=True,\n)\ntry:\n    # Start the web server\n    web_server.start()\n\n    logging.getLogger(\"geventwebsocket.handler\").setLevel(logging.ERROR)\n    logging.getLogger(\"socketio\").setLevel(logging.ERROR)\n    logging.getLogger(\"socketio.server\").setLevel(logging.ERROR)\n    logging.getLogger(\"engineio\").setLevel(logging.ERROR)\n\n\n    logger.info(\"Web server ready\")\n\n    images = {}\n    calibrators = {}\n\n    # Create network tables publisher and AprilTag Processor\n    pose_estimator = Processor(walleye_data.tag_size)\n    # Publisher already created during construction of walleye_data\n    # walleye_data.make_publisher(walleye_data.team_number, walleye_data.table_name)\n    walleye_data.current_state = States.PROCESSING\n\n    logger.info(\"Starting main loop\")\n\n    last_loop_time = time.time()\n\n    # Main loop (Runs everything)\n    while True:\n        # Calculate loop time\n        curr_time = time.time()\n        walleye_data.loop_time = round(curr_time - last_loop_time, 3)\n        last_loop_time = curr_time\n\n        # State changes\n        # Pre-Calibration\n        if walleye_data.current_state == States.BEGIN_CALIBRATION:\n            logger.info(\"Beginning calibration\")\n\n            # Prepare a calibration object for the camera that is being calibrated with pre-set data\n            # only if cal object does not exist yet\n            if (\n                walleye_data.camera_in_calibration not in calibrators\n                or calibrators[walleye_data.camera_in_calibration] is None\n            ):\n                calibrators[walleye_data.camera_in_calibration] = Calibration(\n                    walleye_data.cal_delay,\n                    walleye_data.board_dims,\n                    walleye_data.camera_in_calibration,\n                    calibration_image_folder(walleye_data.camera_in_calibration),\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].resolution,\n                )\n            walleye_data.current_state = States.CALIBRATION_CAPTURE\n\n        # Take calibration images\n        elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n            # Read in frames\n            ret, img = walleye_data.cameras.info[\n                walleye_data.camera_in_calibration\n            ].cam.read()\n\n            if not ret:\n                logger.error(\n                    f\"Failed to capture image: {walleye_data.camera_in_calibration}\"\n                )\n            else:\n                # Process frames with the calibration object created prior\n                returned, used, path_saved = calibrators[\n                    walleye_data.camera_in_calibration\n                ].processFrame(img)\n\n                # If the image is a part of the accepted images save it\n                if used:\n                    walleye_data.cal_img_paths.append(path_saved)\n\n                # Keep a buffer with the images\n                cam_buffers[walleye_data.camera_in_calibration].update(returned)\n\n        # Finished Calibration, generate calibration\n        elif walleye_data.current_state == States.GENERATE_CALIBRATION:\n            # Get file path for the calibration to be saved\n            walleye_data.cameras.info[\n                walleye_data.camera_in_calibration\n            ].calibrationPath = calibration_path_by_cam(\n                walleye_data.camera_in_calibration,\n                walleye_data.cameras.info[walleye_data.camera_in_calibration].resolution,\n            )\n\n            if calibrators[walleye_data.camera_in_calibration] is not None:\n                # Generate a calibration file to the file path\n                has_generated = calibrators[\n                    walleye_data.camera_in_calibration\n                ].generateCalibration(\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].calibrationPath\n                )\n\n                if has_generated:\n                    # Get reproj error\n                    walleye_data.reprojection_error = calibrators[\n                        walleye_data.camera_in_calibration\n                    ].getReprojectionError()\n\n                    # Set the cameras calibration, save off the file path, and\n                    # go to idle\n                    walleye_data.cameras.setCalibration(\n                        walleye_data.camera_in_calibration,\n                        calibrators[walleye_data.camera_in_calibration].calibrationData[\n                            \"K\"\n                        ],\n                        calibrators[walleye_data.camera_in_calibration].calibrationData[\n                            \"dist\"\n                        ],\n                    )\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].calibrationPath = calibration_path_by_cam(\n                        walleye_data.camera_in_calibration,\n                        walleye_data.cameras.info[\n                            walleye_data.camera_in_calibration\n                        ].resolution,\n                    )\n                else:\n                    walleye_data.status = \"Could not generate calibration\"\n            else:\n                walleye_data.status = \"Calibrator for current calibration camera is None\"\n            walleye_data.current_state = States.IDLE\n            calibrators[walleye_data.camera_in_calibration] = None\n\n        # AprilTag processing state\n        elif walleye_data.current_state == States.PROCESSING:\n            # Set tag size, grab camera frames, and grab image timestamp\n            pose_estimator.set_tag_size(walleye_data.tag_size)\n\n            image_time = walleye_data.robot_publisher.get_time() \n\n            connections, images, delay = walleye_data.cameras.getFramesForProcessing()\n\n            for idx, val in enumerate(connections.values()):\n                if not val and walleye_data.robot_publisher.getConnectionValue_XxX_CamelSnakePep8_PreserveName_XxX_7(idx):\n                    logger.info(\"Camera disconnected\")\n\n                walleye_data.robot_publisher.setConnectionValue_XxX_CamelSnakePep8_PreserveName_XxX_6(idx, val)\n\n            # Use the pose_estimator class to find the pose, tags, and ambiguity\n            poses, tags, ambig = pose_estimator.get_pose(\n                images.values(),\n                walleye_data.cameras.listK(),\n                walleye_data.cameras.listD(),\n            )\n\n            # Publish camera number, timestamp, poses, tags, ambiguity and increase the update number\n            # logger.info(f\"Poses at {image_time}: {poses}\")\n\n            for i in range(len(poses)):\n                if poses[i][0].X() < 2000:\n                    walleye_data.robot_publisher.publish(\n                        i, image_time - delay[i], poses[i], tags[i], ambig[i]\n                    )\n\n            # Update the pose visualization\n            for i, (identifier, img) in enumerate(images.items()):\n                if i >= len(poses):\n                    break\n                cam_buffers[identifier].update(img)\n                walleye_data.set_pose(identifier, poses[i][0])\n                if walleye_data.visualizing_poses:\n                    visualization_buffers[identifier].update(\n                        (poses[i][0].X(), poses[i][0].Y(), poses[i][0].Z()), tags[i][1:]\n                    )\n\n        # Ends the WallEye program through the web interface\n        elif walleye_data.current_state == States.SHUTDOWN:\n            logger.info(\"Shutting down\")\n            logging.shutdown()\n            socketio.stop()\n            break\n\n        # Update cameras no matter what state\n        if walleye_data.current_state != States.PROCESSING:\n            for camera_info in walleye_data.cameras.info.values():\n                if (\n                    camera_info.identifier == walleye_data.camera_in_calibration\n                    and walleye_data.current_state in CALIBRATION_STATES\n                ):\n                    continue\n\n                ret, img = camera_info.cam.read()\n\n                cam_buffers[camera_info.identifier].update(img)\n\nexcept Exception as e:\n    # Something bad happened\n    logging.critical(e, exc_info=True)\n    logger.info(\"Shutting down\")\n    socketio.stop()\n    logging.shutdown()\n", "import sys\nimport logging\nfrom logging.handlers import RotatingFileHandler\nfrom directory import calibration_image_folder, calibration_path_by_cam, LOG\n\n# Create logger and set settings\nLOG_FORMAT = \"[%(asctime)s - %(levelname)s - %(filename)s:%(lineno)s - %(funcName)s()]  %(message)s\"\nlogging.basicConfig(\n    format=LOG_FORMAT,\n    handlers=[\n        logging.StreamHandler(sys.stdout),\n        RotatingFileHandler(LOG, maxBytes_XxX_CamelSnakePep8_PreserveName_XxX_2=1024 * 1024, backupCount_XxX_CamelSnakePep8_PreserveName_XxX_3=5),\n    ],\n    datefmt=\"%d-%b-%y %H:%M:%S\",\n    level=logging.INFO,\n)\n\nlogger = logging.getLogger(__name__)\n\nlogger.info(\"----------- Starting Up -----------\")\n\nfrom state import walleye_data, States, CALIBRATION_STATES\nfrom processing.processing import Processor\nimport threading\nfrom camera.camera import Cameras\nfrom calibration.calibration import Calibration, CalibType_XxX_CamelSnakePep8_PreserveName_XxX_4\nimport time\n\n\n# Create and intialize cameras\nwalleye_data.cameras = Cameras()\n\nfrom web_interface.web_interface import (\n    cam_buffers,\n    socketio,\n    app,\n    visualizationBuffers\n)  # After walleye_data.cameras is set\n\nweb_server = threading.Thread(\n    target=lambda: socketio.run(\n        app,\n        host=\"0.0.0.0\",\n        port=5800,\n        debug=False,\n        use_reloader=False,\n        log_output=False,\n    ),\n    daemon=True,\n)\ntry:\n    # Start the web server\n    web_server.start()\n\n    logging.getLogger(\"geventwebsocket.handler\").setLevel(logging.ERROR)\n    logging.getLogger(\"socketio\").setLevel(logging.ERROR)\n    logging.getLogger(\"socketio.server\").setLevel(logging.ERROR)\n    logging.getLogger(\"engineio\").setLevel(logging.ERROR)\n\n\n    logger.info(\"Web server ready\")\n\n    images = {}\n    calibrators = {}\n\n    # Create network tables publisher and AprilTag Processor\n    pose_estimator = Processor(walleye_data.tag_size)\n    # Publisher already created during construction of walleye_data\n    # walleye_data.make_publisher(walleye_data.team_number, walleye_data.table_name)\n    walleye_data.current_state = States.PROCESSING\n\n    logger.info(\"Starting main loop\")\n\n    last_loop_time = time.time()\n\n    # Main loop (Runs everything)\n    while True:\n        # Calculate loop time\n        curr_time = time.time()\n        walleye_data.loop_time = round(curr_time - last_loop_time, 3)\n        last_loop_time = curr_time\n\n        # State changes\n        # Pre-Calibration\n        if walleye_data.current_state == States.BEGIN_CALIBRATION:\n            logger.info(\"Beginning calibration\")\n\n            # Prepare a calibration object for the camera that is being calibrated with pre-set data\n            # only if cal object does not exist yet\n            if (\n                walleye_data.camera_in_calibration not in calibrators\n                or calibrators[walleye_data.camera_in_calibration] is None\n            ):\n                calibrators[walleye_data.camera_in_calibration] = Calibration(\n                    walleye_data.cal_delay,\n                    walleye_data.board_dims,\n                    walleye_data.camera_in_calibration,\n                    calibration_image_folder(walleye_data.camera_in_calibration),\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].resolution,\n                )\n            walleye_data.current_state = States.CALIBRATION_CAPTURE\n\n        # Take calibration images\n        elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n            # Read in frames\n            ret, img = walleye_data.cameras.info[\n                walleye_data.camera_in_calibration\n            ].cam.read()\n\n            if not ret:\n                logger.error(\n                    f\"Failed to capture image: {walleye_data.camera_in_calibration}\"\n                )\n            else:\n                # Process frames with the calibration object created prior\n                returned, used, path_saved = calibrators[\n                    walleye_data.camera_in_calibration\n                ].processFrame(img)\n\n                # If the image is a part of the accepted images save it\n                if used:\n                    walleye_data.cal_img_paths.append(path_saved)\n\n                # Keep a buffer with the images\n                cam_buffers[walleye_data.camera_in_calibration].update(returned)\n\n        # Finished Calibration, generate calibration\n        elif walleye_data.current_state == States.GENERATE_CALIBRATION:\n            # Get file path for the calibration to be saved\n            walleye_data.cameras.info[\n                walleye_data.camera_in_calibration\n            ].calibrationPath = calibration_path_by_cam(\n                walleye_data.camera_in_calibration,\n                walleye_data.cameras.info[walleye_data.camera_in_calibration].resolution,\n            )\n\n            if calibrators[walleye_data.camera_in_calibration] is not None:\n                # Generate a calibration file to the file path\n                has_generated = calibrators[\n                    walleye_data.camera_in_calibration\n                ].generateCalibration(\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].calibrationPath\n                )\n\n                if has_generated:\n                    # Get reproj error\n                    walleye_data.reprojection_error = calibrators[\n                        walleye_data.camera_in_calibration\n                    ].getReprojectionError()\n\n                    # Set the cameras calibration, save off the file path, and\n                    # go to idle\n                    walleye_data.cameras.setCalibration(\n                        walleye_data.camera_in_calibration,\n                        calibrators[walleye_data.camera_in_calibration].calibrationData[\n                            \"K\"\n                        ],\n                        calibrators[walleye_data.camera_in_calibration].calibrationData[\n                            \"dist\"\n                        ],\n                    )\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].calibrationPath = calibration_path_by_cam(\n                        walleye_data.camera_in_calibration,\n                        walleye_data.cameras.info[\n                            walleye_data.camera_in_calibration\n                        ].resolution,\n                    )\n                else:\n                    walleye_data.status = \"Could not generate calibration\"\n            else:\n                walleye_data.status = \"Calibrator for current calibration camera is None\"\n            walleye_data.current_state = States.IDLE\n            calibrators[walleye_data.camera_in_calibration] = None\n\n        # AprilTag processing state\n        elif walleye_data.current_state == States.PROCESSING:\n            # Set tag size, grab camera frames, and grab image timestamp\n            pose_estimator.set_tag_size(walleye_data.tag_size)\n\n            image_time = walleye_data.robot_publisher.get_time() \n\n            connections, images, delay = walleye_data.cameras.getFramesForProcessing()\n\n            for idx, val in enumerate(connections.values()):\n                if not val and walleye_data.robot_publisher.getConnectionValue_XxX_CamelSnakePep8_PreserveName_XxX_7(idx):\n                    logger.info(\"Camera disconnected\")\n\n                walleye_data.robot_publisher.setConnectionValue_XxX_CamelSnakePep8_PreserveName_XxX_6(idx, val)\n\n            # Use the pose_estimator class to find the pose, tags, and ambiguity\n            poses, tags, ambig = pose_estimator.get_pose(\n                images.values(),\n                walleye_data.cameras.listK(),\n                walleye_data.cameras.listD(),\n            )\n\n            # Publish camera number, timestamp, poses, tags, ambiguity and increase the update number\n            # logger.info(f\"Poses at {image_time}: {poses}\")\n\n            for i in range(len(poses)):\n                if poses[i][0].X() < 2000:\n                    walleye_data.robot_publisher.publish(\n                        i, image_time - delay[i], poses[i], tags[i], ambig[i]\n                    )\n\n            # Update the pose visualization\n            for i, (identifier, img) in enumerate(images.items()):\n                if i >= len(poses):\n                    break\n                cam_buffers[identifier].update(img)\n                walleye_data.set_pose(identifier, poses[i][0])\n                if walleye_data.visualizing_poses:\n                    visualizationBuffers[identifier].update(\n                        (poses[i][0].X(), poses[i][0].Y(), poses[i][0].Z()), tags[i][1:]\n                    )\n\n        # Ends the WallEye program through the web interface\n        elif walleye_data.current_state == States.SHUTDOWN:\n            logger.info(\"Shutting down\")\n            logging.shutdown()\n            socketio.stop()\n            break\n\n        # Update cameras no matter what state\n        if walleye_data.current_state != States.PROCESSING:\n            for camera_info in walleye_data.cameras.info.values():\n                if (\n                    camera_info.identifier == walleye_data.camera_in_calibration\n                    and walleye_data.current_state in CALIBRATION_STATES\n                ):\n                    continue\n\n                ret, img = camera_info.cam.read()\n\n                cam_buffers[camera_info.identifier].update(img)\n\nexcept Exception as e:\n    # Something bad happened\n    logging.critical(e, exc_info=True)\n    logger.info(\"Shutting down\")\n    socketio.stop()\n    logging.shutdown()\n"]]], 1715210945.8717809]], ["ChangeSet", ["Renaming <camID> to <cam_id>", [["ChangeContents", ["web_interface/web_interface.py", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualization_buffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(camID, newValue):\n    walleye_data.cameras.setBrightness(camID, float(newValue))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(camID, newValue):\n    walleye_data.cameras.setExposure(camID, float(newValue))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(camID, newValue):\n    w, h = map(int, newValue[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(camID, (w, h)):\n        walleye_data.status = f\"Resolution set to {newValue}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {newValue}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(cam_id):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = cam_id\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {cam_id}\")\n        walleye_data.status = f\"Starting calibration capture for {cam_id}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(camID):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = camID\n    walleye_data.cameras.info[camID].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(camID, file):\n    with open(\n        calibration_path_by_cam(camID, walleye_data.cameras.info[camID].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        calData = json.loads(file.decode())\n        calData[\"camPath\"] = camID\n        json.dump(calData, outFile)\n\n        # Load\n        calData[\"K\"] = np.asarray(calData[\"K\"])\n        calData[\"dist\"] = np.asarray(calData[\"dist\"])\n        walleye_data.cameras.setCalibration(camID, calData[\"K\"], calData[\"dist\"])\n        walleye_data.cameras.info[camID].calibrationPath = calibration_path_by_cam(\n            camID, walleye_data.cameras.info[camID].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {camID}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for camID in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(camID)\n            logger.info(f\"Camera config imported for {camID}\")\n\n    logger.info(f\"Configs sucessfully imported for {camID}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[camID].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    return Response(\n        visualization_buffers[camID].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualization_buffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(camID, newValue):\n    walleye_data.cameras.setBrightness(camID, float(newValue))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(camID, newValue):\n    walleye_data.cameras.setExposure(camID, float(newValue))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(camID, newValue):\n    w, h = map(int, newValue[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(camID, (w, h)):\n        walleye_data.status = f\"Resolution set to {newValue}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {newValue}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(camID):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = camID\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {camID}\")\n        walleye_data.status = f\"Starting calibration capture for {camID}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(camID):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = camID\n    walleye_data.cameras.info[camID].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(camID, file):\n    with open(\n        calibration_path_by_cam(camID, walleye_data.cameras.info[camID].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        calData = json.loads(file.decode())\n        calData[\"camPath\"] = camID\n        json.dump(calData, outFile)\n\n        # Load\n        calData[\"K\"] = np.asarray(calData[\"K\"])\n        calData[\"dist\"] = np.asarray(calData[\"dist\"])\n        walleye_data.cameras.setCalibration(camID, calData[\"K\"], calData[\"dist\"])\n        walleye_data.cameras.info[camID].calibrationPath = calibration_path_by_cam(\n            camID, walleye_data.cameras.info[camID].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {camID}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for camID in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(camID)\n            logger.info(f\"Camera config imported for {camID}\")\n\n    logger.info(f\"Configs sucessfully imported for {camID}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[camID].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    return Response(\n        visualization_buffers[camID].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n"]]], 1715210948.37637]], ["ChangeSet", ["Renaming <calData> to <cal_data>", [["ChangeContents", ["web_interface/web_interface.py", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualization_buffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(camID, newValue):\n    walleye_data.cameras.setBrightness(camID, float(newValue))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(camID, newValue):\n    walleye_data.cameras.setExposure(camID, float(newValue))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(camID, newValue):\n    w, h = map(int, newValue[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(camID, (w, h)):\n        walleye_data.status = f\"Resolution set to {newValue}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {newValue}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(cam_id):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = cam_id\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {cam_id}\")\n        walleye_data.status = f\"Starting calibration capture for {cam_id}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(camID):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = camID\n    walleye_data.cameras.info[camID].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(camID, file):\n    with open(\n        calibration_path_by_cam(camID, walleye_data.cameras.info[camID].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        cal_data = json.loads(file.decode())\n        cal_data[\"camPath\"] = camID\n        json.dump(cal_data, outFile)\n\n        # Load\n        cal_data[\"K\"] = np.asarray(cal_data[\"K\"])\n        cal_data[\"dist\"] = np.asarray(cal_data[\"dist\"])\n        walleye_data.cameras.setCalibration(camID, cal_data[\"K\"], cal_data[\"dist\"])\n        walleye_data.cameras.info[camID].calibrationPath = calibration_path_by_cam(\n            camID, walleye_data.cameras.info[camID].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {camID}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for camID in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(camID)\n            logger.info(f\"Camera config imported for {camID}\")\n\n    logger.info(f\"Configs sucessfully imported for {camID}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[camID].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    return Response(\n        visualization_buffers[camID].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualization_buffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(camID, newValue):\n    walleye_data.cameras.setBrightness(camID, float(newValue))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(camID, newValue):\n    walleye_data.cameras.setExposure(camID, float(newValue))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(camID, newValue):\n    w, h = map(int, newValue[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(camID, (w, h)):\n        walleye_data.status = f\"Resolution set to {newValue}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {newValue}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(cam_id):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = cam_id\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {cam_id}\")\n        walleye_data.status = f\"Starting calibration capture for {cam_id}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(camID):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = camID\n    walleye_data.cameras.info[camID].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(camID, file):\n    with open(\n        calibration_path_by_cam(camID, walleye_data.cameras.info[camID].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        calData = json.loads(file.decode())\n        calData[\"camPath\"] = camID\n        json.dump(calData, outFile)\n\n        # Load\n        calData[\"K\"] = np.asarray(calData[\"K\"])\n        calData[\"dist\"] = np.asarray(calData[\"dist\"])\n        walleye_data.cameras.setCalibration(camID, calData[\"K\"], calData[\"dist\"])\n        walleye_data.cameras.info[camID].calibrationPath = calibration_path_by_cam(\n            camID, walleye_data.cameras.info[camID].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {camID}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for camID in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(camID)\n            logger.info(f\"Camera config imported for {camID}\")\n\n    logger.info(f\"Configs sucessfully imported for {camID}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[camID].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    return Response(\n        visualization_buffers[camID].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n"]]], 1715210952.9486914]], ["ChangeSet", ["Renaming <camID> to <cam_id>", [["ChangeContents", ["web_interface/web_interface.py", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualization_buffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(camID, newValue):\n    walleye_data.cameras.setBrightness(camID, float(newValue))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(camID, newValue):\n    walleye_data.cameras.setExposure(camID, float(newValue))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(camID, newValue):\n    w, h = map(int, newValue[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(camID, (w, h)):\n        walleye_data.status = f\"Resolution set to {newValue}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {newValue}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(cam_id):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = cam_id\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {cam_id}\")\n        walleye_data.status = f\"Starting calibration capture for {cam_id}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(camID):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = camID\n    walleye_data.cameras.info[camID].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(cam_id, file):\n    with open(\n        calibration_path_by_cam(cam_id, walleye_data.cameras.info[cam_id].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        cal_data = json.loads(file.decode())\n        cal_data[\"camPath\"] = cam_id\n        json.dump(cal_data, outFile)\n\n        # Load\n        cal_data[\"K\"] = np.asarray(cal_data[\"K\"])\n        cal_data[\"dist\"] = np.asarray(cal_data[\"dist\"])\n        walleye_data.cameras.setCalibration(cam_id, cal_data[\"K\"], cal_data[\"dist\"])\n        walleye_data.cameras.info[cam_id].calibrationPath = calibration_path_by_cam(\n            cam_id, walleye_data.cameras.info[cam_id].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for camID in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(camID)\n            logger.info(f\"Camera config imported for {camID}\")\n\n    logger.info(f\"Configs sucessfully imported for {camID}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[camID].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    return Response(\n        visualization_buffers[camID].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualization_buffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(camID, newValue):\n    walleye_data.cameras.setBrightness(camID, float(newValue))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(camID, newValue):\n    walleye_data.cameras.setExposure(camID, float(newValue))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(camID, newValue):\n    w, h = map(int, newValue[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(camID, (w, h)):\n        walleye_data.status = f\"Resolution set to {newValue}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {newValue}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(cam_id):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = cam_id\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {cam_id}\")\n        walleye_data.status = f\"Starting calibration capture for {cam_id}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(camID):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = camID\n    walleye_data.cameras.info[camID].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(camID, file):\n    with open(\n        calibration_path_by_cam(camID, walleye_data.cameras.info[camID].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        cal_data = json.loads(file.decode())\n        cal_data[\"camPath\"] = camID\n        json.dump(cal_data, outFile)\n\n        # Load\n        cal_data[\"K\"] = np.asarray(cal_data[\"K\"])\n        cal_data[\"dist\"] = np.asarray(cal_data[\"dist\"])\n        walleye_data.cameras.setCalibration(camID, cal_data[\"K\"], cal_data[\"dist\"])\n        walleye_data.cameras.info[camID].calibrationPath = calibration_path_by_cam(\n            camID, walleye_data.cameras.info[camID].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {camID}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for camID in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(camID)\n            logger.info(f\"Camera config imported for {camID}\")\n\n    logger.info(f\"Configs sucessfully imported for {camID}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[camID].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    return Response(\n        visualization_buffers[camID].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n"]]], 1715210954.9529085]], ["ChangeSet", ["Renaming <camID> to <cam_id>", [["ChangeContents", ["web_interface/web_interface.py", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualization_buffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(camID, newValue):\n    walleye_data.cameras.setBrightness(camID, float(newValue))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(camID, newValue):\n    walleye_data.cameras.setExposure(camID, float(newValue))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(camID, newValue):\n    w, h = map(int, newValue[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(camID, (w, h)):\n        walleye_data.status = f\"Resolution set to {newValue}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {newValue}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(cam_id):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = cam_id\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {cam_id}\")\n        walleye_data.status = f\"Starting calibration capture for {cam_id}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(camID):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = camID\n    walleye_data.cameras.info[camID].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(cam_id, file):\n    with open(\n        calibration_path_by_cam(cam_id, walleye_data.cameras.info[cam_id].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        cal_data = json.loads(file.decode())\n        cal_data[\"camPath\"] = cam_id\n        json.dump(cal_data, outFile)\n\n        # Load\n        cal_data[\"K\"] = np.asarray(cal_data[\"K\"])\n        cal_data[\"dist\"] = np.asarray(cal_data[\"dist\"])\n        walleye_data.cameras.setCalibration(cam_id, cal_data[\"K\"], cal_data[\"dist\"])\n        walleye_data.cameras.info[cam_id].calibrationPath = calibration_path_by_cam(\n            cam_id, walleye_data.cameras.info[cam_id].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for cam_id in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(cam_id)\n            logger.info(f\"Camera config imported for {cam_id}\")\n\n    logger.info(f\"Configs sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[camID].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    return Response(\n        visualization_buffers[camID].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualization_buffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(camID, newValue):\n    walleye_data.cameras.setBrightness(camID, float(newValue))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(camID, newValue):\n    walleye_data.cameras.setExposure(camID, float(newValue))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(camID, newValue):\n    w, h = map(int, newValue[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(camID, (w, h)):\n        walleye_data.status = f\"Resolution set to {newValue}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {newValue}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(cam_id):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = cam_id\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {cam_id}\")\n        walleye_data.status = f\"Starting calibration capture for {cam_id}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(camID):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = camID\n    walleye_data.cameras.info[camID].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(cam_id, file):\n    with open(\n        calibration_path_by_cam(cam_id, walleye_data.cameras.info[cam_id].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        cal_data = json.loads(file.decode())\n        cal_data[\"camPath\"] = cam_id\n        json.dump(cal_data, outFile)\n\n        # Load\n        cal_data[\"K\"] = np.asarray(cal_data[\"K\"])\n        cal_data[\"dist\"] = np.asarray(cal_data[\"dist\"])\n        walleye_data.cameras.setCalibration(cam_id, cal_data[\"K\"], cal_data[\"dist\"])\n        walleye_data.cameras.info[cam_id].calibrationPath = calibration_path_by_cam(\n            cam_id, walleye_data.cameras.info[cam_id].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for camID in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(camID)\n            logger.info(f\"Camera config imported for {camID}\")\n\n    logger.info(f\"Configs sucessfully imported for {camID}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[camID].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    return Response(\n        visualization_buffers[camID].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n"]]], 1715210957.1092923]], ["ChangeSet", ["Renaming <camID> to <cam_id>", [["ChangeContents", ["web_interface/web_interface.py", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualization_buffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(cam_id, newValue):\n    walleye_data.cameras.setBrightness(cam_id, float(newValue))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(camID, newValue):\n    walleye_data.cameras.setExposure(camID, float(newValue))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(camID, newValue):\n    w, h = map(int, newValue[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(camID, (w, h)):\n        walleye_data.status = f\"Resolution set to {newValue}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {newValue}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(cam_id):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = cam_id\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {cam_id}\")\n        walleye_data.status = f\"Starting calibration capture for {cam_id}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(camID):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = camID\n    walleye_data.cameras.info[camID].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(cam_id, file):\n    with open(\n        calibration_path_by_cam(cam_id, walleye_data.cameras.info[cam_id].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        cal_data = json.loads(file.decode())\n        cal_data[\"camPath\"] = cam_id\n        json.dump(cal_data, outFile)\n\n        # Load\n        cal_data[\"K\"] = np.asarray(cal_data[\"K\"])\n        cal_data[\"dist\"] = np.asarray(cal_data[\"dist\"])\n        walleye_data.cameras.setCalibration(cam_id, cal_data[\"K\"], cal_data[\"dist\"])\n        walleye_data.cameras.info[cam_id].calibrationPath = calibration_path_by_cam(\n            cam_id, walleye_data.cameras.info[cam_id].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for cam_id in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(cam_id)\n            logger.info(f\"Camera config imported for {cam_id}\")\n\n    logger.info(f\"Configs sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[camID].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    return Response(\n        visualization_buffers[camID].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualization_buffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(camID, newValue):\n    walleye_data.cameras.setBrightness(camID, float(newValue))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(camID, newValue):\n    walleye_data.cameras.setExposure(camID, float(newValue))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(camID, newValue):\n    w, h = map(int, newValue[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(camID, (w, h)):\n        walleye_data.status = f\"Resolution set to {newValue}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {newValue}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(cam_id):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = cam_id\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {cam_id}\")\n        walleye_data.status = f\"Starting calibration capture for {cam_id}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(camID):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = camID\n    walleye_data.cameras.info[camID].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(cam_id, file):\n    with open(\n        calibration_path_by_cam(cam_id, walleye_data.cameras.info[cam_id].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        cal_data = json.loads(file.decode())\n        cal_data[\"camPath\"] = cam_id\n        json.dump(cal_data, outFile)\n\n        # Load\n        cal_data[\"K\"] = np.asarray(cal_data[\"K\"])\n        cal_data[\"dist\"] = np.asarray(cal_data[\"dist\"])\n        walleye_data.cameras.setCalibration(cam_id, cal_data[\"K\"], cal_data[\"dist\"])\n        walleye_data.cameras.info[cam_id].calibrationPath = calibration_path_by_cam(\n            cam_id, walleye_data.cameras.info[cam_id].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for cam_id in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(cam_id)\n            logger.info(f\"Camera config imported for {cam_id}\")\n\n    logger.info(f\"Configs sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[camID].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    return Response(\n        visualization_buffers[camID].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n"]]], 1715210959.3989668]], ["ChangeSet", ["Renaming <newValue> to <new_value>", [["ChangeContents", ["web_interface/web_interface.py", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualization_buffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(cam_id, new_value):\n    walleye_data.cameras.setBrightness(cam_id, float(new_value))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(camID, newValue):\n    walleye_data.cameras.setExposure(camID, float(newValue))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(camID, newValue):\n    w, h = map(int, newValue[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(camID, (w, h)):\n        walleye_data.status = f\"Resolution set to {newValue}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {newValue}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(cam_id):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = cam_id\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {cam_id}\")\n        walleye_data.status = f\"Starting calibration capture for {cam_id}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(camID):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = camID\n    walleye_data.cameras.info[camID].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(cam_id, file):\n    with open(\n        calibration_path_by_cam(cam_id, walleye_data.cameras.info[cam_id].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        cal_data = json.loads(file.decode())\n        cal_data[\"camPath\"] = cam_id\n        json.dump(cal_data, outFile)\n\n        # Load\n        cal_data[\"K\"] = np.asarray(cal_data[\"K\"])\n        cal_data[\"dist\"] = np.asarray(cal_data[\"dist\"])\n        walleye_data.cameras.setCalibration(cam_id, cal_data[\"K\"], cal_data[\"dist\"])\n        walleye_data.cameras.info[cam_id].calibrationPath = calibration_path_by_cam(\n            cam_id, walleye_data.cameras.info[cam_id].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for cam_id in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(cam_id)\n            logger.info(f\"Camera config imported for {cam_id}\")\n\n    logger.info(f\"Configs sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[camID].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    return Response(\n        visualization_buffers[camID].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualization_buffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(cam_id, newValue):\n    walleye_data.cameras.setBrightness(cam_id, float(newValue))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(camID, newValue):\n    walleye_data.cameras.setExposure(camID, float(newValue))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(camID, newValue):\n    w, h = map(int, newValue[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(camID, (w, h)):\n        walleye_data.status = f\"Resolution set to {newValue}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {newValue}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(cam_id):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = cam_id\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {cam_id}\")\n        walleye_data.status = f\"Starting calibration capture for {cam_id}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(camID):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = camID\n    walleye_data.cameras.info[camID].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(cam_id, file):\n    with open(\n        calibration_path_by_cam(cam_id, walleye_data.cameras.info[cam_id].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        cal_data = json.loads(file.decode())\n        cal_data[\"camPath\"] = cam_id\n        json.dump(cal_data, outFile)\n\n        # Load\n        cal_data[\"K\"] = np.asarray(cal_data[\"K\"])\n        cal_data[\"dist\"] = np.asarray(cal_data[\"dist\"])\n        walleye_data.cameras.setCalibration(cam_id, cal_data[\"K\"], cal_data[\"dist\"])\n        walleye_data.cameras.info[cam_id].calibrationPath = calibration_path_by_cam(\n            cam_id, walleye_data.cameras.info[cam_id].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for cam_id in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(cam_id)\n            logger.info(f\"Camera config imported for {cam_id}\")\n\n    logger.info(f\"Configs sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[camID].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    return Response(\n        visualization_buffers[camID].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n"]]], 1715210960.9553316]], ["ChangeSet", ["Renaming <camID> to <cam_id>", [["ChangeContents", ["web_interface/web_interface.py", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualization_buffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(cam_id, new_value):\n    walleye_data.cameras.setBrightness(cam_id, float(new_value))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(cam_id, newValue):\n    walleye_data.cameras.setExposure(cam_id, float(newValue))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(camID, newValue):\n    w, h = map(int, newValue[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(camID, (w, h)):\n        walleye_data.status = f\"Resolution set to {newValue}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {newValue}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(cam_id):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = cam_id\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {cam_id}\")\n        walleye_data.status = f\"Starting calibration capture for {cam_id}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(camID):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = camID\n    walleye_data.cameras.info[camID].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(cam_id, file):\n    with open(\n        calibration_path_by_cam(cam_id, walleye_data.cameras.info[cam_id].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        cal_data = json.loads(file.decode())\n        cal_data[\"camPath\"] = cam_id\n        json.dump(cal_data, outFile)\n\n        # Load\n        cal_data[\"K\"] = np.asarray(cal_data[\"K\"])\n        cal_data[\"dist\"] = np.asarray(cal_data[\"dist\"])\n        walleye_data.cameras.setCalibration(cam_id, cal_data[\"K\"], cal_data[\"dist\"])\n        walleye_data.cameras.info[cam_id].calibrationPath = calibration_path_by_cam(\n            cam_id, walleye_data.cameras.info[cam_id].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for cam_id in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(cam_id)\n            logger.info(f\"Camera config imported for {cam_id}\")\n\n    logger.info(f\"Configs sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[camID].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    return Response(\n        visualization_buffers[camID].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualization_buffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(cam_id, new_value):\n    walleye_data.cameras.setBrightness(cam_id, float(new_value))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(camID, newValue):\n    walleye_data.cameras.setExposure(camID, float(newValue))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(camID, newValue):\n    w, h = map(int, newValue[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(camID, (w, h)):\n        walleye_data.status = f\"Resolution set to {newValue}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {newValue}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(cam_id):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = cam_id\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {cam_id}\")\n        walleye_data.status = f\"Starting calibration capture for {cam_id}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(camID):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = camID\n    walleye_data.cameras.info[camID].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(cam_id, file):\n    with open(\n        calibration_path_by_cam(cam_id, walleye_data.cameras.info[cam_id].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        cal_data = json.loads(file.decode())\n        cal_data[\"camPath\"] = cam_id\n        json.dump(cal_data, outFile)\n\n        # Load\n        cal_data[\"K\"] = np.asarray(cal_data[\"K\"])\n        cal_data[\"dist\"] = np.asarray(cal_data[\"dist\"])\n        walleye_data.cameras.setCalibration(cam_id, cal_data[\"K\"], cal_data[\"dist\"])\n        walleye_data.cameras.info[cam_id].calibrationPath = calibration_path_by_cam(\n            cam_id, walleye_data.cameras.info[cam_id].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for cam_id in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(cam_id)\n            logger.info(f\"Camera config imported for {cam_id}\")\n\n    logger.info(f\"Configs sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[camID].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    return Response(\n        visualization_buffers[camID].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n"]]], 1715210962.3109024]], ["ChangeSet", ["Renaming <newValue> to <new_value>", [["ChangeContents", ["web_interface/web_interface.py", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualization_buffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(cam_id, new_value):\n    walleye_data.cameras.setBrightness(cam_id, float(new_value))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(cam_id, new_value):\n    walleye_data.cameras.setExposure(cam_id, float(new_value))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(camID, newValue):\n    w, h = map(int, newValue[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(camID, (w, h)):\n        walleye_data.status = f\"Resolution set to {newValue}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {newValue}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(cam_id):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = cam_id\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {cam_id}\")\n        walleye_data.status = f\"Starting calibration capture for {cam_id}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(camID):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = camID\n    walleye_data.cameras.info[camID].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(cam_id, file):\n    with open(\n        calibration_path_by_cam(cam_id, walleye_data.cameras.info[cam_id].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        cal_data = json.loads(file.decode())\n        cal_data[\"camPath\"] = cam_id\n        json.dump(cal_data, outFile)\n\n        # Load\n        cal_data[\"K\"] = np.asarray(cal_data[\"K\"])\n        cal_data[\"dist\"] = np.asarray(cal_data[\"dist\"])\n        walleye_data.cameras.setCalibration(cam_id, cal_data[\"K\"], cal_data[\"dist\"])\n        walleye_data.cameras.info[cam_id].calibrationPath = calibration_path_by_cam(\n            cam_id, walleye_data.cameras.info[cam_id].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for cam_id in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(cam_id)\n            logger.info(f\"Camera config imported for {cam_id}\")\n\n    logger.info(f\"Configs sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[camID].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    return Response(\n        visualization_buffers[camID].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualization_buffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(cam_id, new_value):\n    walleye_data.cameras.setBrightness(cam_id, float(new_value))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(cam_id, newValue):\n    walleye_data.cameras.setExposure(cam_id, float(newValue))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(camID, newValue):\n    w, h = map(int, newValue[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(camID, (w, h)):\n        walleye_data.status = f\"Resolution set to {newValue}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {newValue}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(cam_id):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = cam_id\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {cam_id}\")\n        walleye_data.status = f\"Starting calibration capture for {cam_id}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(camID):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = camID\n    walleye_data.cameras.info[camID].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(cam_id, file):\n    with open(\n        calibration_path_by_cam(cam_id, walleye_data.cameras.info[cam_id].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        cal_data = json.loads(file.decode())\n        cal_data[\"camPath\"] = cam_id\n        json.dump(cal_data, outFile)\n\n        # Load\n        cal_data[\"K\"] = np.asarray(cal_data[\"K\"])\n        cal_data[\"dist\"] = np.asarray(cal_data[\"dist\"])\n        walleye_data.cameras.setCalibration(cam_id, cal_data[\"K\"], cal_data[\"dist\"])\n        walleye_data.cameras.info[cam_id].calibrationPath = calibration_path_by_cam(\n            cam_id, walleye_data.cameras.info[cam_id].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for cam_id in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(cam_id)\n            logger.info(f\"Camera config imported for {cam_id}\")\n\n    logger.info(f\"Configs sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[camID].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    return Response(\n        visualization_buffers[camID].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n"]]], 1715210963.5023482]], ["ChangeSet", ["Renaming <camID> to <cam_id>", [["ChangeContents", ["web_interface/web_interface.py", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualization_buffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(cam_id, new_value):\n    walleye_data.cameras.setBrightness(cam_id, float(new_value))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(cam_id, new_value):\n    walleye_data.cameras.setExposure(cam_id, float(new_value))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(cam_id, newValue):\n    w, h = map(int, newValue[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(cam_id, (w, h)):\n        walleye_data.status = f\"Resolution set to {newValue}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {newValue}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(cam_id):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = cam_id\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {cam_id}\")\n        walleye_data.status = f\"Starting calibration capture for {cam_id}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(camID):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = camID\n    walleye_data.cameras.info[camID].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(cam_id, file):\n    with open(\n        calibration_path_by_cam(cam_id, walleye_data.cameras.info[cam_id].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        cal_data = json.loads(file.decode())\n        cal_data[\"camPath\"] = cam_id\n        json.dump(cal_data, outFile)\n\n        # Load\n        cal_data[\"K\"] = np.asarray(cal_data[\"K\"])\n        cal_data[\"dist\"] = np.asarray(cal_data[\"dist\"])\n        walleye_data.cameras.setCalibration(cam_id, cal_data[\"K\"], cal_data[\"dist\"])\n        walleye_data.cameras.info[cam_id].calibrationPath = calibration_path_by_cam(\n            cam_id, walleye_data.cameras.info[cam_id].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for cam_id in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(cam_id)\n            logger.info(f\"Camera config imported for {cam_id}\")\n\n    logger.info(f\"Configs sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[camID].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    return Response(\n        visualization_buffers[camID].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualization_buffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(cam_id, new_value):\n    walleye_data.cameras.setBrightness(cam_id, float(new_value))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(cam_id, new_value):\n    walleye_data.cameras.setExposure(cam_id, float(new_value))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(camID, newValue):\n    w, h = map(int, newValue[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(camID, (w, h)):\n        walleye_data.status = f\"Resolution set to {newValue}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {newValue}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(cam_id):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = cam_id\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {cam_id}\")\n        walleye_data.status = f\"Starting calibration capture for {cam_id}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(camID):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = camID\n    walleye_data.cameras.info[camID].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(cam_id, file):\n    with open(\n        calibration_path_by_cam(cam_id, walleye_data.cameras.info[cam_id].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        cal_data = json.loads(file.decode())\n        cal_data[\"camPath\"] = cam_id\n        json.dump(cal_data, outFile)\n\n        # Load\n        cal_data[\"K\"] = np.asarray(cal_data[\"K\"])\n        cal_data[\"dist\"] = np.asarray(cal_data[\"dist\"])\n        walleye_data.cameras.setCalibration(cam_id, cal_data[\"K\"], cal_data[\"dist\"])\n        walleye_data.cameras.info[cam_id].calibrationPath = calibration_path_by_cam(\n            cam_id, walleye_data.cameras.info[cam_id].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for cam_id in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(cam_id)\n            logger.info(f\"Camera config imported for {cam_id}\")\n\n    logger.info(f\"Configs sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[camID].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    return Response(\n        visualization_buffers[camID].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n"]]], 1715210964.835402]], ["ChangeSet", ["Renaming <newValue> to <new_value>", [["ChangeContents", ["web_interface/web_interface.py", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualization_buffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(cam_id, new_value):\n    walleye_data.cameras.setBrightness(cam_id, float(new_value))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(cam_id, new_value):\n    walleye_data.cameras.setExposure(cam_id, float(new_value))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(cam_id, new_value):\n    w, h = map(int, new_value[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(cam_id, (w, h)):\n        walleye_data.status = f\"Resolution set to {new_value}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {new_value}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(cam_id):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = cam_id\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {cam_id}\")\n        walleye_data.status = f\"Starting calibration capture for {cam_id}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(camID):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = camID\n    walleye_data.cameras.info[camID].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(cam_id, file):\n    with open(\n        calibration_path_by_cam(cam_id, walleye_data.cameras.info[cam_id].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        cal_data = json.loads(file.decode())\n        cal_data[\"camPath\"] = cam_id\n        json.dump(cal_data, outFile)\n\n        # Load\n        cal_data[\"K\"] = np.asarray(cal_data[\"K\"])\n        cal_data[\"dist\"] = np.asarray(cal_data[\"dist\"])\n        walleye_data.cameras.setCalibration(cam_id, cal_data[\"K\"], cal_data[\"dist\"])\n        walleye_data.cameras.info[cam_id].calibrationPath = calibration_path_by_cam(\n            cam_id, walleye_data.cameras.info[cam_id].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for cam_id in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(cam_id)\n            logger.info(f\"Camera config imported for {cam_id}\")\n\n    logger.info(f\"Configs sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[camID].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    return Response(\n        visualization_buffers[camID].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualization_buffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(cam_id, new_value):\n    walleye_data.cameras.setBrightness(cam_id, float(new_value))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(cam_id, new_value):\n    walleye_data.cameras.setExposure(cam_id, float(new_value))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(cam_id, newValue):\n    w, h = map(int, newValue[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(cam_id, (w, h)):\n        walleye_data.status = f\"Resolution set to {newValue}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {newValue}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(cam_id):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = cam_id\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {cam_id}\")\n        walleye_data.status = f\"Starting calibration capture for {cam_id}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(camID):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = camID\n    walleye_data.cameras.info[camID].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(cam_id, file):\n    with open(\n        calibration_path_by_cam(cam_id, walleye_data.cameras.info[cam_id].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        cal_data = json.loads(file.decode())\n        cal_data[\"camPath\"] = cam_id\n        json.dump(cal_data, outFile)\n\n        # Load\n        cal_data[\"K\"] = np.asarray(cal_data[\"K\"])\n        cal_data[\"dist\"] = np.asarray(cal_data[\"dist\"])\n        walleye_data.cameras.setCalibration(cam_id, cal_data[\"K\"], cal_data[\"dist\"])\n        walleye_data.cameras.info[cam_id].calibrationPath = calibration_path_by_cam(\n            cam_id, walleye_data.cameras.info[cam_id].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for cam_id in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(cam_id)\n            logger.info(f\"Camera config imported for {cam_id}\")\n\n    logger.info(f\"Configs sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[camID].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    return Response(\n        visualization_buffers[camID].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n"]]], 1715210965.9893875]], ["ChangeSet", ["Renaming <camID> to <cam_id>", [["ChangeContents", ["web_interface/web_interface.py", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualization_buffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(cam_id, new_value):\n    walleye_data.cameras.setBrightness(cam_id, float(new_value))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(cam_id, new_value):\n    walleye_data.cameras.setExposure(cam_id, float(new_value))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(cam_id, new_value):\n    w, h = map(int, new_value[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(cam_id, (w, h)):\n        walleye_data.status = f\"Resolution set to {new_value}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {new_value}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(cam_id):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = cam_id\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {cam_id}\")\n        walleye_data.status = f\"Starting calibration capture for {cam_id}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(cam_id):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = cam_id\n    walleye_data.cameras.info[cam_id].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(cam_id, file):\n    with open(\n        calibration_path_by_cam(cam_id, walleye_data.cameras.info[cam_id].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        cal_data = json.loads(file.decode())\n        cal_data[\"camPath\"] = cam_id\n        json.dump(cal_data, outFile)\n\n        # Load\n        cal_data[\"K\"] = np.asarray(cal_data[\"K\"])\n        cal_data[\"dist\"] = np.asarray(cal_data[\"dist\"])\n        walleye_data.cameras.setCalibration(cam_id, cal_data[\"K\"], cal_data[\"dist\"])\n        walleye_data.cameras.info[cam_id].calibrationPath = calibration_path_by_cam(\n            cam_id, walleye_data.cameras.info[cam_id].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for cam_id in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(cam_id)\n            logger.info(f\"Camera config imported for {cam_id}\")\n\n    logger.info(f\"Configs sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[camID].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    return Response(\n        visualization_buffers[camID].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualization_buffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(cam_id, new_value):\n    walleye_data.cameras.setBrightness(cam_id, float(new_value))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(cam_id, new_value):\n    walleye_data.cameras.setExposure(cam_id, float(new_value))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(cam_id, new_value):\n    w, h = map(int, new_value[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(cam_id, (w, h)):\n        walleye_data.status = f\"Resolution set to {new_value}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {new_value}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(cam_id):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = cam_id\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {cam_id}\")\n        walleye_data.status = f\"Starting calibration capture for {cam_id}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(camID):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = camID\n    walleye_data.cameras.info[camID].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(cam_id, file):\n    with open(\n        calibration_path_by_cam(cam_id, walleye_data.cameras.info[cam_id].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        cal_data = json.loads(file.decode())\n        cal_data[\"camPath\"] = cam_id\n        json.dump(cal_data, outFile)\n\n        # Load\n        cal_data[\"K\"] = np.asarray(cal_data[\"K\"])\n        cal_data[\"dist\"] = np.asarray(cal_data[\"dist\"])\n        walleye_data.cameras.setCalibration(cam_id, cal_data[\"K\"], cal_data[\"dist\"])\n        walleye_data.cameras.info[cam_id].calibrationPath = calibration_path_by_cam(\n            cam_id, walleye_data.cameras.info[cam_id].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for cam_id in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(cam_id)\n            logger.info(f\"Camera config imported for {cam_id}\")\n\n    logger.info(f\"Configs sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[camID].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    return Response(\n        visualization_buffers[camID].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n"]]], 1715210967.8066158]], ["ChangeSet", ["Renaming <camID> to <cam_id>", [["ChangeContents", ["web_interface/web_interface.py", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualization_buffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(cam_id, new_value):\n    walleye_data.cameras.setBrightness(cam_id, float(new_value))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(cam_id, new_value):\n    walleye_data.cameras.setExposure(cam_id, float(new_value))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(cam_id, new_value):\n    w, h = map(int, new_value[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(cam_id, (w, h)):\n        walleye_data.status = f\"Resolution set to {new_value}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {new_value}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(cam_id):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = cam_id\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {cam_id}\")\n        walleye_data.status = f\"Starting calibration capture for {cam_id}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(cam_id):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = cam_id\n    walleye_data.cameras.info[cam_id].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(cam_id, file):\n    with open(\n        calibration_path_by_cam(cam_id, walleye_data.cameras.info[cam_id].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        cal_data = json.loads(file.decode())\n        cal_data[\"camPath\"] = cam_id\n        json.dump(cal_data, outFile)\n\n        # Load\n        cal_data[\"K\"] = np.asarray(cal_data[\"K\"])\n        cal_data[\"dist\"] = np.asarray(cal_data[\"dist\"])\n        walleye_data.cameras.setCalibration(cam_id, cal_data[\"K\"], cal_data[\"dist\"])\n        walleye_data.cameras.info[cam_id].calibrationPath = calibration_path_by_cam(\n            cam_id, walleye_data.cameras.info[cam_id].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for cam_id in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(cam_id)\n            logger.info(f\"Camera config imported for {cam_id}\")\n\n    logger.info(f\"Configs sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(cam_id):\n    if cam_id not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {cam_id}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[cam_id].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    return Response(\n        visualization_buffers[camID].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualization_buffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(cam_id, new_value):\n    walleye_data.cameras.setBrightness(cam_id, float(new_value))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(cam_id, new_value):\n    walleye_data.cameras.setExposure(cam_id, float(new_value))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(cam_id, new_value):\n    w, h = map(int, new_value[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(cam_id, (w, h)):\n        walleye_data.status = f\"Resolution set to {new_value}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {new_value}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(cam_id):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = cam_id\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {cam_id}\")\n        walleye_data.status = f\"Starting calibration capture for {cam_id}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(cam_id):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = cam_id\n    walleye_data.cameras.info[cam_id].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(cam_id, file):\n    with open(\n        calibration_path_by_cam(cam_id, walleye_data.cameras.info[cam_id].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        cal_data = json.loads(file.decode())\n        cal_data[\"camPath\"] = cam_id\n        json.dump(cal_data, outFile)\n\n        # Load\n        cal_data[\"K\"] = np.asarray(cal_data[\"K\"])\n        cal_data[\"dist\"] = np.asarray(cal_data[\"dist\"])\n        walleye_data.cameras.setCalibration(cam_id, cal_data[\"K\"], cal_data[\"dist\"])\n        walleye_data.cameras.info[cam_id].calibrationPath = calibration_path_by_cam(\n            cam_id, walleye_data.cameras.info[cam_id].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for cam_id in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(cam_id)\n            logger.info(f\"Camera config imported for {cam_id}\")\n\n    logger.info(f\"Configs sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[camID].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    return Response(\n        visualization_buffers[camID].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n"]]], 1715210969.7275398]], ["ChangeSet", ["Renaming <camID> to <cam_id>", [["ChangeContents", ["web_interface/web_interface.py", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualization_buffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(cam_id, new_value):\n    walleye_data.cameras.setBrightness(cam_id, float(new_value))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(cam_id, new_value):\n    walleye_data.cameras.setExposure(cam_id, float(new_value))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(cam_id, new_value):\n    w, h = map(int, new_value[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(cam_id, (w, h)):\n        walleye_data.status = f\"Resolution set to {new_value}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {new_value}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(cam_id):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = cam_id\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {cam_id}\")\n        walleye_data.status = f\"Starting calibration capture for {cam_id}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(cam_id):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = cam_id\n    walleye_data.cameras.info[cam_id].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(cam_id, file):\n    with open(\n        calibration_path_by_cam(cam_id, walleye_data.cameras.info[cam_id].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        cal_data = json.loads(file.decode())\n        cal_data[\"camPath\"] = cam_id\n        json.dump(cal_data, outFile)\n\n        # Load\n        cal_data[\"K\"] = np.asarray(cal_data[\"K\"])\n        cal_data[\"dist\"] = np.asarray(cal_data[\"dist\"])\n        walleye_data.cameras.setCalibration(cam_id, cal_data[\"K\"], cal_data[\"dist\"])\n        walleye_data.cameras.info[cam_id].calibrationPath = calibration_path_by_cam(\n            cam_id, walleye_data.cameras.info[cam_id].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for cam_id in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(cam_id)\n            logger.info(f\"Camera config imported for {cam_id}\")\n\n    logger.info(f\"Configs sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(cam_id):\n    if cam_id not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {cam_id}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[cam_id].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(cam_id):\n    if cam_id not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {cam_id}\")\n        return\n\n    return Response(\n        visualization_buffers[cam_id].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualization_buffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(cam_id, new_value):\n    walleye_data.cameras.setBrightness(cam_id, float(new_value))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(cam_id, new_value):\n    walleye_data.cameras.setExposure(cam_id, float(new_value))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(cam_id, new_value):\n    w, h = map(int, new_value[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(cam_id, (w, h)):\n        walleye_data.status = f\"Resolution set to {new_value}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {new_value}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(cam_id):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = cam_id\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {cam_id}\")\n        walleye_data.status = f\"Starting calibration capture for {cam_id}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(cam_id):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = cam_id\n    walleye_data.cameras.info[cam_id].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(cam_id, file):\n    with open(\n        calibration_path_by_cam(cam_id, walleye_data.cameras.info[cam_id].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        cal_data = json.loads(file.decode())\n        cal_data[\"camPath\"] = cam_id\n        json.dump(cal_data, outFile)\n\n        # Load\n        cal_data[\"K\"] = np.asarray(cal_data[\"K\"])\n        cal_data[\"dist\"] = np.asarray(cal_data[\"dist\"])\n        walleye_data.cameras.setCalibration(cam_id, cal_data[\"K\"], cal_data[\"dist\"])\n        walleye_data.cameras.info[cam_id].calibrationPath = calibration_path_by_cam(\n            cam_id, walleye_data.cameras.info[cam_id].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for cam_id in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(cam_id)\n            logger.info(f\"Camera config imported for {cam_id}\")\n\n    logger.info(f\"Configs sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(cam_id):\n    if cam_id not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {cam_id}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[cam_id].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(camID):\n    if camID not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {camID}\")\n        return\n\n    return Response(\n        visualization_buffers[camID].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n"]]], 1715210972.7824428]], ["ChangeSet", ["Renaming <displayInfo> to <display_info>", [["ChangeContents", ["web_interface/web_interface.py", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualization_buffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef display_info(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(cam_id, new_value):\n    walleye_data.cameras.setBrightness(cam_id, float(new_value))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(cam_id, new_value):\n    walleye_data.cameras.setExposure(cam_id, float(new_value))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(cam_id, new_value):\n    w, h = map(int, new_value[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(cam_id, (w, h)):\n        walleye_data.status = f\"Resolution set to {new_value}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {new_value}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(cam_id):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = cam_id\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {cam_id}\")\n        walleye_data.status = f\"Starting calibration capture for {cam_id}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(cam_id):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = cam_id\n    walleye_data.cameras.info[cam_id].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(cam_id, file):\n    with open(\n        calibration_path_by_cam(cam_id, walleye_data.cameras.info[cam_id].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        cal_data = json.loads(file.decode())\n        cal_data[\"camPath\"] = cam_id\n        json.dump(cal_data, outFile)\n\n        # Load\n        cal_data[\"K\"] = np.asarray(cal_data[\"K\"])\n        cal_data[\"dist\"] = np.asarray(cal_data[\"dist\"])\n        walleye_data.cameras.setCalibration(cam_id, cal_data[\"K\"], cal_data[\"dist\"])\n        walleye_data.cameras.info[cam_id].calibrationPath = calibration_path_by_cam(\n            cam_id, walleye_data.cameras.info[cam_id].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for cam_id in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(cam_id)\n            logger.info(f\"Camera config imported for {cam_id}\")\n\n    logger.info(f\"Configs sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(cam_id):\n    if cam_id not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {cam_id}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[cam_id].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(cam_id):\n    if cam_id not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {cam_id}\")\n        return\n\n    return Response(\n        visualization_buffers[cam_id].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n", "from flask import Response, Flask, send_from_directory\nimport os\nfrom flask_socketio import SocketIO\nimport json\nfrom directory import CONFIG_ZIP, calibration_path_by_cam\nfrom state import walleye_data, States\nimport logging\nimport numpy as np\nfrom web_interface.image_streams import Buffer, LivePlotBuffer\nimport zipfile\nimport pathlib\nimport io\n\n# import asyncio\n\nlogger = logging.getLogger(__name__)\n\n\napp = Flask(__name__, static_folder=\"./walleye/build\", static_url_path=\"/\")\nsocketio = SocketIO(\n    app,\n    logger=True,\n    cors_allowed_origins=\"*\",\n    async_mode=\"gevent\",\n)\n\ncam_buffers = {identifier: Buffer() for identifier in walleye_data.cameras.info.keys()}\nvisualization_buffers = {\n    identifier: LivePlotBuffer() for identifier in walleye_data.cameras.info.keys()\n}\n\n\n# def iter_over_async(ait, loop):\n#     ait = ait.__aiter__()\n\n#     async def get_next():\n#         try:\n#             obj = await ait.__anext__()\n#             return False, obj\n#         except StopAsyncIteration:\n#             return True, None\n\n#     while True:\n#         done, obj = loop.run_until_complete(get_next())\n#         if done:\n#             break\n#         yield obj\n\n\ndef displayInfo(msg):\n    logger.info(f\"Sending message to web interface: {msg}\")\n    walleye_data.status = msg\n\n\ndef update_after(action):\n    def action_and_update(*args, **kwargs):\n        action(*args, **kwargs)\n        send_state_update()\n        # logger.info(action.__name__)\n\n    return action_and_update\n\n\n# @socketio.on_error_default\n# def default_error_handler(e):\n#     logger.critical(e)\n#     socketio.emit(\"error\", \"An error occured: \" + str(e))\n\n\n@socketio.on(\"connect\")\n@update_after\ndef connect():\n    logger.info(\"Client connected\")\n\n\n@socketio.on(\"disconnect\")\ndef disconnect():\n    logger.warning(\"Client disconnected\")\n\n\n@socketio.on(\"set_brightness\")\n@update_after\ndef set_brightness(cam_id, new_value):\n    walleye_data.cameras.setBrightness(cam_id, float(new_value))\n\n\n@socketio.on(\"set_exposure\")\n@update_after\ndef set_exposure(cam_id, new_value):\n    walleye_data.cameras.setExposure(cam_id, float(new_value))\n\n\n@socketio.on(\"set_resolution\")\n@update_after\ndef set_resolution(cam_id, new_value):\n    w, h = map(int, new_value[1:-1].split(\",\"))\n    if walleye_data.cameras.setResolution(cam_id, (w, h)):\n        walleye_data.status = f\"Resolution set to {new_value}\"\n    else:\n        walleye_data.status = f\"Could not set resolution: {new_value}\"\n\n\n@socketio.on(\"toggle_calibration\")\n@update_after\ndef toggle_calibration(cam_id):\n    if walleye_data.current_state in (States.IDLE, States.PROCESSING):\n        walleye_data.camera_in_calibration = cam_id\n        walleye_data.reprojection_error = None\n        walleye_data.current_state = States.BEGIN_CALIBRATION\n        logger.info(f\"Starting calibration capture for {cam_id}\")\n        walleye_data.status = f\"Starting calibration capture for {cam_id}\"\n\n    elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n        walleye_data.current_state = States.IDLE\n        logger.info(f\"Stopping calibration capture\")\n        walleye_data.status = f\"Stopping calibration capture\"\n\n\n@socketio.on(\"generate_calibration\")\n@update_after\ndef generate_calibration(cam_id):\n    walleye_data.current_state = States.GENERATE_CALIBRATION\n    walleye_data.camera_in_calibration = cam_id\n    walleye_data.cameras.info[cam_id].calibrationPath = None\n    walleye_data.status = \"Calibration generation\"\n\n\n@socketio.on(\"import_calibration\")\n@update_after\ndef import_calibration(cam_id, file):\n    with open(\n        calibration_path_by_cam(cam_id, walleye_data.cameras.info[cam_id].resolution),\n        \"w\",\n    ) as outFile:\n        # Save\n        cal_data = json.loads(file.decode())\n        cal_data[\"camPath\"] = cam_id\n        json.dump(cal_data, outFile)\n\n        # Load\n        cal_data[\"K\"] = np.asarray(cal_data[\"K\"])\n        cal_data[\"dist\"] = np.asarray(cal_data[\"dist\"])\n        walleye_data.cameras.setCalibration(cam_id, cal_data[\"K\"], cal_data[\"dist\"])\n        walleye_data.cameras.info[cam_id].calibrationPath = calibration_path_by_cam(\n            cam_id, walleye_data.cameras.info[cam_id].resolution\n        )\n\n    logger.info(f\"Calibration sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Calibration loaded\"\n\n\n@socketio.on(\"import_config\")\n@update_after\ndef import_config(file):\n    logger.info(\"Importing config\")\n    walleye_data.status = \"Importing config\"\n    with zipfile.ZipFile(io.BytesIO(file), \"r\") as config:\n        for name in config.namelist():\n            config.extract(name)\n            logger.info(f\"Extracted {name}\")\n\n        logger.info(f\"Connected cams: {list(walleye_data.cameras.info)}\")\n\n        for cam_id in walleye_data.cameras.info.keys():\n            walleye_data.cameras.importConfig(cam_id)\n            logger.info(f\"Camera config imported for {cam_id}\")\n\n    logger.info(f\"Configs sucessfully imported for {cam_id}\")\n    walleye_data.status = \"Configs/Cals loaded\"\n\n\n@socketio.on(\"export_config\")\n@update_after\ndef export_config():\n    logger.info(\"Attempting to prepare config.zip\")\n    walleye_data.status = \"Attempting to prepare config.zip\"\n    directory = pathlib.Path(\".\")\n\n    with zipfile.ZipFile(CONFIG_ZIP, \"w\") as config:\n        logger.info(f\"Opening {CONFIG_ZIP} for writing\")\n\n        for f in directory.rglob(\"config_data/*\"):\n            config.write(f)\n            logger.info(f\"Zipping {f}\")\n\n        config.write(CONFIG_ZIP)\n        logger.info(f\"Zipping {CONFIG_ZIP}\")\n\n    logger.info(f\"Config sucessfully zipped\")\n    walleye_data.status = \"Config.zip ready\"\n    socketio.emit(\"config_ready\")\n\n\n@socketio.on(\"set_table_name\")\n@update_after\ndef set_table_name(name):\n    walleye_data.make_publisher(walleye_data.team_number, name)\n\n\n@socketio.on(\"set_team_number\")\n@update_after\ndef set_team_number(number):\n    walleye_data.make_publisher(int(number), walleye_data.table_name)\n\n\n@socketio.on(\"set_tag_size\")\n@update_after\ndef set_tag_size(size):\n    walleye_data.set_tag_size(float(size))\n\n\n@socketio.on(\"set_board_dims\")\n@update_after\ndef set_board_dims(w, h):\n    walleye_data.board_dims = (int(w), int(h))\n    walleye_data.set_board_dim(walleye_data.board_dims)\n    logger.info(f\"Board dimensions set: {(w, h)}\")\n\n\n@socketio.on(\"set_static_ip\")\n@update_after\ndef set_static_ip(ip):\n    walleye_data.set_ip(str(ip))\n\n\n@socketio.on(\"shutdown\")\n@update_after\ndef shutdown():\n    walleye_data.current_state = States.SHUTDOWN\n    socketio.stop()\n\n\n@socketio.on(\"toggle_pnp\")\n@update_after\ndef toggle_pnp():\n    if walleye_data.current_state == States.PROCESSING:\n        walleye_data.current_state = States.IDLE\n        logger.info(\"PnP stopped\")\n    else:\n        walleye_data.current_state = States.PROCESSING\n        logger.info(\"PnP started\")\n\n\n@socketio.on(\"toggle_pose_visualization\")\n@update_after\ndef toggle_pose_visualization():\n    walleye_data.visualizing_poses = not walleye_data.visualizing_poses\n    walleye_data.status = (\n        \"Visualizing poses\"\n        if walleye_data.visualizing_poses\n        else \"Not visualizating poses\"\n    )\n\n\n@socketio.on(\"pose_update\")\ndef pose_update():\n    socketio.sleep(0)\n    socketio.emit(\"pose_update\", walleye_data.poses)\n\n\n@socketio.on(\"performance_update\")\ndef performance_update():\n    socketio.sleep(0)\n    socketio.emit(\"performance_update\", walleye_data.loop_time)\n\n\n@socketio.on(\"msg_update\")\ndef msg_update():\n    socketio.sleep(0)\n    socketio.emit(\"msg_update\", walleye_data.status)\n\n\ndef send_state_update():\n    # logger.info(f\"Sending state update : {walleye_data.get_state()}\")\n    socketio.sleep(0)\n    socketio.emit(\"state_update\", walleye_data.get_state())\n\n\n@app.route(\"/files/<path:path>\")\ndef files(path):\n    return send_from_directory(os.getcwd(), path, as_attachment=True)\n\n\n@app.route(\"/video_feed/<camID>\")\ndef video_feed(cam_id):\n    if cam_id not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {cam_id}\")\n        return\n\n    # loop = asyncio.new_event_loop()\n    # asyncio.set_event_loop(loop)\n    # img = iter_over_async(camBuffers[camID].output(), loop)\n\n    return Response(\n        cam_buffers[cam_id].output(), mimetype=\"multipart/x-mixed-replace; boundary=frame\"\n    )\n\n\n@app.route(\"/pose_visualization/<camID>\")\ndef pose_visualization(cam_id):\n    if cam_id not in cam_buffers:\n        logger.error(f\"Bad cam id recieved: {cam_id}\")\n        return\n\n    return Response(\n        visualization_buffers[cam_id].output(),\n        mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n    )\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return app.send_static_file(\"index.html\")\n"]]], 1715210976.346753]], ["ChangeSet", ["Renaming <V4L_PATH> to <V4L_PATH_XxX_CamelSnakePep8_PreserveName_XxX_1>", [["ChangeContents", ["camera/camera.py", "import cv2\nfrom camera.boot_up import write_config, parse_config\nfrom calibration.calibration import Calibration\nimport os\nimport time\nfrom sys import platform\nimport logging\nfrom camera.camera_info import CameraInfo, EXPOSURE, BRIGHTNESS\nfrom pathlib import Path\nfrom directory import V4L_PATH_XxX_CamelSnakePep8_PreserveName_XxX_1, full_cam_path, calibration_path_by_cam\nimport json\n\n\nclass Cameras:\n    logger = logging.getLogger(__name__)\n\n    def __init__(self):\n        # Cameras identified by their path (or whatever unique identifier is\n        # available)\n        self.info = {}\n\n        if platform == \"linux\" or platform == \"linux2\":\n            Cameras.logger.info(\"Platform is linux\")\n\n            # Automatically detect cameras\n            try:\n                camera_paths = os.listdir(V4L_PATH_XxX_CamelSnakePep8_PreserveName_XxX_1)\n            except FileNotFoundError:\n                camera_paths = []\n                Cameras.logger.error(\"No cameras detected!!\")\n\n            # Try all cameras found by the PI\n            for identifier in camera_paths:\n                if (\n                    Path(\"../../../deadeye\").is_dir()\n                    and identifier\n                    == \"platform-xhci-hcd.9.auto-usb-0:1:1.0-video-index0\"\n                ):\n                    continue\n\n                path = full_cam_path(identifier)\n\n                # Open camera and check if it is opened\n                cam = cv2.VideoCapture(path, cv2.CAP_V4L2)\n\n                if cam.isOpened():\n                    Cameras.logger.info(f\"Camera found: {identifier}\")\n\n                    # Get supported resolutions using v4l2-ctl and a little\n                    # regex\n                    # OLD (from import v4l_cmd_line import getFormats, getSettings)\n                    # supportedResolutions, formats = getFormats(identifier)\n                    # exposureRange, brightnessRange = getSettings(identifier)\n\n                    # Initialize CameraInfo object\n                    self.info[identifier] = CameraInfo(cam, identifier)\n\n                    Cameras.logger.info(\n                        f\"Supported resolutions: {self.info[identifier].get_supported_resolutions()}\"\n                    )\n                    Cameras.logger.info(\n                        f\"Supported formats: {list(self.info[identifier].valid_formats.keys())}\"\n                    )\n                    Cameras.logger.info(\n                        f\"Supported exposures (min, max, step): {self.info[identifier].exposure_range}\"\n                    )\n                    Cameras.logger.info(\n                        f\"Supported brightnesses (min, max, step): {self.info[identifier].brightness_range}\"\n                    )\n\n                    # Disable buffer so we always pull the latest image\n                    cam.set(cv2.CAP_PROP_BUFFERSIZE, 1)\n\n                    # Try to disable auto exposure\n                    if cam.set(cv2.CAP_PROP_AUTO_EXPOSURE, 1):\n                        Cameras.logger.info(f\"Auto exposure disabled for {identifier}\")\n                    else:\n                        Cameras.logger.warning(\n                            f\"Failed to disable auto exposure for {identifier}\"\n                        )\n\n                    # Attempt to import config from file\n                    self.import_config(identifier)\n\n                    # Save configs\n                    write_config(\n                        identifier,\n                        self.get_resolutions()[identifier],\n                        self.get_brightnesss()[identifier],\n                        self.get_exposures()[identifier],\n                    )\n\n                else:\n                    Cameras.logger.warning(f\"Failed to open camera: {identifier}\")\n\n        else:\n            Cameras.logger.error(\"Unsupported platform!\")\n\n    def set_calibration(self, identifier, K, D):\n        self.info[identifier].K = K\n        self.info[identifier].D = D\n\n        Cameras.logger.info(f\"Calibration set for {identifier}, using {K}\\n{D}\")\n\n    # Return a list of camera matrixs\n    def list_k(self):\n        return [i.K for i in self.info.values()]\n\n    # Return a list of camera distortion coefficients\n    def list_d(self):\n        return [i.D for i in self.info.values()]\n\n    # Grab frames from each camera specifically for processing\n    def get_frames_for_processing(self):\n        frames = {}\n        connections = {}\n        delay = {}\n        for identifier, camInfo in self.info.items():\n            ret, img = camInfo.cam.read()\n\n            # if not ret:\n            #     Cameras.logger.error(f\"Failed to capture image: {identifier}\")\n\n            frames[identifier] = img\n            connections[identifier] = ret\n            delay[identifier] = time.clock_gettime_ns(\n                time.CLOCK_MONOTONIC\n            ) / 1000000 - camInfo.cam.get(\n                cv2.CAP_PROP_POS_MSEC\n            )  # Expect -28 to -32 on laptop testing TODO CHECK THIS\n\n        return (connections, frames, delay)\n\n    # Sets resolution, video format, and FPS\n    def set_resolution(self, identifier, resolution):\n        if resolution is None:\n            Cameras.logger.info(\"Resolution not set\")\n            return False\n        # set resolution, fps, and video format\n        # os.system(f\"v4l2-ctl -d /dev/v4l/by-path/{identifier} --set-fmt-video=width={resolution[0]},height={resolution[1]}\")\n        self.info[identifier].cam.set(cv2.CAP_PROP_FRAME_HEIGHT, resolution[1])\n        self.info[identifier].cam.set(cv2.CAP_PROP_FRAME_WIDTH, resolution[0])\n        self.info[identifier].cam.set(\n            cv2.CAP_PROP_FOURCC,\n            cv2.VideoWriter_fourcc(\n                *(\n                    \"YUYV\"\n                    if \"YUYV\" in \"\".join(self.info[identifier].valid_formats)\n                    else \"GREY\"\n                )\n            ),\n        )\n        # self.info[identifier].cam.set(cv2.CAP_PROP_FOURCC, cv2.VideoWriter_fourcc(*\"YUYV\"))\n        self.info[identifier].cam.set(cv2.CAP_PROP_FPS, 5)  # Lower can be better\n        resolution = tuple(resolution)\n\n        # Test if resolution got set\n        if self.get_resolutions()[identifier] != resolution:\n            Cameras.logger.error(\n                f\"Failed to set resolution to {resolution} for {identifier}, using {self.get_resolutions()[identifier]}\"\n            )\n            return False\n\n        # Write a new config file with the new resolution\n        self.info[identifier].resolution = resolution\n        self.import_calibration(identifier)\n\n        write_config(\n            identifier,\n            resolution,\n            self.get_brightnesss()[identifier],\n            self.get_exposures()[identifier],\n        )\n\n        Cameras.logger.info(f\"Resolution set to {resolution} for {identifier}\")\n        return True\n\n    def set_brightness(self, identifier, brightness):\n        if brightness is None:\n            Cameras.logger.info(\"Brightness not set\")\n            return False\n\n        success = self.info[identifier].set(BRIGHTNESS, brightness)\n\n        if success:\n            write_config(\n                identifier,\n                self.get_resolutions()[identifier],\n                brightness,\n                self.get_exposures()[identifier],\n            )\n\n        return success\n\n        # Set brightness through command line\n        # returned = setBrightness(identifier, brightness)\n\n        # Check if it set, if so write it to a file\n        # if returned != 0:\n        #     Cameras.logger.warning(\n        #         f\"Brightness not set: {brightness} not accepted on camera {identifier}\"\n        #     )\n        #     return False\n        # else:\n        #     Cameras.logger.info(f\"Brightness set to {brightness}\")\n        #     writeConfig(\n        #         identifier,\n        #         self.getResolutions()[identifier],\n        #         brightness,\n        #         self.getExposures()[identifier],\n        #     )\n        #     return True\n\n    def set_exposure(self, identifier, exposure):\n        if exposure is None:\n            Cameras.logger.info(\"Exposure not set\")\n            return False\n\n        success = self.info[identifier].set(EXPOSURE, exposure)\n\n        if success:\n            write_config(\n                identifier,\n                self.get_resolutions()[identifier],\n                self.get_brightnesss()[identifier],\n                exposure,\n            )\n\n        return success\n\n        # Set exposure with a command\n        # returned = setExposure(identifier, exposure)\n\n        # Check if it set, if so write it to a file\n        # if returned != 0:\n        #     Cameras.logger.warning(\n        #         f\"Exposure not set: {exposure} not accepted on camera {identifier}\"\n        #     )\n        #     return False\n        # else:\n        #     Cameras.logger.info(f\"Exposure set to {exposure}\")\n\n        #     writeConfig(\n        #         identifier,\n        #         self.getResolutions()[identifier],\n        #         self.getBrightnesss()[identifier],\n        #         exposure,\n        #     )\n        #     return True\n\n    # Return a dictionary of all camera exposures\n    def get_exposures(self):\n        return {\n            identifier: camInfo.cam.get(cv2.CAP_PROP_EXPOSURE)\n            for identifier, camInfo in self.info.items()\n        }\n\n    # Return a dictionary of all camera brightnesss\n    def get_brightnesss(self):\n        return {\n            identifier: camInfo.cam.get(cv2.CAP_PROP_BRIGHTNESS)\n            for identifier, camInfo in self.info.items()\n        }\n\n    # Return a dictionary of all camera resolutions\n    def get_resolutions(self):\n        resolution = {}\n        for identifier, camInfo in self.info.items():\n            resolution[identifier] = (\n                int(camInfo.cam.get(cv2.CAP_PROP_FRAME_WIDTH)),\n                int(camInfo.cam.get(cv2.CAP_PROP_FRAME_HEIGHT)),\n            )\n\n        return {\n            identifier: (\n                int(camInfo.cam.get(cv2.CAP_PROP_FRAME_WIDTH)),\n                int(camInfo.cam.get(cv2.CAP_PROP_FRAME_HEIGHT)),\n            )\n            for identifier, camInfo in self.info.items()\n        }\n\n    # Find a calibration for the camera\n    def import_calibration(self, identifier):\n        resolution = tuple(self.info[identifier].resolution)\n\n        # Look for the calibration file\n        try:\n            calib = Calibration.parse_calibration(\n                calibration_path_by_cam(identifier, resolution)\n            )\n\n            # grab the camera matrix and distortion coefficent and set it\n            self.set_calibration(identifier, calib[\"K\"], calib[\"dist\"])\n            self.info[identifier].calibrationPath = calibration_path_by_cam(\n                identifier, resolution\n            )\n            return True\n        except (FileNotFoundError, json.decoder.JSONDecodeError):\n            self.info[identifier].calibrationPath = None\n            Cameras.logger.error(\n                f\"Calibration not found for camera {identifier} at resolution {resolution}\"\n            )\n            return False\n\n    def import_config(self, identifier):\n        # Attempt to import config from file\n        Cameras.logger.info(f\"Attempting to import config for {identifier}\")\n        config = None\n\n        try:\n            # Parse config from config file\n            config = parse_config(identifier)\n            Cameras.logger.info(f\"Config found!\")\n\n        except (FileNotFoundError, json.decoder.JSONDecodeError):\n            Cameras.logger.warning(f\"Config not found for camera {identifier}\")\n\n        if config is not None:\n            # Config was found, set config data\n            if not self.set_resolution(\n                identifier, config[\"Resolution\"]\n            ):  # Calls self.importCalibration iff resolution was set\n                self.import_calibration(identifier)\n            self.set_brightness(identifier, config[\"Brightness\"])\n            self.set_exposure(identifier, config[\"Exposure\"])\n\n        else:\n            self.import_calibration(identifier)\n            Cameras.logger.warning(f\"Camera config not found for camera {identifier}\")\n\n        return config\n", "import cv2\nfrom camera.boot_up import write_config, parse_config\nfrom calibration.calibration import Calibration\nimport os\nimport time\nfrom sys import platform\nimport logging\nfrom camera.camera_info import CameraInfo, EXPOSURE, BRIGHTNESS\nfrom pathlib import Path\nfrom directory import V4L_PATH, full_cam_path, calibration_path_by_cam\nimport json\n\n\nclass Cameras:\n    logger = logging.getLogger(__name__)\n\n    def __init__(self):\n        # Cameras identified by their path (or whatever unique identifier is\n        # available)\n        self.info = {}\n\n        if platform == \"linux\" or platform == \"linux2\":\n            Cameras.logger.info(\"Platform is linux\")\n\n            # Automatically detect cameras\n            try:\n                camera_paths = os.listdir(V4L_PATH)\n            except FileNotFoundError:\n                camera_paths = []\n                Cameras.logger.error(\"No cameras detected!!\")\n\n            # Try all cameras found by the PI\n            for identifier in camera_paths:\n                if (\n                    Path(\"../../../deadeye\").is_dir()\n                    and identifier\n                    == \"platform-xhci-hcd.9.auto-usb-0:1:1.0-video-index0\"\n                ):\n                    continue\n\n                path = full_cam_path(identifier)\n\n                # Open camera and check if it is opened\n                cam = cv2.VideoCapture(path, cv2.CAP_V4L2)\n\n                if cam.isOpened():\n                    Cameras.logger.info(f\"Camera found: {identifier}\")\n\n                    # Get supported resolutions using v4l2-ctl and a little\n                    # regex\n                    # OLD (from import v4l_cmd_line import getFormats, getSettings)\n                    # supportedResolutions, formats = getFormats(identifier)\n                    # exposureRange, brightnessRange = getSettings(identifier)\n\n                    # Initialize CameraInfo object\n                    self.info[identifier] = CameraInfo(cam, identifier)\n\n                    Cameras.logger.info(\n                        f\"Supported resolutions: {self.info[identifier].get_supported_resolutions()}\"\n                    )\n                    Cameras.logger.info(\n                        f\"Supported formats: {list(self.info[identifier].valid_formats.keys())}\"\n                    )\n                    Cameras.logger.info(\n                        f\"Supported exposures (min, max, step): {self.info[identifier].exposure_range}\"\n                    )\n                    Cameras.logger.info(\n                        f\"Supported brightnesses (min, max, step): {self.info[identifier].brightness_range}\"\n                    )\n\n                    # Disable buffer so we always pull the latest image\n                    cam.set(cv2.CAP_PROP_BUFFERSIZE, 1)\n\n                    # Try to disable auto exposure\n                    if cam.set(cv2.CAP_PROP_AUTO_EXPOSURE, 1):\n                        Cameras.logger.info(f\"Auto exposure disabled for {identifier}\")\n                    else:\n                        Cameras.logger.warning(\n                            f\"Failed to disable auto exposure for {identifier}\"\n                        )\n\n                    # Attempt to import config from file\n                    self.import_config(identifier)\n\n                    # Save configs\n                    write_config(\n                        identifier,\n                        self.get_resolutions()[identifier],\n                        self.get_brightnesss()[identifier],\n                        self.get_exposures()[identifier],\n                    )\n\n                else:\n                    Cameras.logger.warning(f\"Failed to open camera: {identifier}\")\n\n        else:\n            Cameras.logger.error(\"Unsupported platform!\")\n\n    def set_calibration(self, identifier, K, D):\n        self.info[identifier].K = K\n        self.info[identifier].D = D\n\n        Cameras.logger.info(f\"Calibration set for {identifier}, using {K}\\n{D}\")\n\n    # Return a list of camera matrixs\n    def list_k(self):\n        return [i.K for i in self.info.values()]\n\n    # Return a list of camera distortion coefficients\n    def list_d(self):\n        return [i.D for i in self.info.values()]\n\n    # Grab frames from each camera specifically for processing\n    def get_frames_for_processing(self):\n        frames = {}\n        connections = {}\n        delay = {}\n        for identifier, camInfo in self.info.items():\n            ret, img = camInfo.cam.read()\n\n            # if not ret:\n            #     Cameras.logger.error(f\"Failed to capture image: {identifier}\")\n\n            frames[identifier] = img\n            connections[identifier] = ret\n            delay[identifier] = time.clock_gettime_ns(\n                time.CLOCK_MONOTONIC\n            ) / 1000000 - camInfo.cam.get(\n                cv2.CAP_PROP_POS_MSEC\n            )  # Expect -28 to -32 on laptop testing TODO CHECK THIS\n\n        return (connections, frames, delay)\n\n    # Sets resolution, video format, and FPS\n    def set_resolution(self, identifier, resolution):\n        if resolution is None:\n            Cameras.logger.info(\"Resolution not set\")\n            return False\n        # set resolution, fps, and video format\n        # os.system(f\"v4l2-ctl -d /dev/v4l/by-path/{identifier} --set-fmt-video=width={resolution[0]},height={resolution[1]}\")\n        self.info[identifier].cam.set(cv2.CAP_PROP_FRAME_HEIGHT, resolution[1])\n        self.info[identifier].cam.set(cv2.CAP_PROP_FRAME_WIDTH, resolution[0])\n        self.info[identifier].cam.set(\n            cv2.CAP_PROP_FOURCC,\n            cv2.VideoWriter_fourcc(\n                *(\n                    \"YUYV\"\n                    if \"YUYV\" in \"\".join(self.info[identifier].valid_formats)\n                    else \"GREY\"\n                )\n            ),\n        )\n        # self.info[identifier].cam.set(cv2.CAP_PROP_FOURCC, cv2.VideoWriter_fourcc(*\"YUYV\"))\n        self.info[identifier].cam.set(cv2.CAP_PROP_FPS, 5)  # Lower can be better\n        resolution = tuple(resolution)\n\n        # Test if resolution got set\n        if self.get_resolutions()[identifier] != resolution:\n            Cameras.logger.error(\n                f\"Failed to set resolution to {resolution} for {identifier}, using {self.get_resolutions()[identifier]}\"\n            )\n            return False\n\n        # Write a new config file with the new resolution\n        self.info[identifier].resolution = resolution\n        self.import_calibration(identifier)\n\n        write_config(\n            identifier,\n            resolution,\n            self.get_brightnesss()[identifier],\n            self.get_exposures()[identifier],\n        )\n\n        Cameras.logger.info(f\"Resolution set to {resolution} for {identifier}\")\n        return True\n\n    def set_brightness(self, identifier, brightness):\n        if brightness is None:\n            Cameras.logger.info(\"Brightness not set\")\n            return False\n\n        success = self.info[identifier].set(BRIGHTNESS, brightness)\n\n        if success:\n            write_config(\n                identifier,\n                self.get_resolutions()[identifier],\n                brightness,\n                self.get_exposures()[identifier],\n            )\n\n        return success\n\n        # Set brightness through command line\n        # returned = setBrightness(identifier, brightness)\n\n        # Check if it set, if so write it to a file\n        # if returned != 0:\n        #     Cameras.logger.warning(\n        #         f\"Brightness not set: {brightness} not accepted on camera {identifier}\"\n        #     )\n        #     return False\n        # else:\n        #     Cameras.logger.info(f\"Brightness set to {brightness}\")\n        #     writeConfig(\n        #         identifier,\n        #         self.getResolutions()[identifier],\n        #         brightness,\n        #         self.getExposures()[identifier],\n        #     )\n        #     return True\n\n    def set_exposure(self, identifier, exposure):\n        if exposure is None:\n            Cameras.logger.info(\"Exposure not set\")\n            return False\n\n        success = self.info[identifier].set(EXPOSURE, exposure)\n\n        if success:\n            write_config(\n                identifier,\n                self.get_resolutions()[identifier],\n                self.get_brightnesss()[identifier],\n                exposure,\n            )\n\n        return success\n\n        # Set exposure with a command\n        # returned = setExposure(identifier, exposure)\n\n        # Check if it set, if so write it to a file\n        # if returned != 0:\n        #     Cameras.logger.warning(\n        #         f\"Exposure not set: {exposure} not accepted on camera {identifier}\"\n        #     )\n        #     return False\n        # else:\n        #     Cameras.logger.info(f\"Exposure set to {exposure}\")\n\n        #     writeConfig(\n        #         identifier,\n        #         self.getResolutions()[identifier],\n        #         self.getBrightnesss()[identifier],\n        #         exposure,\n        #     )\n        #     return True\n\n    # Return a dictionary of all camera exposures\n    def get_exposures(self):\n        return {\n            identifier: camInfo.cam.get(cv2.CAP_PROP_EXPOSURE)\n            for identifier, camInfo in self.info.items()\n        }\n\n    # Return a dictionary of all camera brightnesss\n    def get_brightnesss(self):\n        return {\n            identifier: camInfo.cam.get(cv2.CAP_PROP_BRIGHTNESS)\n            for identifier, camInfo in self.info.items()\n        }\n\n    # Return a dictionary of all camera resolutions\n    def get_resolutions(self):\n        resolution = {}\n        for identifier, camInfo in self.info.items():\n            resolution[identifier] = (\n                int(camInfo.cam.get(cv2.CAP_PROP_FRAME_WIDTH)),\n                int(camInfo.cam.get(cv2.CAP_PROP_FRAME_HEIGHT)),\n            )\n\n        return {\n            identifier: (\n                int(camInfo.cam.get(cv2.CAP_PROP_FRAME_WIDTH)),\n                int(camInfo.cam.get(cv2.CAP_PROP_FRAME_HEIGHT)),\n            )\n            for identifier, camInfo in self.info.items()\n        }\n\n    # Find a calibration for the camera\n    def import_calibration(self, identifier):\n        resolution = tuple(self.info[identifier].resolution)\n\n        # Look for the calibration file\n        try:\n            calib = Calibration.parse_calibration(\n                calibration_path_by_cam(identifier, resolution)\n            )\n\n            # grab the camera matrix and distortion coefficent and set it\n            self.set_calibration(identifier, calib[\"K\"], calib[\"dist\"])\n            self.info[identifier].calibrationPath = calibration_path_by_cam(\n                identifier, resolution\n            )\n            return True\n        except (FileNotFoundError, json.decoder.JSONDecodeError):\n            self.info[identifier].calibrationPath = None\n            Cameras.logger.error(\n                f\"Calibration not found for camera {identifier} at resolution {resolution}\"\n            )\n            return False\n\n    def import_config(self, identifier):\n        # Attempt to import config from file\n        Cameras.logger.info(f\"Attempting to import config for {identifier}\")\n        config = None\n\n        try:\n            # Parse config from config file\n            config = parse_config(identifier)\n            Cameras.logger.info(f\"Config found!\")\n\n        except (FileNotFoundError, json.decoder.JSONDecodeError):\n            Cameras.logger.warning(f\"Config not found for camera {identifier}\")\n\n        if config is not None:\n            # Config was found, set config data\n            if not self.set_resolution(\n                identifier, config[\"Resolution\"]\n            ):  # Calls self.importCalibration iff resolution was set\n                self.import_calibration(identifier)\n            self.set_brightness(identifier, config[\"Brightness\"])\n            self.set_exposure(identifier, config[\"Exposure\"])\n\n        else:\n            self.import_calibration(identifier)\n            Cameras.logger.warning(f\"Camera config not found for camera {identifier}\")\n\n        return config\n"]], ["ChangeContents", ["directory.py", "import os.path\n\nV4L_PATH_XxX_CamelSnakePep8_PreserveName_XxX_1 = \"/dev/v4l/by-path\"\nCONFIG_DATA_PATH = \"config_data/system_data.json\"\nLOG = \"walleye.log\"\nCONFIG_ZIP = \"config.zip\"\n\n\ndef clean_identifier(identifier):\n    return identifier.replace(\":\", \"-\").replace(\".\", \"-\")\n\n\ndef calibration_image_folder(identifier):\n    return os.path.join(\"config_data\", f\"cam_{clean_identifier(identifier)}_cal_imgs\")\n\n\ndef calibration_path_by_cam(identifier, resolution):\n    return os.path.join(\n        \"config_data\",\n        \"calibrations\",\n        f\"cam_{clean_identifier(identifier)}_{resolution}_cal_data.json\",\n    )\n\n\ndef cam_config_path(identifier):\n    return os.path.join(\n        \"config_data\",\n        \"camera_configs\",\n        f\"config_settings_{clean_identifier(identifier)}.json\",\n    )\n\n\ndef full_cam_path(identifier):\n    return os.path.join(V4L_PATH_XxX_CamelSnakePep8_PreserveName_XxX_1, identifier)\n", "import os.path\n\nV4L_PATH = \"/dev/v4l/by-path\"\nCONFIG_DATA_PATH = \"config_data/system_data.json\"\nLOG = \"walleye.log\"\nCONFIG_ZIP = \"config.zip\"\n\n\ndef clean_identifier(identifier):\n    return identifier.replace(\":\", \"-\").replace(\".\", \"-\")\n\n\ndef calibration_image_folder(identifier):\n    return os.path.join(\"config_data\", f\"cam_{clean_identifier(identifier)}_cal_imgs\")\n\n\ndef calibration_path_by_cam(identifier, resolution):\n    return os.path.join(\n        \"config_data\",\n        \"calibrations\",\n        f\"cam_{clean_identifier(identifier)}_{resolution}_cal_data.json\",\n    )\n\n\ndef cam_config_path(identifier):\n    return os.path.join(\n        \"config_data\",\n        \"camera_configs\",\n        f\"config_settings_{clean_identifier(identifier)}.json\",\n    )\n\n\ndef full_cam_path(identifier):\n    return os.path.join(V4L_PATH, identifier)\n"]]], 1715213076.2233856]], ["ChangeSet", ["Renaming <maxBytes> to <maxBytes_XxX_CamelSnakePep8_PreserveName_XxX_2>", [["ChangeContents", ["init.py", "import sys\nimport logging\nfrom logging.handlers import RotatingFileHandler\nfrom directory import calibration_image_folder, calibration_path_by_cam, LOG\n\n# Create logger and set settings\nLOG_FORMAT = \"[%(asctime)s - %(levelname)s - %(filename)s:%(lineno)s - %(funcName)s()]  %(message)s\"\nlogging.basicConfig(\n    format=LOG_FORMAT,\n    handlers=[\n        logging.StreamHandler(sys.stdout),\n        RotatingFileHandler(LOG, maxBytes_XxX_CamelSnakePep8_PreserveName_XxX_2=1024 * 1024, backupCount=5),\n    ],\n    datefmt=\"%d-%b-%y %H:%M:%S\",\n    level=logging.INFO,\n)\n\nlogger = logging.getLogger(__name__)\n\nlogger.info(\"----------- Starting Up -----------\")\n\nfrom state import walleye_data, States, CALIBRATION_STATES\nfrom processing.processing import Processor\nimport threading\nfrom camera.camera import Cameras\nfrom calibration.calibration import Calibration, CalibType\nimport time\n\n\n# Create and intialize cameras\nwalleye_data.cameras = Cameras()\n\nfrom web_interface.web_interface import (\n    cam_buffers,\n    socketio,\n    app,\n    visualization_buffers\n)  # After walleye_data.cameras is set\n\nweb_server = threading.Thread(\n    target=lambda: socketio.run(\n        app,\n        host=\"0.0.0.0\",\n        port=5800,\n        debug=False,\n        use_reloader=False,\n        log_output=False,\n    ),\n    # daemon=True,\n)\ntry:\n    # Start the web server\n    web_server.start()\n\n    logging.getLogger(\"geventwebsocket.handler\").setLevel(logging.ERROR)\n    logging.getLogger(\"socketio\").setLevel(logging.ERROR)\n    logging.getLogger(\"socketio.server\").setLevel(logging.ERROR)\n    logging.getLogger(\"engineio\").setLevel(logging.ERROR)\n\n\n    logger.info(\"Web server ready\")\n\n    images = {}\n    calibrators = {}\n\n    # Create network tables publisher and AprilTag Processor\n    pose_estimator = Processor(walleye_data.tag_size)\n    # Publisher already created during construction of walleye_data\n    # walleye_data.make_publisher(walleye_data.team_number, walleye_data.table_name)\n    walleye_data.current_state = States.PROCESSING\n\n    logger.info(\"Starting main loop\")\n\n    last_loop_time = time.time()\n\n    # Main loop (Runs everything)\n    while True:\n        # Calculate loop time\n        curr_time = time.time()\n        walleye_data.loop_time = round(curr_time - last_loop_time, 3)\n        last_loop_time = curr_time\n\n        # State changes\n        # Pre-Calibration\n        if walleye_data.current_state == States.BEGIN_CALIBRATION:\n            logger.info(\"Beginning calibration\")\n\n            # Prepare a calibration object for the camera that is being calibrated with pre-set data\n            # only if cal object does not exist yet\n            if (\n                walleye_data.camera_in_calibration not in calibrators\n                or calibrators[walleye_data.camera_in_calibration] is None\n            ):\n                calibrators[walleye_data.camera_in_calibration] = Calibration(\n                    walleye_data.cal_delay,\n                    walleye_data.board_dims,\n                    walleye_data.camera_in_calibration,\n                    calibration_image_folder(walleye_data.camera_in_calibration),\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].resolution,\n                )\n            walleye_data.current_state = States.CALIBRATION_CAPTURE\n\n        # Take calibration images\n        elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n            # Read in frames\n            ret, img = walleye_data.cameras.info[\n                walleye_data.camera_in_calibration\n            ].cam.read()\n\n            if not ret:\n                logger.error(\n                    f\"Failed to capture image: {walleye_data.camera_in_calibration}\"\n                )\n            else:\n                # Process frames with the calibration object created prior\n                returned, used, path_saved = calibrators[\n                    walleye_data.camera_in_calibration\n                ].process_frame(img)\n\n                # If the image is a part of the accepted images save it\n                if used:\n                    walleye_data.cal_img_paths.append(path_saved)\n\n                # Keep a buffer with the images\n                cam_buffers[walleye_data.camera_in_calibration].update(returned)\n\n        # Finished Calibration, generate calibration\n        elif walleye_data.current_state == States.GENERATE_CALIBRATION:\n            # Get file path for the calibration to be saved\n            walleye_data.cameras.info[\n                walleye_data.camera_in_calibration\n            ].calibrationPath = calibration_path_by_cam(\n                walleye_data.camera_in_calibration,\n                walleye_data.cameras.info[walleye_data.camera_in_calibration].resolution,\n            )\n\n            if calibrators[walleye_data.camera_in_calibration] is not None:\n                # Generate a calibration file to the file path\n                has_generated = calibrators[\n                    walleye_data.camera_in_calibration\n                ].generate_calibration(\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].calibration_path\n                )\n\n                if has_generated:\n                    # Get reproj error\n                    walleye_data.reprojection_error = calibrators[\n                        walleye_data.camera_in_calibration\n                    ].get_reprojection_error()\n\n                    # Set the cameras calibration, save off the file path, and\n                    # go to idle\n                    walleye_data.cameras.setCalibration(\n                        walleye_data.camera_in_calibration,\n                        calibrators[walleye_data.camera_in_calibration].calibrationData[\n                            \"K\"\n                        ],\n                        calibrators[walleye_data.camera_in_calibration].calibrationData[\n                            \"dist\"\n                        ],\n                    )\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].calibrationPath = calibration_path_by_cam(\n                        walleye_data.camera_in_calibration,\n                        walleye_data.cameras.info[\n                            walleye_data.camera_in_calibration\n                        ].resolution,\n                    )\n                else:\n                    walleye_data.status = \"Could not generate calibration\"\n            else:\n                walleye_data.status = \"Calibrator for current calibration camera is None\"\n            walleye_data.current_state = States.IDLE\n            calibrators[walleye_data.camera_in_calibration] = None\n\n        # AprilTag processing state\n        elif walleye_data.current_state == States.PROCESSING:\n            # Set tag size, grab camera frames, and grab image timestamp\n            pose_estimator.set_tag_size(walleye_data.tag_size)\n\n            image_time = walleye_data.robot_publisher.get_time() \n\n            connections, images, delay = walleye_data.cameras.get_frames_for_processing()\n\n            for idx, val in enumerate(connections.values()):\n                if not val and walleye_data.robot_publisher.getConnectionValue(idx):\n                    logger.info(\"Camera disconnected\")\n\n                walleye_data.robot_publisher.setConnectionValue(idx, val)\n\n            # Use the pose_estimator class to find the pose, tags, and ambiguity\n            poses, tags, ambig = pose_estimator.get_pose(\n                images.values(),\n                walleye_data.cameras.list_k(),\n                walleye_data.cameras.list_d(),\n            )\n\n            # Publish camera number, timestamp, poses, tags, ambiguity and increase the update number\n            # logger.info(f\"Poses at {image_time}: {poses}\")\n\n            for i in range(len(poses)):\n                if poses[i][0].X() < 2000:\n                    walleye_data.robot_publisher.publish(\n                        i, image_time - delay[i], poses[i], tags[i], ambig[i]\n                    )\n\n            # Update the pose visualization\n            for i, (identifier, img) in enumerate(images.items()):\n                if i >= len(poses):\n                    break\n                cam_buffers[identifier].update(img)\n                walleye_data.set_pose(identifier, poses[i][0])\n                if walleye_data.visualizing_poses:\n                    visualization_buffers[identifier].update(\n                        (poses[i][0].X(), poses[i][0].Y(), poses[i][0].Z()), tags[i][1:]\n                    )\n\n        # Ends the WallEye program through the web interface\n        elif walleye_data.current_state == States.SHUTDOWN:\n            logger.info(\"Shutting down\")\n            logging.shutdown()\n            socketio.stop()\n            break\n\n        # Update cameras no matter what state\n        if walleye_data.current_state != States.PROCESSING:\n            for camera_info in walleye_data.cameras.info.values():\n                if (\n                    camera_info.identifier == walleye_data.camera_in_calibration\n                    and walleye_data.current_state in CALIBRATION_STATES\n                ):\n                    continue\n\n                ret, img = camera_info.cam.read()\n\n                cam_buffers[camera_info.identifier].update(img)\n\nexcept Exception as e:\n    # Something bad happened\n    logging.critical(e, exc_info=True)\n    logger.info(\"Shutting down\")\n    socketio.stop()\n    logging.shutdown()\n", "import sys\nimport logging\nfrom logging.handlers import RotatingFileHandler\nfrom directory import calibration_image_folder, calibration_path_by_cam, LOG\n\n# Create logger and set settings\nLOG_FORMAT = \"[%(asctime)s - %(levelname)s - %(filename)s:%(lineno)s - %(funcName)s()]  %(message)s\"\nlogging.basicConfig(\n    format=LOG_FORMAT,\n    handlers=[\n        logging.StreamHandler(sys.stdout),\n        RotatingFileHandler(LOG, maxBytes=1024 * 1024, backupCount=5),\n    ],\n    datefmt=\"%d-%b-%y %H:%M:%S\",\n    level=logging.INFO,\n)\n\nlogger = logging.getLogger(__name__)\n\nlogger.info(\"----------- Starting Up -----------\")\n\nfrom state import walleye_data, States, CALIBRATION_STATES\nfrom processing.processing import Processor\nimport threading\nfrom camera.camera import Cameras\nfrom calibration.calibration import Calibration, CalibType\nimport time\n\n\n# Create and intialize cameras\nwalleye_data.cameras = Cameras()\n\nfrom web_interface.web_interface import (\n    cam_buffers,\n    socketio,\n    app,\n    visualization_buffers\n)  # After walleye_data.cameras is set\n\nweb_server = threading.Thread(\n    target=lambda: socketio.run(\n        app,\n        host=\"0.0.0.0\",\n        port=5800,\n        debug=False,\n        use_reloader=False,\n        log_output=False,\n    ),\n    # daemon=True,\n)\ntry:\n    # Start the web server\n    web_server.start()\n\n    logging.getLogger(\"geventwebsocket.handler\").setLevel(logging.ERROR)\n    logging.getLogger(\"socketio\").setLevel(logging.ERROR)\n    logging.getLogger(\"socketio.server\").setLevel(logging.ERROR)\n    logging.getLogger(\"engineio\").setLevel(logging.ERROR)\n\n\n    logger.info(\"Web server ready\")\n\n    images = {}\n    calibrators = {}\n\n    # Create network tables publisher and AprilTag Processor\n    pose_estimator = Processor(walleye_data.tag_size)\n    # Publisher already created during construction of walleye_data\n    # walleye_data.make_publisher(walleye_data.team_number, walleye_data.table_name)\n    walleye_data.current_state = States.PROCESSING\n\n    logger.info(\"Starting main loop\")\n\n    last_loop_time = time.time()\n\n    # Main loop (Runs everything)\n    while True:\n        # Calculate loop time\n        curr_time = time.time()\n        walleye_data.loop_time = round(curr_time - last_loop_time, 3)\n        last_loop_time = curr_time\n\n        # State changes\n        # Pre-Calibration\n        if walleye_data.current_state == States.BEGIN_CALIBRATION:\n            logger.info(\"Beginning calibration\")\n\n            # Prepare a calibration object for the camera that is being calibrated with pre-set data\n            # only if cal object does not exist yet\n            if (\n                walleye_data.camera_in_calibration not in calibrators\n                or calibrators[walleye_data.camera_in_calibration] is None\n            ):\n                calibrators[walleye_data.camera_in_calibration] = Calibration(\n                    walleye_data.cal_delay,\n                    walleye_data.board_dims,\n                    walleye_data.camera_in_calibration,\n                    calibration_image_folder(walleye_data.camera_in_calibration),\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].resolution,\n                )\n            walleye_data.current_state = States.CALIBRATION_CAPTURE\n\n        # Take calibration images\n        elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n            # Read in frames\n            ret, img = walleye_data.cameras.info[\n                walleye_data.camera_in_calibration\n            ].cam.read()\n\n            if not ret:\n                logger.error(\n                    f\"Failed to capture image: {walleye_data.camera_in_calibration}\"\n                )\n            else:\n                # Process frames with the calibration object created prior\n                returned, used, path_saved = calibrators[\n                    walleye_data.camera_in_calibration\n                ].process_frame(img)\n\n                # If the image is a part of the accepted images save it\n                if used:\n                    walleye_data.cal_img_paths.append(path_saved)\n\n                # Keep a buffer with the images\n                cam_buffers[walleye_data.camera_in_calibration].update(returned)\n\n        # Finished Calibration, generate calibration\n        elif walleye_data.current_state == States.GENERATE_CALIBRATION:\n            # Get file path for the calibration to be saved\n            walleye_data.cameras.info[\n                walleye_data.camera_in_calibration\n            ].calibrationPath = calibration_path_by_cam(\n                walleye_data.camera_in_calibration,\n                walleye_data.cameras.info[walleye_data.camera_in_calibration].resolution,\n            )\n\n            if calibrators[walleye_data.camera_in_calibration] is not None:\n                # Generate a calibration file to the file path\n                has_generated = calibrators[\n                    walleye_data.camera_in_calibration\n                ].generate_calibration(\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].calibration_path\n                )\n\n                if has_generated:\n                    # Get reproj error\n                    walleye_data.reprojection_error = calibrators[\n                        walleye_data.camera_in_calibration\n                    ].get_reprojection_error()\n\n                    # Set the cameras calibration, save off the file path, and\n                    # go to idle\n                    walleye_data.cameras.setCalibration(\n                        walleye_data.camera_in_calibration,\n                        calibrators[walleye_data.camera_in_calibration].calibrationData[\n                            \"K\"\n                        ],\n                        calibrators[walleye_data.camera_in_calibration].calibrationData[\n                            \"dist\"\n                        ],\n                    )\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].calibrationPath = calibration_path_by_cam(\n                        walleye_data.camera_in_calibration,\n                        walleye_data.cameras.info[\n                            walleye_data.camera_in_calibration\n                        ].resolution,\n                    )\n                else:\n                    walleye_data.status = \"Could not generate calibration\"\n            else:\n                walleye_data.status = \"Calibrator for current calibration camera is None\"\n            walleye_data.current_state = States.IDLE\n            calibrators[walleye_data.camera_in_calibration] = None\n\n        # AprilTag processing state\n        elif walleye_data.current_state == States.PROCESSING:\n            # Set tag size, grab camera frames, and grab image timestamp\n            pose_estimator.set_tag_size(walleye_data.tag_size)\n\n            image_time = walleye_data.robot_publisher.get_time() \n\n            connections, images, delay = walleye_data.cameras.get_frames_for_processing()\n\n            for idx, val in enumerate(connections.values()):\n                if not val and walleye_data.robot_publisher.getConnectionValue(idx):\n                    logger.info(\"Camera disconnected\")\n\n                walleye_data.robot_publisher.setConnectionValue(idx, val)\n\n            # Use the pose_estimator class to find the pose, tags, and ambiguity\n            poses, tags, ambig = pose_estimator.get_pose(\n                images.values(),\n                walleye_data.cameras.list_k(),\n                walleye_data.cameras.list_d(),\n            )\n\n            # Publish camera number, timestamp, poses, tags, ambiguity and increase the update number\n            # logger.info(f\"Poses at {image_time}: {poses}\")\n\n            for i in range(len(poses)):\n                if poses[i][0].X() < 2000:\n                    walleye_data.robot_publisher.publish(\n                        i, image_time - delay[i], poses[i], tags[i], ambig[i]\n                    )\n\n            # Update the pose visualization\n            for i, (identifier, img) in enumerate(images.items()):\n                if i >= len(poses):\n                    break\n                cam_buffers[identifier].update(img)\n                walleye_data.set_pose(identifier, poses[i][0])\n                if walleye_data.visualizing_poses:\n                    visualization_buffers[identifier].update(\n                        (poses[i][0].X(), poses[i][0].Y(), poses[i][0].Z()), tags[i][1:]\n                    )\n\n        # Ends the WallEye program through the web interface\n        elif walleye_data.current_state == States.SHUTDOWN:\n            logger.info(\"Shutting down\")\n            logging.shutdown()\n            socketio.stop()\n            break\n\n        # Update cameras no matter what state\n        if walleye_data.current_state != States.PROCESSING:\n            for camera_info in walleye_data.cameras.info.values():\n                if (\n                    camera_info.identifier == walleye_data.camera_in_calibration\n                    and walleye_data.current_state in CALIBRATION_STATES\n                ):\n                    continue\n\n                ret, img = camera_info.cam.read()\n\n                cam_buffers[camera_info.identifier].update(img)\n\nexcept Exception as e:\n    # Something bad happened\n    logging.critical(e, exc_info=True)\n    logger.info(\"Shutting down\")\n    socketio.stop()\n    logging.shutdown()\n"]]], 1715213078.5045853]], ["ChangeSet", ["Renaming <backupCount> to <backupCount_XxX_CamelSnakePep8_PreserveName_XxX_3>", [["ChangeContents", ["init.py", "import sys\nimport logging\nfrom logging.handlers import RotatingFileHandler\nfrom directory import calibration_image_folder, calibration_path_by_cam, LOG\n\n# Create logger and set settings\nLOG_FORMAT = \"[%(asctime)s - %(levelname)s - %(filename)s:%(lineno)s - %(funcName)s()]  %(message)s\"\nlogging.basicConfig(\n    format=LOG_FORMAT,\n    handlers=[\n        logging.StreamHandler(sys.stdout),\n        RotatingFileHandler(LOG, maxBytes_XxX_CamelSnakePep8_PreserveName_XxX_2=1024 * 1024, backupCount_XxX_CamelSnakePep8_PreserveName_XxX_3=5),\n    ],\n    datefmt=\"%d-%b-%y %H:%M:%S\",\n    level=logging.INFO,\n)\n\nlogger = logging.getLogger(__name__)\n\nlogger.info(\"----------- Starting Up -----------\")\n\nfrom state import walleye_data, States, CALIBRATION_STATES\nfrom processing.processing import Processor\nimport threading\nfrom camera.camera import Cameras\nfrom calibration.calibration import Calibration, CalibType\nimport time\n\n\n# Create and intialize cameras\nwalleye_data.cameras = Cameras()\n\nfrom web_interface.web_interface import (\n    cam_buffers,\n    socketio,\n    app,\n    visualization_buffers\n)  # After walleye_data.cameras is set\n\nweb_server = threading.Thread(\n    target=lambda: socketio.run(\n        app,\n        host=\"0.0.0.0\",\n        port=5800,\n        debug=False,\n        use_reloader=False,\n        log_output=False,\n    ),\n    # daemon=True,\n)\ntry:\n    # Start the web server\n    web_server.start()\n\n    logging.getLogger(\"geventwebsocket.handler\").setLevel(logging.ERROR)\n    logging.getLogger(\"socketio\").setLevel(logging.ERROR)\n    logging.getLogger(\"socketio.server\").setLevel(logging.ERROR)\n    logging.getLogger(\"engineio\").setLevel(logging.ERROR)\n\n\n    logger.info(\"Web server ready\")\n\n    images = {}\n    calibrators = {}\n\n    # Create network tables publisher and AprilTag Processor\n    pose_estimator = Processor(walleye_data.tag_size)\n    # Publisher already created during construction of walleye_data\n    # walleye_data.make_publisher(walleye_data.team_number, walleye_data.table_name)\n    walleye_data.current_state = States.PROCESSING\n\n    logger.info(\"Starting main loop\")\n\n    last_loop_time = time.time()\n\n    # Main loop (Runs everything)\n    while True:\n        # Calculate loop time\n        curr_time = time.time()\n        walleye_data.loop_time = round(curr_time - last_loop_time, 3)\n        last_loop_time = curr_time\n\n        # State changes\n        # Pre-Calibration\n        if walleye_data.current_state == States.BEGIN_CALIBRATION:\n            logger.info(\"Beginning calibration\")\n\n            # Prepare a calibration object for the camera that is being calibrated with pre-set data\n            # only if cal object does not exist yet\n            if (\n                walleye_data.camera_in_calibration not in calibrators\n                or calibrators[walleye_data.camera_in_calibration] is None\n            ):\n                calibrators[walleye_data.camera_in_calibration] = Calibration(\n                    walleye_data.cal_delay,\n                    walleye_data.board_dims,\n                    walleye_data.camera_in_calibration,\n                    calibration_image_folder(walleye_data.camera_in_calibration),\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].resolution,\n                )\n            walleye_data.current_state = States.CALIBRATION_CAPTURE\n\n        # Take calibration images\n        elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n            # Read in frames\n            ret, img = walleye_data.cameras.info[\n                walleye_data.camera_in_calibration\n            ].cam.read()\n\n            if not ret:\n                logger.error(\n                    f\"Failed to capture image: {walleye_data.camera_in_calibration}\"\n                )\n            else:\n                # Process frames with the calibration object created prior\n                returned, used, path_saved = calibrators[\n                    walleye_data.camera_in_calibration\n                ].process_frame(img)\n\n                # If the image is a part of the accepted images save it\n                if used:\n                    walleye_data.cal_img_paths.append(path_saved)\n\n                # Keep a buffer with the images\n                cam_buffers[walleye_data.camera_in_calibration].update(returned)\n\n        # Finished Calibration, generate calibration\n        elif walleye_data.current_state == States.GENERATE_CALIBRATION:\n            # Get file path for the calibration to be saved\n            walleye_data.cameras.info[\n                walleye_data.camera_in_calibration\n            ].calibrationPath = calibration_path_by_cam(\n                walleye_data.camera_in_calibration,\n                walleye_data.cameras.info[walleye_data.camera_in_calibration].resolution,\n            )\n\n            if calibrators[walleye_data.camera_in_calibration] is not None:\n                # Generate a calibration file to the file path\n                has_generated = calibrators[\n                    walleye_data.camera_in_calibration\n                ].generate_calibration(\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].calibration_path\n                )\n\n                if has_generated:\n                    # Get reproj error\n                    walleye_data.reprojection_error = calibrators[\n                        walleye_data.camera_in_calibration\n                    ].get_reprojection_error()\n\n                    # Set the cameras calibration, save off the file path, and\n                    # go to idle\n                    walleye_data.cameras.setCalibration(\n                        walleye_data.camera_in_calibration,\n                        calibrators[walleye_data.camera_in_calibration].calibrationData[\n                            \"K\"\n                        ],\n                        calibrators[walleye_data.camera_in_calibration].calibrationData[\n                            \"dist\"\n                        ],\n                    )\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].calibrationPath = calibration_path_by_cam(\n                        walleye_data.camera_in_calibration,\n                        walleye_data.cameras.info[\n                            walleye_data.camera_in_calibration\n                        ].resolution,\n                    )\n                else:\n                    walleye_data.status = \"Could not generate calibration\"\n            else:\n                walleye_data.status = \"Calibrator for current calibration camera is None\"\n            walleye_data.current_state = States.IDLE\n            calibrators[walleye_data.camera_in_calibration] = None\n\n        # AprilTag processing state\n        elif walleye_data.current_state == States.PROCESSING:\n            # Set tag size, grab camera frames, and grab image timestamp\n            pose_estimator.set_tag_size(walleye_data.tag_size)\n\n            image_time = walleye_data.robot_publisher.get_time() \n\n            connections, images, delay = walleye_data.cameras.get_frames_for_processing()\n\n            for idx, val in enumerate(connections.values()):\n                if not val and walleye_data.robot_publisher.getConnectionValue(idx):\n                    logger.info(\"Camera disconnected\")\n\n                walleye_data.robot_publisher.setConnectionValue(idx, val)\n\n            # Use the pose_estimator class to find the pose, tags, and ambiguity\n            poses, tags, ambig = pose_estimator.get_pose(\n                images.values(),\n                walleye_data.cameras.list_k(),\n                walleye_data.cameras.list_d(),\n            )\n\n            # Publish camera number, timestamp, poses, tags, ambiguity and increase the update number\n            # logger.info(f\"Poses at {image_time}: {poses}\")\n\n            for i in range(len(poses)):\n                if poses[i][0].X() < 2000:\n                    walleye_data.robot_publisher.publish(\n                        i, image_time - delay[i], poses[i], tags[i], ambig[i]\n                    )\n\n            # Update the pose visualization\n            for i, (identifier, img) in enumerate(images.items()):\n                if i >= len(poses):\n                    break\n                cam_buffers[identifier].update(img)\n                walleye_data.set_pose(identifier, poses[i][0])\n                if walleye_data.visualizing_poses:\n                    visualization_buffers[identifier].update(\n                        (poses[i][0].X(), poses[i][0].Y(), poses[i][0].Z()), tags[i][1:]\n                    )\n\n        # Ends the WallEye program through the web interface\n        elif walleye_data.current_state == States.SHUTDOWN:\n            logger.info(\"Shutting down\")\n            logging.shutdown()\n            socketio.stop()\n            break\n\n        # Update cameras no matter what state\n        if walleye_data.current_state != States.PROCESSING:\n            for camera_info in walleye_data.cameras.info.values():\n                if (\n                    camera_info.identifier == walleye_data.camera_in_calibration\n                    and walleye_data.current_state in CALIBRATION_STATES\n                ):\n                    continue\n\n                ret, img = camera_info.cam.read()\n\n                cam_buffers[camera_info.identifier].update(img)\n\nexcept Exception as e:\n    # Something bad happened\n    logging.critical(e, exc_info=True)\n    logger.info(\"Shutting down\")\n    socketio.stop()\n    logging.shutdown()\n", "import sys\nimport logging\nfrom logging.handlers import RotatingFileHandler\nfrom directory import calibration_image_folder, calibration_path_by_cam, LOG\n\n# Create logger and set settings\nLOG_FORMAT = \"[%(asctime)s - %(levelname)s - %(filename)s:%(lineno)s - %(funcName)s()]  %(message)s\"\nlogging.basicConfig(\n    format=LOG_FORMAT,\n    handlers=[\n        logging.StreamHandler(sys.stdout),\n        RotatingFileHandler(LOG, maxBytes_XxX_CamelSnakePep8_PreserveName_XxX_2=1024 * 1024, backupCount=5),\n    ],\n    datefmt=\"%d-%b-%y %H:%M:%S\",\n    level=logging.INFO,\n)\n\nlogger = logging.getLogger(__name__)\n\nlogger.info(\"----------- Starting Up -----------\")\n\nfrom state import walleye_data, States, CALIBRATION_STATES\nfrom processing.processing import Processor\nimport threading\nfrom camera.camera import Cameras\nfrom calibration.calibration import Calibration, CalibType\nimport time\n\n\n# Create and intialize cameras\nwalleye_data.cameras = Cameras()\n\nfrom web_interface.web_interface import (\n    cam_buffers,\n    socketio,\n    app,\n    visualization_buffers\n)  # After walleye_data.cameras is set\n\nweb_server = threading.Thread(\n    target=lambda: socketio.run(\n        app,\n        host=\"0.0.0.0\",\n        port=5800,\n        debug=False,\n        use_reloader=False,\n        log_output=False,\n    ),\n    # daemon=True,\n)\ntry:\n    # Start the web server\n    web_server.start()\n\n    logging.getLogger(\"geventwebsocket.handler\").setLevel(logging.ERROR)\n    logging.getLogger(\"socketio\").setLevel(logging.ERROR)\n    logging.getLogger(\"socketio.server\").setLevel(logging.ERROR)\n    logging.getLogger(\"engineio\").setLevel(logging.ERROR)\n\n\n    logger.info(\"Web server ready\")\n\n    images = {}\n    calibrators = {}\n\n    # Create network tables publisher and AprilTag Processor\n    pose_estimator = Processor(walleye_data.tag_size)\n    # Publisher already created during construction of walleye_data\n    # walleye_data.make_publisher(walleye_data.team_number, walleye_data.table_name)\n    walleye_data.current_state = States.PROCESSING\n\n    logger.info(\"Starting main loop\")\n\n    last_loop_time = time.time()\n\n    # Main loop (Runs everything)\n    while True:\n        # Calculate loop time\n        curr_time = time.time()\n        walleye_data.loop_time = round(curr_time - last_loop_time, 3)\n        last_loop_time = curr_time\n\n        # State changes\n        # Pre-Calibration\n        if walleye_data.current_state == States.BEGIN_CALIBRATION:\n            logger.info(\"Beginning calibration\")\n\n            # Prepare a calibration object for the camera that is being calibrated with pre-set data\n            # only if cal object does not exist yet\n            if (\n                walleye_data.camera_in_calibration not in calibrators\n                or calibrators[walleye_data.camera_in_calibration] is None\n            ):\n                calibrators[walleye_data.camera_in_calibration] = Calibration(\n                    walleye_data.cal_delay,\n                    walleye_data.board_dims,\n                    walleye_data.camera_in_calibration,\n                    calibration_image_folder(walleye_data.camera_in_calibration),\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].resolution,\n                )\n            walleye_data.current_state = States.CALIBRATION_CAPTURE\n\n        # Take calibration images\n        elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n            # Read in frames\n            ret, img = walleye_data.cameras.info[\n                walleye_data.camera_in_calibration\n            ].cam.read()\n\n            if not ret:\n                logger.error(\n                    f\"Failed to capture image: {walleye_data.camera_in_calibration}\"\n                )\n            else:\n                # Process frames with the calibration object created prior\n                returned, used, path_saved = calibrators[\n                    walleye_data.camera_in_calibration\n                ].process_frame(img)\n\n                # If the image is a part of the accepted images save it\n                if used:\n                    walleye_data.cal_img_paths.append(path_saved)\n\n                # Keep a buffer with the images\n                cam_buffers[walleye_data.camera_in_calibration].update(returned)\n\n        # Finished Calibration, generate calibration\n        elif walleye_data.current_state == States.GENERATE_CALIBRATION:\n            # Get file path for the calibration to be saved\n            walleye_data.cameras.info[\n                walleye_data.camera_in_calibration\n            ].calibrationPath = calibration_path_by_cam(\n                walleye_data.camera_in_calibration,\n                walleye_data.cameras.info[walleye_data.camera_in_calibration].resolution,\n            )\n\n            if calibrators[walleye_data.camera_in_calibration] is not None:\n                # Generate a calibration file to the file path\n                has_generated = calibrators[\n                    walleye_data.camera_in_calibration\n                ].generate_calibration(\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].calibration_path\n                )\n\n                if has_generated:\n                    # Get reproj error\n                    walleye_data.reprojection_error = calibrators[\n                        walleye_data.camera_in_calibration\n                    ].get_reprojection_error()\n\n                    # Set the cameras calibration, save off the file path, and\n                    # go to idle\n                    walleye_data.cameras.setCalibration(\n                        walleye_data.camera_in_calibration,\n                        calibrators[walleye_data.camera_in_calibration].calibrationData[\n                            \"K\"\n                        ],\n                        calibrators[walleye_data.camera_in_calibration].calibrationData[\n                            \"dist\"\n                        ],\n                    )\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].calibrationPath = calibration_path_by_cam(\n                        walleye_data.camera_in_calibration,\n                        walleye_data.cameras.info[\n                            walleye_data.camera_in_calibration\n                        ].resolution,\n                    )\n                else:\n                    walleye_data.status = \"Could not generate calibration\"\n            else:\n                walleye_data.status = \"Calibrator for current calibration camera is None\"\n            walleye_data.current_state = States.IDLE\n            calibrators[walleye_data.camera_in_calibration] = None\n\n        # AprilTag processing state\n        elif walleye_data.current_state == States.PROCESSING:\n            # Set tag size, grab camera frames, and grab image timestamp\n            pose_estimator.set_tag_size(walleye_data.tag_size)\n\n            image_time = walleye_data.robot_publisher.get_time() \n\n            connections, images, delay = walleye_data.cameras.get_frames_for_processing()\n\n            for idx, val in enumerate(connections.values()):\n                if not val and walleye_data.robot_publisher.getConnectionValue(idx):\n                    logger.info(\"Camera disconnected\")\n\n                walleye_data.robot_publisher.setConnectionValue(idx, val)\n\n            # Use the pose_estimator class to find the pose, tags, and ambiguity\n            poses, tags, ambig = pose_estimator.get_pose(\n                images.values(),\n                walleye_data.cameras.list_k(),\n                walleye_data.cameras.list_d(),\n            )\n\n            # Publish camera number, timestamp, poses, tags, ambiguity and increase the update number\n            # logger.info(f\"Poses at {image_time}: {poses}\")\n\n            for i in range(len(poses)):\n                if poses[i][0].X() < 2000:\n                    walleye_data.robot_publisher.publish(\n                        i, image_time - delay[i], poses[i], tags[i], ambig[i]\n                    )\n\n            # Update the pose visualization\n            for i, (identifier, img) in enumerate(images.items()):\n                if i >= len(poses):\n                    break\n                cam_buffers[identifier].update(img)\n                walleye_data.set_pose(identifier, poses[i][0])\n                if walleye_data.visualizing_poses:\n                    visualization_buffers[identifier].update(\n                        (poses[i][0].X(), poses[i][0].Y(), poses[i][0].Z()), tags[i][1:]\n                    )\n\n        # Ends the WallEye program through the web interface\n        elif walleye_data.current_state == States.SHUTDOWN:\n            logger.info(\"Shutting down\")\n            logging.shutdown()\n            socketio.stop()\n            break\n\n        # Update cameras no matter what state\n        if walleye_data.current_state != States.PROCESSING:\n            for camera_info in walleye_data.cameras.info.values():\n                if (\n                    camera_info.identifier == walleye_data.camera_in_calibration\n                    and walleye_data.current_state in CALIBRATION_STATES\n                ):\n                    continue\n\n                ret, img = camera_info.cam.read()\n\n                cam_buffers[camera_info.identifier].update(img)\n\nexcept Exception as e:\n    # Something bad happened\n    logging.critical(e, exc_info=True)\n    logger.info(\"Shutting down\")\n    socketio.stop()\n    logging.shutdown()\n"]]], 1715213080.456461]], ["ChangeSet", ["Renaming <CalibType> to <CalibType_XxX_CamelSnakePep8_PreserveName_XxX_4>", [["ChangeContents", ["init.py", "import sys\nimport logging\nfrom logging.handlers import RotatingFileHandler\nfrom directory import calibration_image_folder, calibration_path_by_cam, LOG\n\n# Create logger and set settings\nLOG_FORMAT = \"[%(asctime)s - %(levelname)s - %(filename)s:%(lineno)s - %(funcName)s()]  %(message)s\"\nlogging.basicConfig(\n    format=LOG_FORMAT,\n    handlers=[\n        logging.StreamHandler(sys.stdout),\n        RotatingFileHandler(LOG, maxBytes_XxX_CamelSnakePep8_PreserveName_XxX_2=1024 * 1024, backupCount_XxX_CamelSnakePep8_PreserveName_XxX_3=5),\n    ],\n    datefmt=\"%d-%b-%y %H:%M:%S\",\n    level=logging.INFO,\n)\n\nlogger = logging.getLogger(__name__)\n\nlogger.info(\"----------- Starting Up -----------\")\n\nfrom state import walleye_data, States, CALIBRATION_STATES\nfrom processing.processing import Processor\nimport threading\nfrom camera.camera import Cameras\nfrom calibration.calibration import Calibration, CalibType_XxX_CamelSnakePep8_PreserveName_XxX_4\nimport time\n\n\n# Create and intialize cameras\nwalleye_data.cameras = Cameras()\n\nfrom web_interface.web_interface import (\n    cam_buffers,\n    socketio,\n    app,\n    visualization_buffers\n)  # After walleye_data.cameras is set\n\nweb_server = threading.Thread(\n    target=lambda: socketio.run(\n        app,\n        host=\"0.0.0.0\",\n        port=5800,\n        debug=False,\n        use_reloader=False,\n        log_output=False,\n    ),\n    # daemon=True,\n)\ntry:\n    # Start the web server\n    web_server.start()\n\n    logging.getLogger(\"geventwebsocket.handler\").setLevel(logging.ERROR)\n    logging.getLogger(\"socketio\").setLevel(logging.ERROR)\n    logging.getLogger(\"socketio.server\").setLevel(logging.ERROR)\n    logging.getLogger(\"engineio\").setLevel(logging.ERROR)\n\n\n    logger.info(\"Web server ready\")\n\n    images = {}\n    calibrators = {}\n\n    # Create network tables publisher and AprilTag Processor\n    pose_estimator = Processor(walleye_data.tag_size)\n    # Publisher already created during construction of walleye_data\n    # walleye_data.make_publisher(walleye_data.team_number, walleye_data.table_name)\n    walleye_data.current_state = States.PROCESSING\n\n    logger.info(\"Starting main loop\")\n\n    last_loop_time = time.time()\n\n    # Main loop (Runs everything)\n    while True:\n        # Calculate loop time\n        curr_time = time.time()\n        walleye_data.loop_time = round(curr_time - last_loop_time, 3)\n        last_loop_time = curr_time\n\n        # State changes\n        # Pre-Calibration\n        if walleye_data.current_state == States.BEGIN_CALIBRATION:\n            logger.info(\"Beginning calibration\")\n\n            # Prepare a calibration object for the camera that is being calibrated with pre-set data\n            # only if cal object does not exist yet\n            if (\n                walleye_data.camera_in_calibration not in calibrators\n                or calibrators[walleye_data.camera_in_calibration] is None\n            ):\n                calibrators[walleye_data.camera_in_calibration] = Calibration(\n                    walleye_data.cal_delay,\n                    walleye_data.board_dims,\n                    walleye_data.camera_in_calibration,\n                    calibration_image_folder(walleye_data.camera_in_calibration),\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].resolution,\n                )\n            walleye_data.current_state = States.CALIBRATION_CAPTURE\n\n        # Take calibration images\n        elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n            # Read in frames\n            ret, img = walleye_data.cameras.info[\n                walleye_data.camera_in_calibration\n            ].cam.read()\n\n            if not ret:\n                logger.error(\n                    f\"Failed to capture image: {walleye_data.camera_in_calibration}\"\n                )\n            else:\n                # Process frames with the calibration object created prior\n                returned, used, path_saved = calibrators[\n                    walleye_data.camera_in_calibration\n                ].process_frame(img)\n\n                # If the image is a part of the accepted images save it\n                if used:\n                    walleye_data.cal_img_paths.append(path_saved)\n\n                # Keep a buffer with the images\n                cam_buffers[walleye_data.camera_in_calibration].update(returned)\n\n        # Finished Calibration, generate calibration\n        elif walleye_data.current_state == States.GENERATE_CALIBRATION:\n            # Get file path for the calibration to be saved\n            walleye_data.cameras.info[\n                walleye_data.camera_in_calibration\n            ].calibrationPath = calibration_path_by_cam(\n                walleye_data.camera_in_calibration,\n                walleye_data.cameras.info[walleye_data.camera_in_calibration].resolution,\n            )\n\n            if calibrators[walleye_data.camera_in_calibration] is not None:\n                # Generate a calibration file to the file path\n                has_generated = calibrators[\n                    walleye_data.camera_in_calibration\n                ].generate_calibration(\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].calibration_path\n                )\n\n                if has_generated:\n                    # Get reproj error\n                    walleye_data.reprojection_error = calibrators[\n                        walleye_data.camera_in_calibration\n                    ].get_reprojection_error()\n\n                    # Set the cameras calibration, save off the file path, and\n                    # go to idle\n                    walleye_data.cameras.setCalibration(\n                        walleye_data.camera_in_calibration,\n                        calibrators[walleye_data.camera_in_calibration].calibrationData[\n                            \"K\"\n                        ],\n                        calibrators[walleye_data.camera_in_calibration].calibrationData[\n                            \"dist\"\n                        ],\n                    )\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].calibrationPath = calibration_path_by_cam(\n                        walleye_data.camera_in_calibration,\n                        walleye_data.cameras.info[\n                            walleye_data.camera_in_calibration\n                        ].resolution,\n                    )\n                else:\n                    walleye_data.status = \"Could not generate calibration\"\n            else:\n                walleye_data.status = \"Calibrator for current calibration camera is None\"\n            walleye_data.current_state = States.IDLE\n            calibrators[walleye_data.camera_in_calibration] = None\n\n        # AprilTag processing state\n        elif walleye_data.current_state == States.PROCESSING:\n            # Set tag size, grab camera frames, and grab image timestamp\n            pose_estimator.set_tag_size(walleye_data.tag_size)\n\n            image_time = walleye_data.robot_publisher.get_time() \n\n            connections, images, delay = walleye_data.cameras.get_frames_for_processing()\n\n            for idx, val in enumerate(connections.values()):\n                if not val and walleye_data.robot_publisher.getConnectionValue(idx):\n                    logger.info(\"Camera disconnected\")\n\n                walleye_data.robot_publisher.setConnectionValue(idx, val)\n\n            # Use the pose_estimator class to find the pose, tags, and ambiguity\n            poses, tags, ambig = pose_estimator.get_pose(\n                images.values(),\n                walleye_data.cameras.list_k(),\n                walleye_data.cameras.list_d(),\n            )\n\n            # Publish camera number, timestamp, poses, tags, ambiguity and increase the update number\n            # logger.info(f\"Poses at {image_time}: {poses}\")\n\n            for i in range(len(poses)):\n                if poses[i][0].X() < 2000:\n                    walleye_data.robot_publisher.publish(\n                        i, image_time - delay[i], poses[i], tags[i], ambig[i]\n                    )\n\n            # Update the pose visualization\n            for i, (identifier, img) in enumerate(images.items()):\n                if i >= len(poses):\n                    break\n                cam_buffers[identifier].update(img)\n                walleye_data.set_pose(identifier, poses[i][0])\n                if walleye_data.visualizing_poses:\n                    visualization_buffers[identifier].update(\n                        (poses[i][0].X(), poses[i][0].Y(), poses[i][0].Z()), tags[i][1:]\n                    )\n\n        # Ends the WallEye program through the web interface\n        elif walleye_data.current_state == States.SHUTDOWN:\n            logger.info(\"Shutting down\")\n            logging.shutdown()\n            socketio.stop()\n            break\n\n        # Update cameras no matter what state\n        if walleye_data.current_state != States.PROCESSING:\n            for camera_info in walleye_data.cameras.info.values():\n                if (\n                    camera_info.identifier == walleye_data.camera_in_calibration\n                    and walleye_data.current_state in CALIBRATION_STATES\n                ):\n                    continue\n\n                ret, img = camera_info.cam.read()\n\n                cam_buffers[camera_info.identifier].update(img)\n\nexcept Exception as e:\n    # Something bad happened\n    logging.critical(e, exc_info=True)\n    logger.info(\"Shutting down\")\n    socketio.stop()\n    logging.shutdown()\n", "import sys\nimport logging\nfrom logging.handlers import RotatingFileHandler\nfrom directory import calibration_image_folder, calibration_path_by_cam, LOG\n\n# Create logger and set settings\nLOG_FORMAT = \"[%(asctime)s - %(levelname)s - %(filename)s:%(lineno)s - %(funcName)s()]  %(message)s\"\nlogging.basicConfig(\n    format=LOG_FORMAT,\n    handlers=[\n        logging.StreamHandler(sys.stdout),\n        RotatingFileHandler(LOG, maxBytes_XxX_CamelSnakePep8_PreserveName_XxX_2=1024 * 1024, backupCount_XxX_CamelSnakePep8_PreserveName_XxX_3=5),\n    ],\n    datefmt=\"%d-%b-%y %H:%M:%S\",\n    level=logging.INFO,\n)\n\nlogger = logging.getLogger(__name__)\n\nlogger.info(\"----------- Starting Up -----------\")\n\nfrom state import walleye_data, States, CALIBRATION_STATES\nfrom processing.processing import Processor\nimport threading\nfrom camera.camera import Cameras\nfrom calibration.calibration import Calibration, CalibType\nimport time\n\n\n# Create and intialize cameras\nwalleye_data.cameras = Cameras()\n\nfrom web_interface.web_interface import (\n    cam_buffers,\n    socketio,\n    app,\n    visualization_buffers\n)  # After walleye_data.cameras is set\n\nweb_server = threading.Thread(\n    target=lambda: socketio.run(\n        app,\n        host=\"0.0.0.0\",\n        port=5800,\n        debug=False,\n        use_reloader=False,\n        log_output=False,\n    ),\n    # daemon=True,\n)\ntry:\n    # Start the web server\n    web_server.start()\n\n    logging.getLogger(\"geventwebsocket.handler\").setLevel(logging.ERROR)\n    logging.getLogger(\"socketio\").setLevel(logging.ERROR)\n    logging.getLogger(\"socketio.server\").setLevel(logging.ERROR)\n    logging.getLogger(\"engineio\").setLevel(logging.ERROR)\n\n\n    logger.info(\"Web server ready\")\n\n    images = {}\n    calibrators = {}\n\n    # Create network tables publisher and AprilTag Processor\n    pose_estimator = Processor(walleye_data.tag_size)\n    # Publisher already created during construction of walleye_data\n    # walleye_data.make_publisher(walleye_data.team_number, walleye_data.table_name)\n    walleye_data.current_state = States.PROCESSING\n\n    logger.info(\"Starting main loop\")\n\n    last_loop_time = time.time()\n\n    # Main loop (Runs everything)\n    while True:\n        # Calculate loop time\n        curr_time = time.time()\n        walleye_data.loop_time = round(curr_time - last_loop_time, 3)\n        last_loop_time = curr_time\n\n        # State changes\n        # Pre-Calibration\n        if walleye_data.current_state == States.BEGIN_CALIBRATION:\n            logger.info(\"Beginning calibration\")\n\n            # Prepare a calibration object for the camera that is being calibrated with pre-set data\n            # only if cal object does not exist yet\n            if (\n                walleye_data.camera_in_calibration not in calibrators\n                or calibrators[walleye_data.camera_in_calibration] is None\n            ):\n                calibrators[walleye_data.camera_in_calibration] = Calibration(\n                    walleye_data.cal_delay,\n                    walleye_data.board_dims,\n                    walleye_data.camera_in_calibration,\n                    calibration_image_folder(walleye_data.camera_in_calibration),\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].resolution,\n                )\n            walleye_data.current_state = States.CALIBRATION_CAPTURE\n\n        # Take calibration images\n        elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n            # Read in frames\n            ret, img = walleye_data.cameras.info[\n                walleye_data.camera_in_calibration\n            ].cam.read()\n\n            if not ret:\n                logger.error(\n                    f\"Failed to capture image: {walleye_data.camera_in_calibration}\"\n                )\n            else:\n                # Process frames with the calibration object created prior\n                returned, used, path_saved = calibrators[\n                    walleye_data.camera_in_calibration\n                ].process_frame(img)\n\n                # If the image is a part of the accepted images save it\n                if used:\n                    walleye_data.cal_img_paths.append(path_saved)\n\n                # Keep a buffer with the images\n                cam_buffers[walleye_data.camera_in_calibration].update(returned)\n\n        # Finished Calibration, generate calibration\n        elif walleye_data.current_state == States.GENERATE_CALIBRATION:\n            # Get file path for the calibration to be saved\n            walleye_data.cameras.info[\n                walleye_data.camera_in_calibration\n            ].calibrationPath = calibration_path_by_cam(\n                walleye_data.camera_in_calibration,\n                walleye_data.cameras.info[walleye_data.camera_in_calibration].resolution,\n            )\n\n            if calibrators[walleye_data.camera_in_calibration] is not None:\n                # Generate a calibration file to the file path\n                has_generated = calibrators[\n                    walleye_data.camera_in_calibration\n                ].generate_calibration(\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].calibration_path\n                )\n\n                if has_generated:\n                    # Get reproj error\n                    walleye_data.reprojection_error = calibrators[\n                        walleye_data.camera_in_calibration\n                    ].get_reprojection_error()\n\n                    # Set the cameras calibration, save off the file path, and\n                    # go to idle\n                    walleye_data.cameras.setCalibration(\n                        walleye_data.camera_in_calibration,\n                        calibrators[walleye_data.camera_in_calibration].calibrationData[\n                            \"K\"\n                        ],\n                        calibrators[walleye_data.camera_in_calibration].calibrationData[\n                            \"dist\"\n                        ],\n                    )\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].calibrationPath = calibration_path_by_cam(\n                        walleye_data.camera_in_calibration,\n                        walleye_data.cameras.info[\n                            walleye_data.camera_in_calibration\n                        ].resolution,\n                    )\n                else:\n                    walleye_data.status = \"Could not generate calibration\"\n            else:\n                walleye_data.status = \"Calibrator for current calibration camera is None\"\n            walleye_data.current_state = States.IDLE\n            calibrators[walleye_data.camera_in_calibration] = None\n\n        # AprilTag processing state\n        elif walleye_data.current_state == States.PROCESSING:\n            # Set tag size, grab camera frames, and grab image timestamp\n            pose_estimator.set_tag_size(walleye_data.tag_size)\n\n            image_time = walleye_data.robot_publisher.get_time() \n\n            connections, images, delay = walleye_data.cameras.get_frames_for_processing()\n\n            for idx, val in enumerate(connections.values()):\n                if not val and walleye_data.robot_publisher.getConnectionValue(idx):\n                    logger.info(\"Camera disconnected\")\n\n                walleye_data.robot_publisher.setConnectionValue(idx, val)\n\n            # Use the pose_estimator class to find the pose, tags, and ambiguity\n            poses, tags, ambig = pose_estimator.get_pose(\n                images.values(),\n                walleye_data.cameras.list_k(),\n                walleye_data.cameras.list_d(),\n            )\n\n            # Publish camera number, timestamp, poses, tags, ambiguity and increase the update number\n            # logger.info(f\"Poses at {image_time}: {poses}\")\n\n            for i in range(len(poses)):\n                if poses[i][0].X() < 2000:\n                    walleye_data.robot_publisher.publish(\n                        i, image_time - delay[i], poses[i], tags[i], ambig[i]\n                    )\n\n            # Update the pose visualization\n            for i, (identifier, img) in enumerate(images.items()):\n                if i >= len(poses):\n                    break\n                cam_buffers[identifier].update(img)\n                walleye_data.set_pose(identifier, poses[i][0])\n                if walleye_data.visualizing_poses:\n                    visualization_buffers[identifier].update(\n                        (poses[i][0].X(), poses[i][0].Y(), poses[i][0].Z()), tags[i][1:]\n                    )\n\n        # Ends the WallEye program through the web interface\n        elif walleye_data.current_state == States.SHUTDOWN:\n            logger.info(\"Shutting down\")\n            logging.shutdown()\n            socketio.stop()\n            break\n\n        # Update cameras no matter what state\n        if walleye_data.current_state != States.PROCESSING:\n            for camera_info in walleye_data.cameras.info.values():\n                if (\n                    camera_info.identifier == walleye_data.camera_in_calibration\n                    and walleye_data.current_state in CALIBRATION_STATES\n                ):\n                    continue\n\n                ret, img = camera_info.cam.read()\n\n                cam_buffers[camera_info.identifier].update(img)\n\nexcept Exception as e:\n    # Something bad happened\n    logging.critical(e, exc_info=True)\n    logger.info(\"Shutting down\")\n    socketio.stop()\n    logging.shutdown()\n"]], ["ChangeContents", ["calibration/calibration.py", "import cv2\nimport time\nimport numpy as np\nimport json\nimport os\nimport shutil\nimport logging\nfrom enum import Enum\nfrom pathlib import Path\n\n\nclass CalibType_XxX_CamelSnakePep8_PreserveName_XxX_4(Enum):\n    CHESSBOARD = \"CHESSBOARD\"\n    CIRCLE_GRID = \"CIRCLE_GRID\"\n\n\nclass Calibration:\n    logger = logging.getLogger(__name__)\n\n    # Create a calibration object for the specified camera\n    def __init__(\n        self,\n        delay: float,\n        corner_shape: tuple[int, int],\n        cam_path: str,\n        img_path: str,\n        resolution: tuple,\n        calibType: CalibType_XxX_CamelSnakePep8_PreserveName_XxX_4 = CalibType_XxX_CamelSnakePep8_PreserveName_XxX_4.CHESSBOARD,\n    ):\n        self.delay = delay\n        self.corner_shape = corner_shape  # (col, row) format\n        self.img_path = img_path\n        self.cam_path = cam_path\n        self.resolution = resolution\n        self.calib_type = calibType\n\n        # Create a list for the corner locations for the calibration tag\n        self.reference = np.zeros((corner_shape[0] * corner_shape[1], 3), np.float32)\n        if self.calib_type == CalibType_XxX_CamelSnakePep8_PreserveName_XxX_4.CHESSBOARD:\n            self.reference[:, :2] = np.mgrid[\n                0 : corner_shape[0], 0 : corner_shape[1]\n            ].T.reshape(-1, 2)\n        elif self.calib_type == CalibType_XxX_CamelSnakePep8_PreserveName_XxX_4.CIRCLE_GRID:\n            # criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)\n\n            blob_params = cv2.SimpleBlobDetector_Params()\n\n            # Change thresholds TODO adjust as necessary\n            # blobParams.minThreshold = 8\n            # blobParams.maxThreshold = 255\n\n            # # Filter by Area.\n            # blobParams.filterByArea = True\n            # blobParams.minArea = 64\n            # blobParams.maxArea = 2500\n\n            # # Filter by Circularity\n            # blobParams.filterByCircularity = True\n            # blobParams.minCircularity = 0.1\n\n            # # Filter by Convexity\n            # blobParams.filterByConvexity = True\n            # blobParams.minConvexity = 0.87\n\n            # # Filter by Inertia\n            # blobParams.filterByInertia = True\n            # blobParams.minInertiaRatio = 0.01\n\n            self.blob_detector = cv2.SimpleBlobDetector_create(blob_params)\n\n            for i in range(corner_shape[1]):\n                self.reference[i * corner_shape[0] : (i + 1) * corner_shape[0]][:, 0] = i\n                self.reference[i * corner_shape[0] : (i + 1) * corner_shape[0]][:, 1] = (\n                    np.arange(0, corner_shape[0]) * 2 + i % 2\n                )\n\n        # Set values\n        self.obj_points = []\n        self.img_points = []\n        self.last_image_used = 0\n        self.ready_counts = 0\n\n        self.last_image_stable = False\n        self.last_image_sharp = False\n\n        self.prev_corner1 = np.zeros(2)\n        self.prev_corner2 = np.zeros(2)\n\n        self.prev_used_corner1 = np.zeros(2)\n        self.prev_used_corner2 = np.zeros(2)\n\n        self.overlay = np.zeros((resolution[1], resolution[0], 3), np.uint8)\n\n        if os.path.isdir(self.img_path):\n            shutil.rmtree(self.img_path)\n        os.mkdir(self.img_path)\n\n    # Take a frame and process it for calibration\n    def process_frame(\n        self,\n        img,\n        refinementWindow: tuple[int, int] = (5, 5),\n        refinementCriteria: tuple[float, int, float] = (\n            cv2.TERM_CRITERIA_EPS + cv2.TermCriteria_COUNT,\n            40,\n            0.001,\n        ),\n    ):\n        # Convert it to gray and look for calibration board corners\n        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n        self.img_shape = gray.shape[::-1]\n\n        if self.calib_type == CalibType_XxX_CamelSnakePep8_PreserveName_XxX_4.CHESSBOARD:\n            found, corners = cv2.findChessboardCorners(\n                gray,\n                self.corner_shape,\n                cv2.CALIB_CB_ADAPTIVE_THRESH\n                + cv2.CALIB_CB_NORMALIZE_IMAGE\n                + cv2.CALIB_CB_FAST_CHECK,\n            )\n\n        elif self.calib_type == CalibType_XxX_CamelSnakePep8_PreserveName_XxX_4.CIRCLE_GRID:  # TODO test\n            keypoints = self.blob_detector.detect(gray)\n            img_keypoints = cv2.drawKeypoints(\n                img,\n                keypoints,\n                np.array([]),\n                (0, 255, 0),\n                cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS,\n            )\n            found, corners = cv2.findCirclesGrid(\n                img_keypoints, self.corner_shape, None, flags=cv2.CALIB_CB_ASYMMETRIC_GRID\n            )\n\n        used = False\n        path_saved = None\n\n        # If there is a board and it has been long enough\n        if (\n            found\n            and time.time() - self.last_image_used > self.delay\n            and self.is_ready(gray, corners)\n        ):\n            used = True\n            self.update_overlay(corners)\n            self.last_image_used = time.time()\n            self.prev_used_corner1 = corners[0][0]\n            self.prev_used_corner2 = corners[-1][-1]\n\n            # Refine corner locations (Better calibrations)\n            refined = cv2.cornerSubPix(\n                gray, corners, refinementWindow, (-1, -1), refinementCriteria\n            )\n\n            # Set 3d locations and 2d location for image\n            self.obj_points.append(self.reference)\n            self.img_points.append(refined)\n\n            # Save off time and image\n            curr_time = time.time_ns()\n            path_saved = os.path.join(self.img_path, f\"{curr_time}.png\")\n\n            cv2.imwrite(path_saved, gray)\n\n            Calibration.logger.info(f\"Calibration image saved to {path_saved}\")\n\n        self.draw_overlay(img)\n\n        # Draw lines for the calibration board\n        cv2.drawChessboardCorners(img, self.corner_shape, corners, found)\n\n        if found:\n            # cv2.putText(\n            #     img,\n            #     \"Sharp\" if self.lastImageSharp else \"Blurry\",\n            #     (0, img.shape[0] - 10),\n            #     cv2.FONT_HERSHEY_SIMPLEX,\n            #     1,\n            #     (255, 0, 0) if self.lastImageSharp else (0, 0, 255),\n            #     2,\n            # )\n            # Text for calibrating the camera\n            cv2.putText(\n                img,\n                \"Stable\" if self.last_image_stable else \"Not stable\",\n                (0, img.shape[0] - 50),\n                cv2.FONT_HERSHEY_SIMPLEX,\n                1,\n                (255, 0, 0) if self.last_image_stable else (0, 0, 255),\n                2,\n            )\n\n        # Keep track of the amount of images taken on the image\n        cv2.putText(\n            img,\n            f\"Imgs taken: {len(self.img_points)}\",\n            (0, img.shape[0] - 100),\n            cv2.FONT_HERSHEY_SIMPLEX,\n            1,\n            (255, 0, 0) if used else (0, 0, 255),\n            2,\n        )\n\n        return (img, used, path_saved)\n\n    def update_overlay(self, corners):\n        cv2.fillPoly(\n            self.overlay,\n            [\n                np.asarray(\n                    [\n                        corners[0][0],\n                        corners[self.corner_shape[0] - 1][0],\n                        corners[-1][0],\n                        corners[-(self.corner_shape[0])][0],\n                    ],\n                    \"int32\",\n                )\n            ],\n            (\n                np.random.randint(0, 255),\n                np.random.randint(0, 255),\n                np.random.randint(0, 255),\n            ),\n        )\n\n    def draw_overlay(self, img, alpha=0.5):\n        mask = self.overlay.astype(bool)\n        img[mask] = cv2.addWeighted(img, alpha, self.overlay, 1 - alpha, 0)[mask]\n\n    # Return all saved calibration images\n    def load_saved_images(\n        self,\n        imgs: list[str],\n        refinementWindow: tuple[int, int] = (5, 5),\n        refinementCriteria: tuple[float, int, float] = (\n            cv2.TERM_CRITERIA_EPS + cv2.TermCriteria_COUNT,\n            40,\n            0.001,\n        ),\n    ):\n        # Go through each image, grayscale it, find corner loc, refine, and\n        # save off 2d and 3d locations\n        for img in imgs:\n            saved = cv2.imread(img)\n            gray = cv2.cvtColor(saved, cv2.COLOR_BGR2GRAY)\n            self.img_shape = gray.shape[::-1]\n            found, corners = cv2.findChessboardCorners(\n                gray,\n                self.corner_shape,\n                cv2.CALIB_CB_ADAPTIVE_THRESH\n                + cv2.CALIB_CB_NORMALIZE_IMAGE\n                + cv2.CALIB_CB_FAST_CHECK,\n            )\n\n            if found:\n                refined = cv2.cornerSubPix(\n                    gray,\n                    corners,\n                    refinementWindow,\n                    (-1, -1),\n                    refinementCriteria,\n                )\n\n                self.obj_points.append(self.reference)\n                self.img_points.append(refined)\n\n    # Generate a calibration and write to a file\n    def generate_calibration(self, cal_file: str):\n        if len(self.obj_points) == 0:\n            Calibration.logger.error(\"Calibration failed: No image data available\")\n            return False\n\n        # Using the saved off 2d and 3d points, it will return a camera matrix\n        # and distortion coeff\n        ret, cam_mtx, distortion, rot, trans = cv2.calibrateCamera(\n            self.obj_points,\n            self.img_points,\n            self.img_shape,\n            None,\n            None,\n            # flags=cv2.CALIB_RATIONAL_MODEL\n            # + cv2.CALIB_THIN_PRISM_MODEL\n            # + cv2.CALIB_TILTED_MODEL,\n        )\n\n        # Write to a dictionary\n        self.calibration_data = {\n            \"K\": cam_mtx,\n            \"dist\": distortion,\n            \"r\": rot,\n            \"t\": trans,\n            \"resolution\": self.resolution,\n        }\n\n        # Get calibration error and set it\n        reproj_error = self.get_reprojection_error()\n\n        self.calibration_data[\"reprojError\"] = reproj_error\n\n        Path(os.path.join(\"config_data\", \"calibrations\")).mkdir(\n            parents=True, exist_ok=True\n        )\n\n        # Write to a calibration file\n        with open(cal_file, \"w\") as f:\n            json.dump(\n                {\n                    \"camPath\": self.cam_path,\n                    \"K\": cam_mtx.tolist(),\n                    \"dist\": distortion.tolist(),\n                    \"r\": np.asarray(rot).tolist(),\n                    \"t\": np.asarray(trans).tolist(),\n                    \"reproj\": reproj_error,\n                    \"resolution\": self.resolution,\n                },\n                f,\n            )\n\n        Calibration.logger.info(\n            f\"Calibration successfully generated and saved to {cal_file} with resolution {self.resolution}\"\n        )\n\n        return ret\n\n    # Check if the current image has a stable board\n    def is_stable(self, corners: np.ndarray):\n        corner1 = corners[0][0]\n        corner2 = corners[-1][0]\n\n        dt = time.time() - self.last_image_used\n\n        speed1 = np.linalg.norm(corner1 - self.prev_corner1) / dt\n        speed2 = np.linalg.norm(corner2 - self.prev_corner2) / dt\n\n        self.prev_corner1 = corner1\n        self.prev_corner2 = corner2\n\n        threshold = self.resolution[0] / 200\n\n        self.last_image_stable = speed1 < threshold and speed2 < threshold\n\n        return self.last_image_stable\n\n    # Not currently used\n    # def isSharp(self, img: np.ndarray, threshold: float = 10, cutoff: float = 80):\n    #     (h, w) = img.shape\n\n    #     fft = np.fft.fft2(img)\n    #     fftShift = np.fft.fftshift(fft)\n\n    #     fftShift[\n    #         h // 2 - cutoff : h // 2 + cutoff, w // 2 - cutoff : w // 2 + cutoff\n    #     ] = 0\n\n    #     fftShift = np.fft.ifftshift(fftShift)\n    #     recon = np.fft.ifft2(fftShift)\n\n    #     self.lastImageSharp = threshold < np.mean(20 * np.log(np.abs(recon)))\n\n    #     return self.lastImageSharp\n\n    # Check if the current image can be use for calibration\n    def is_ready(\n        self, img: np.ndarray, corners: np.ndarray, requiredReadyCounts: int = 6\n    ) -> bool:\n        threshold = self.resolution[0] / 50\n        if (\n            np.linalg.norm(self.prev_used_corner1 - corners[0][0]) > threshold\n            and np.linalg.norm(self.prev_used_corner2 - corners[-1][-1]) > threshold\n            and self.is_stable(corners)\n        ):  # Not checking isSharp\n            self.ready_counts += 1\n        else:\n            self.ready_counts = 0\n\n        return requiredReadyCounts <= self.ready_counts\n\n    # calculate error of the calibration\n    def get_reprojection_error(self) -> float:\n        if len(self.obj_points) == 0:\n            Calibration.logger.error(\"Cannot compute reprojection error: No image data\")\n            return\n\n        total_error = 0\n\n        for i in range(len(self.obj_points)):\n            imgpoints2, _ = cv2.projectPoints(\n                self.obj_points[i],\n                self.calibration_data[\"r\"][i],\n                self.calibration_data[\"t\"][i],\n                self.calibration_data[\"K\"],\n                self.calibration_data[\"dist\"],\n            )\n            error = cv2.norm(self.img_points[i], imgpoints2, cv2.NORM_L2) / len(\n                imgpoints2\n            )\n            total_error += error\n\n        return total_error / len(self.obj_points)\n\n    # Load a calibration file\n    def load_calibration(self, file: str):\n        with open(file, \"r\") as f:\n            self.calibration_data = json.load(f)\n\n        self.calibration_data[\"K\"] = np.asarray(self.calibration_data[\"K\"])\n        self.calibration_data[\"dist\"] = np.asarray(self.calibration_data[\"dist\"])\n        self.calibration_data[\"r\"] = np.asarray(self.calibration_data[\"r\"])\n        self.calibration_data[\"t\"] = np.asarray(self.calibration_data[\"t\"])\n\n        Calibration.logger.info(f\"Calibration loaded from {file}\")\n\n    # Get calibration data from a calibration file\n    @staticmethod\n    def parse_calibration(file: str):\n        Calibration.logger.info(f\"Looking for calibration stored at {file}\")\n\n        with open(file, \"r\") as f:\n            calibration_data = json.load(f)\n\n        try:\n            calibration_data[\"K\"] = np.array(calibration_data[\"K\"])\n            calibration_data[\"dist\"] = np.array(calibration_data[\"dist\"])\n            calibration_data[\"r\"] = np.array(calibration_data[\"r\"])\n            calibration_data[\"t\"] = np.array(calibration_data[\"t\"])\n        except BaseException:\n            Calibration.logger.error(f\"Invalid calibration format in {file}\")\n\n        return calibration_data\n", "import cv2\nimport time\nimport numpy as np\nimport json\nimport os\nimport shutil\nimport logging\nfrom enum import Enum\nfrom pathlib import Path\n\n\nclass CalibType(Enum):\n    CHESSBOARD = \"CHESSBOARD\"\n    CIRCLE_GRID = \"CIRCLE_GRID\"\n\n\nclass Calibration:\n    logger = logging.getLogger(__name__)\n\n    # Create a calibration object for the specified camera\n    def __init__(\n        self,\n        delay: float,\n        corner_shape: tuple[int, int],\n        cam_path: str,\n        img_path: str,\n        resolution: tuple,\n        calibType: CalibType = CalibType.CHESSBOARD,\n    ):\n        self.delay = delay\n        self.corner_shape = corner_shape  # (col, row) format\n        self.img_path = img_path\n        self.cam_path = cam_path\n        self.resolution = resolution\n        self.calib_type = calibType\n\n        # Create a list for the corner locations for the calibration tag\n        self.reference = np.zeros((corner_shape[0] * corner_shape[1], 3), np.float32)\n        if self.calib_type == CalibType.CHESSBOARD:\n            self.reference[:, :2] = np.mgrid[\n                0 : corner_shape[0], 0 : corner_shape[1]\n            ].T.reshape(-1, 2)\n        elif self.calib_type == CalibType.CIRCLE_GRID:\n            # criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)\n\n            blob_params = cv2.SimpleBlobDetector_Params()\n\n            # Change thresholds TODO adjust as necessary\n            # blobParams.minThreshold = 8\n            # blobParams.maxThreshold = 255\n\n            # # Filter by Area.\n            # blobParams.filterByArea = True\n            # blobParams.minArea = 64\n            # blobParams.maxArea = 2500\n\n            # # Filter by Circularity\n            # blobParams.filterByCircularity = True\n            # blobParams.minCircularity = 0.1\n\n            # # Filter by Convexity\n            # blobParams.filterByConvexity = True\n            # blobParams.minConvexity = 0.87\n\n            # # Filter by Inertia\n            # blobParams.filterByInertia = True\n            # blobParams.minInertiaRatio = 0.01\n\n            self.blob_detector = cv2.SimpleBlobDetector_create(blob_params)\n\n            for i in range(corner_shape[1]):\n                self.reference[i * corner_shape[0] : (i + 1) * corner_shape[0]][:, 0] = i\n                self.reference[i * corner_shape[0] : (i + 1) * corner_shape[0]][:, 1] = (\n                    np.arange(0, corner_shape[0]) * 2 + i % 2\n                )\n\n        # Set values\n        self.obj_points = []\n        self.img_points = []\n        self.last_image_used = 0\n        self.ready_counts = 0\n\n        self.last_image_stable = False\n        self.last_image_sharp = False\n\n        self.prev_corner1 = np.zeros(2)\n        self.prev_corner2 = np.zeros(2)\n\n        self.prev_used_corner1 = np.zeros(2)\n        self.prev_used_corner2 = np.zeros(2)\n\n        self.overlay = np.zeros((resolution[1], resolution[0], 3), np.uint8)\n\n        if os.path.isdir(self.img_path):\n            shutil.rmtree(self.img_path)\n        os.mkdir(self.img_path)\n\n    # Take a frame and process it for calibration\n    def process_frame(\n        self,\n        img,\n        refinementWindow: tuple[int, int] = (5, 5),\n        refinementCriteria: tuple[float, int, float] = (\n            cv2.TERM_CRITERIA_EPS + cv2.TermCriteria_COUNT,\n            40,\n            0.001,\n        ),\n    ):\n        # Convert it to gray and look for calibration board corners\n        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n        self.img_shape = gray.shape[::-1]\n\n        if self.calib_type == CalibType.CHESSBOARD:\n            found, corners = cv2.findChessboardCorners(\n                gray,\n                self.corner_shape,\n                cv2.CALIB_CB_ADAPTIVE_THRESH\n                + cv2.CALIB_CB_NORMALIZE_IMAGE\n                + cv2.CALIB_CB_FAST_CHECK,\n            )\n\n        elif self.calib_type == CalibType.CIRCLE_GRID:  # TODO test\n            keypoints = self.blob_detector.detect(gray)\n            img_keypoints = cv2.drawKeypoints(\n                img,\n                keypoints,\n                np.array([]),\n                (0, 255, 0),\n                cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS,\n            )\n            found, corners = cv2.findCirclesGrid(\n                img_keypoints, self.corner_shape, None, flags=cv2.CALIB_CB_ASYMMETRIC_GRID\n            )\n\n        used = False\n        path_saved = None\n\n        # If there is a board and it has been long enough\n        if (\n            found\n            and time.time() - self.last_image_used > self.delay\n            and self.is_ready(gray, corners)\n        ):\n            used = True\n            self.update_overlay(corners)\n            self.last_image_used = time.time()\n            self.prev_used_corner1 = corners[0][0]\n            self.prev_used_corner2 = corners[-1][-1]\n\n            # Refine corner locations (Better calibrations)\n            refined = cv2.cornerSubPix(\n                gray, corners, refinementWindow, (-1, -1), refinementCriteria\n            )\n\n            # Set 3d locations and 2d location for image\n            self.obj_points.append(self.reference)\n            self.img_points.append(refined)\n\n            # Save off time and image\n            curr_time = time.time_ns()\n            path_saved = os.path.join(self.img_path, f\"{curr_time}.png\")\n\n            cv2.imwrite(path_saved, gray)\n\n            Calibration.logger.info(f\"Calibration image saved to {path_saved}\")\n\n        self.draw_overlay(img)\n\n        # Draw lines for the calibration board\n        cv2.drawChessboardCorners(img, self.corner_shape, corners, found)\n\n        if found:\n            # cv2.putText(\n            #     img,\n            #     \"Sharp\" if self.lastImageSharp else \"Blurry\",\n            #     (0, img.shape[0] - 10),\n            #     cv2.FONT_HERSHEY_SIMPLEX,\n            #     1,\n            #     (255, 0, 0) if self.lastImageSharp else (0, 0, 255),\n            #     2,\n            # )\n            # Text for calibrating the camera\n            cv2.putText(\n                img,\n                \"Stable\" if self.last_image_stable else \"Not stable\",\n                (0, img.shape[0] - 50),\n                cv2.FONT_HERSHEY_SIMPLEX,\n                1,\n                (255, 0, 0) if self.last_image_stable else (0, 0, 255),\n                2,\n            )\n\n        # Keep track of the amount of images taken on the image\n        cv2.putText(\n            img,\n            f\"Imgs taken: {len(self.img_points)}\",\n            (0, img.shape[0] - 100),\n            cv2.FONT_HERSHEY_SIMPLEX,\n            1,\n            (255, 0, 0) if used else (0, 0, 255),\n            2,\n        )\n\n        return (img, used, path_saved)\n\n    def update_overlay(self, corners):\n        cv2.fillPoly(\n            self.overlay,\n            [\n                np.asarray(\n                    [\n                        corners[0][0],\n                        corners[self.corner_shape[0] - 1][0],\n                        corners[-1][0],\n                        corners[-(self.corner_shape[0])][0],\n                    ],\n                    \"int32\",\n                )\n            ],\n            (\n                np.random.randint(0, 255),\n                np.random.randint(0, 255),\n                np.random.randint(0, 255),\n            ),\n        )\n\n    def draw_overlay(self, img, alpha=0.5):\n        mask = self.overlay.astype(bool)\n        img[mask] = cv2.addWeighted(img, alpha, self.overlay, 1 - alpha, 0)[mask]\n\n    # Return all saved calibration images\n    def load_saved_images(\n        self,\n        imgs: list[str],\n        refinementWindow: tuple[int, int] = (5, 5),\n        refinementCriteria: tuple[float, int, float] = (\n            cv2.TERM_CRITERIA_EPS + cv2.TermCriteria_COUNT,\n            40,\n            0.001,\n        ),\n    ):\n        # Go through each image, grayscale it, find corner loc, refine, and\n        # save off 2d and 3d locations\n        for img in imgs:\n            saved = cv2.imread(img)\n            gray = cv2.cvtColor(saved, cv2.COLOR_BGR2GRAY)\n            self.img_shape = gray.shape[::-1]\n            found, corners = cv2.findChessboardCorners(\n                gray,\n                self.corner_shape,\n                cv2.CALIB_CB_ADAPTIVE_THRESH\n                + cv2.CALIB_CB_NORMALIZE_IMAGE\n                + cv2.CALIB_CB_FAST_CHECK,\n            )\n\n            if found:\n                refined = cv2.cornerSubPix(\n                    gray,\n                    corners,\n                    refinementWindow,\n                    (-1, -1),\n                    refinementCriteria,\n                )\n\n                self.obj_points.append(self.reference)\n                self.img_points.append(refined)\n\n    # Generate a calibration and write to a file\n    def generate_calibration(self, cal_file: str):\n        if len(self.obj_points) == 0:\n            Calibration.logger.error(\"Calibration failed: No image data available\")\n            return False\n\n        # Using the saved off 2d and 3d points, it will return a camera matrix\n        # and distortion coeff\n        ret, cam_mtx, distortion, rot, trans = cv2.calibrateCamera(\n            self.obj_points,\n            self.img_points,\n            self.img_shape,\n            None,\n            None,\n            # flags=cv2.CALIB_RATIONAL_MODEL\n            # + cv2.CALIB_THIN_PRISM_MODEL\n            # + cv2.CALIB_TILTED_MODEL,\n        )\n\n        # Write to a dictionary\n        self.calibration_data = {\n            \"K\": cam_mtx,\n            \"dist\": distortion,\n            \"r\": rot,\n            \"t\": trans,\n            \"resolution\": self.resolution,\n        }\n\n        # Get calibration error and set it\n        reproj_error = self.get_reprojection_error()\n\n        self.calibration_data[\"reprojError\"] = reproj_error\n\n        Path(os.path.join(\"config_data\", \"calibrations\")).mkdir(\n            parents=True, exist_ok=True\n        )\n\n        # Write to a calibration file\n        with open(cal_file, \"w\") as f:\n            json.dump(\n                {\n                    \"camPath\": self.cam_path,\n                    \"K\": cam_mtx.tolist(),\n                    \"dist\": distortion.tolist(),\n                    \"r\": np.asarray(rot).tolist(),\n                    \"t\": np.asarray(trans).tolist(),\n                    \"reproj\": reproj_error,\n                    \"resolution\": self.resolution,\n                },\n                f,\n            )\n\n        Calibration.logger.info(\n            f\"Calibration successfully generated and saved to {cal_file} with resolution {self.resolution}\"\n        )\n\n        return ret\n\n    # Check if the current image has a stable board\n    def is_stable(self, corners: np.ndarray):\n        corner1 = corners[0][0]\n        corner2 = corners[-1][0]\n\n        dt = time.time() - self.last_image_used\n\n        speed1 = np.linalg.norm(corner1 - self.prev_corner1) / dt\n        speed2 = np.linalg.norm(corner2 - self.prev_corner2) / dt\n\n        self.prev_corner1 = corner1\n        self.prev_corner2 = corner2\n\n        threshold = self.resolution[0] / 200\n\n        self.last_image_stable = speed1 < threshold and speed2 < threshold\n\n        return self.last_image_stable\n\n    # Not currently used\n    # def isSharp(self, img: np.ndarray, threshold: float = 10, cutoff: float = 80):\n    #     (h, w) = img.shape\n\n    #     fft = np.fft.fft2(img)\n    #     fftShift = np.fft.fftshift(fft)\n\n    #     fftShift[\n    #         h // 2 - cutoff : h // 2 + cutoff, w // 2 - cutoff : w // 2 + cutoff\n    #     ] = 0\n\n    #     fftShift = np.fft.ifftshift(fftShift)\n    #     recon = np.fft.ifft2(fftShift)\n\n    #     self.lastImageSharp = threshold < np.mean(20 * np.log(np.abs(recon)))\n\n    #     return self.lastImageSharp\n\n    # Check if the current image can be use for calibration\n    def is_ready(\n        self, img: np.ndarray, corners: np.ndarray, requiredReadyCounts: int = 6\n    ) -> bool:\n        threshold = self.resolution[0] / 50\n        if (\n            np.linalg.norm(self.prev_used_corner1 - corners[0][0]) > threshold\n            and np.linalg.norm(self.prev_used_corner2 - corners[-1][-1]) > threshold\n            and self.is_stable(corners)\n        ):  # Not checking isSharp\n            self.ready_counts += 1\n        else:\n            self.ready_counts = 0\n\n        return requiredReadyCounts <= self.ready_counts\n\n    # calculate error of the calibration\n    def get_reprojection_error(self) -> float:\n        if len(self.obj_points) == 0:\n            Calibration.logger.error(\"Cannot compute reprojection error: No image data\")\n            return\n\n        total_error = 0\n\n        for i in range(len(self.obj_points)):\n            imgpoints2, _ = cv2.projectPoints(\n                self.obj_points[i],\n                self.calibration_data[\"r\"][i],\n                self.calibration_data[\"t\"][i],\n                self.calibration_data[\"K\"],\n                self.calibration_data[\"dist\"],\n            )\n            error = cv2.norm(self.img_points[i], imgpoints2, cv2.NORM_L2) / len(\n                imgpoints2\n            )\n            total_error += error\n\n        return total_error / len(self.obj_points)\n\n    # Load a calibration file\n    def load_calibration(self, file: str):\n        with open(file, \"r\") as f:\n            self.calibration_data = json.load(f)\n\n        self.calibration_data[\"K\"] = np.asarray(self.calibration_data[\"K\"])\n        self.calibration_data[\"dist\"] = np.asarray(self.calibration_data[\"dist\"])\n        self.calibration_data[\"r\"] = np.asarray(self.calibration_data[\"r\"])\n        self.calibration_data[\"t\"] = np.asarray(self.calibration_data[\"t\"])\n\n        Calibration.logger.info(f\"Calibration loaded from {file}\")\n\n    # Get calibration data from a calibration file\n    @staticmethod\n    def parse_calibration(file: str):\n        Calibration.logger.info(f\"Looking for calibration stored at {file}\")\n\n        with open(file, \"r\") as f:\n            calibration_data = json.load(f)\n\n        try:\n            calibration_data[\"K\"] = np.array(calibration_data[\"K\"])\n            calibration_data[\"dist\"] = np.array(calibration_data[\"dist\"])\n            calibration_data[\"r\"] = np.array(calibration_data[\"r\"])\n            calibration_data[\"t\"] = np.array(calibration_data[\"t\"])\n        except BaseException:\n            Calibration.logger.error(f\"Invalid calibration format in {file}\")\n\n        return calibration_data\n"]]], 1715213084.9103222]], ["ChangeSet", ["Renaming <rot3D> to <rot3D_XxX_CamelSnakePep8_PreserveName_XxX_5>", [["ChangeContents", ["processing/processing.py", "import cv2\nimport json\nimport logging\nimport wpimath.geometry as wpi\nimport numpy as np\nimport math\n\n\nclass Processor:\n    logger = logging.getLogger(__name__)\n    BAD_POSE = wpi.Pose3d(wpi.Translation3d(2767, 2767, 2767), wpi.Rotation3d())\n    MIN_TAG = 0\n    MAX_TAG = 16\n\n    # Create a pose estimator\n    def __init__(self, tag_length):\n        # Open tag layout for tag poses\n        with open(\"./processing/april_tag_layout.json\", \"r\") as f:\n            self.tag_layout = json.load(f)\n            Processor.logger.info(\"Tag layout loaded\")\n\n        # Save layout\n        self.tag_layout = self.tag_layout[\"tags\"]\n\n        # Create an aruco detector (finds the tags in images)\n        self.aruco_detector = cv2.aruco.ArucoDetector()\n        self.aruco_detector.setDictionary(\n            cv2.aruco.getPredefinedDictionary(\n                cv2.aruco.DICT_APRILTAG_36H11\n            )  # Old: DICT_APRILTAG_16H5 ---- NEW: DICT_APRILTAG_36H11\n        )\n\n        # Change params to balance speed and accuracy\n        aruco_params = cv2.aruco.DetectorParameters()\n        aruco_params.cornerRefinementMethod = cv2.aruco.CORNER_REFINE_SUBPIX\n        aruco_params.cornerRefinementMinAccuracy = 0.1\n        aruco_params.cornerRefinementMaxIterations = 30\n        self.aruco_detector.setDetectorParameters(aruco_params)\n\n        self.square_length = tag_length\n\n    # Return camera pose\n    def get_pose(self, images, K, D):\n        return self.image_pose(images, K, D, self.tag_layout, self.aruco_detector)\n\n    # Set AprilTag side length in meters\n    def set_tag_size(self, size):\n        self.square_length = size\n\n    # A method that translates the WPILib coordinate system to the openCV\n    # coordinate system\n    @staticmethod\n    def translation_to_solve_pnp(translation):\n        return np.asarray([-translation.Y(), -translation.Z(), translation.X()])\n\n    # Grab AprilTag pose information\n    @staticmethod\n    def make_pose_object(temp):\n        return wpi.Transform3d(\n            wpi.Translation3d(\n                temp[\"translation\"][\"x\"],\n                temp[\"translation\"][\"y\"],\n                temp[\"translation\"][\"z\"],\n            ),\n            wpi.Rotation3d(\n                wpi.Quaternion(\n                    temp[\"rotation\"][\"quaternion\"][\"W\"],\n                    temp[\"rotation\"][\"quaternion\"][\"X\"],\n                    temp[\"rotation\"][\"quaternion\"][\"Y\"],\n                    temp[\"rotation\"][\"quaternion\"][\"Z\"],\n                )\n            ).rotateBy(wpi.Rotation3d(0, 0, math.radians(180))),\n        )\n\n    # ROT MUST BE A 3x3 ROTATION MATRIX\n    @staticmethod\n    def get_transform(trans, rot):\n        return np.concatenate(\n            (np.concatenate((rot, trans), axis=1), np.asarray([[0, 0, 0, 1]])), axis=0\n        )\n\n    @staticmethod\n    def get_tag_transform(json_id):\n        pose = Processor.make_pose_object(json_id)\n        rot = pose.rotation().rotateBy(wpi.Rotation3d(0, 0, math.radians(180)))\n        translation = np.asarray([pose.X(), pose.Y(), pose.Z()]).reshape(3, 1)\n        rot, _ = cv2.Rodrigues(np.asarray([rot.X(), rot.Y(), rot.Z()]).reshape(3, 1))\n        return Processor.get_transform(translation, rot)\n\n    @staticmethod\n    def get_rot_from_transform(transform):\n        return transform[:3, :3]\n\n    @staticmethod\n    def get_translation_from_transform(transform):\n        return transform[:3, 3]\n\n    # Translate corner locations\n    @staticmethod\n    def add_corners(tag_pos, corner_pos):\n        return Processor.translation_to_solve_pnp(\n            tag_pos.translation() + corner_pos.rotateBy(tag_pos.rotation())\n        )\n\n    @staticmethod\n    def get_trans_rots(tvecs, rvecs, cur_id, layout):\n\n        cam_tvecs = tvecs\n\n        # ambig.append(reproj[0][0])\n\n        x = cam_tvecs[0]\n        y = cam_tvecs[1]\n        z = cam_tvecs[2]\n\n        cam_tvecs = np.asarray([z, -x, -y]).reshape(3, 1)\n\n        cam_rvecs = rvecs\n\n        x = cam_rvecs[0]\n        y = cam_rvecs[1]\n        z = cam_rvecs[2]\n\n        cam_rvecs = np.asarray([z, -x, -y]).reshape(3, 1)\n\n        cam_rot_mat, _ = cv2.Rodrigues(cam_rvecs)\n        cam2_tag = Processor.get_transform(cam_tvecs, cam_rot_mat)\n        world2_tag = Processor.get_tag_transform(layout[cur_id - 1][\"pose\"])\n\n        world2_cam = np.dot(world2_tag, np.linalg.inv(cam2_tag))\n\n        trans_vec = Processor.get_translation_from_transform(world2_cam)\n        rvecs = Processor.get_rot_from_transform(world2_cam)\n        return (trans_vec, rvecs)\n\n    # Find AprilTags and calculate the camera's pose\n    def image_pose(self, images, K, D, layout, aruco_detector):\n        poses = []\n        tags = []\n        ambig = []\n\n        # Loop through images\n        for img_index, img in enumerate(images):\n            pose1 = 0\n            pose2 = 0\n            cur_tags = []\n\n            # If an invalid image is given or no calibration return an error\n            # pose\n            if img is None or K[img_index] is None or D[img_index] is None:\n                poses.append((Processor.BAD_POSE, Processor.BAD_POSE))\n                tags.append([])\n                ambig.append(2767)\n                continue\n\n            # Find corner locations for all tags in frame\n            corners, ids, rej = aruco_detector.detectMarkers(\n                img\n            )  # BEWARE: ids is a 2D array!!!\n\n            # If you have corners, find pose\n            if len(corners) > 0:\n                # Processor.logger.info(corners)\n                num = 0\n\n                # Draw lines around tags for ease of seeing (website)\n                cv2.aruco.drawDetectedMarkers(img, corners, ids)\n\n                tag_loc = None\n                corner_loc = None\n                tag_count = 0\n\n                # Loop through each id\n                for i in ids:\n                    # Filter out invalid ids\n                    if i < Processor.MIN_TAG or i > Processor.MAX_TAG:\n                        Processor.logger.warning(f\"BAD TAG ID: {i}\")\n                        continue\n\n                    # Add id information to tagID array\n                    cur_tags.append(i[0])\n\n                    # Grab tag pose and calcualte each corner location\n                    pose = Processor.make_pose_object(layout[int(i - 1)][\"pose\"])\n                    c1 = Processor.translation_to_solve_pnp(\n                        pose\n                        + wpi.Transform3d(\n                            wpi.Translation3d(\n                                0, -self.square_length / 2, -self.square_length / 2\n                            ),\n                            wpi.Rotation3d(),\n                        )\n                    )\n                    c2 = Processor.translation_to_solve_pnp(\n                        pose\n                        + wpi.Transform3d(\n                            wpi.Translation3d(\n                                0, self.square_length / 2, -self.square_length / 2\n                            ),\n                            wpi.Rotation3d(),\n                        )\n                    )\n                    c3 = Processor.translation_to_solve_pnp(\n                        pose\n                        + wpi.Transform3d(\n                            wpi.Translation3d(\n                                0, self.square_length / 2, self.square_length / 2\n                            ),\n                            wpi.Rotation3d(),\n                        )\n                    )\n                    c4 = Processor.translation_to_solve_pnp(\n                        pose\n                        + wpi.Transform3d(\n                            wpi.Translation3d(\n                                0, -self.square_length / 2, self.square_length / 2\n                            ),\n                            wpi.Rotation3d(),\n                        )\n                    )\n\n                    # Corners as if center of tag is 0,0,0 to draw axis lines\n                    tempc1 = np.asarray(\n                        [self.square_length / 2, self.square_length / 2, 0]\n                    )\n                    tempc2 = np.asarray(\n                        [-self.square_length / 2, self.square_length / 2, 0]\n                    )\n                    tempc3 = np.asarray(\n                        [self.square_length / 2, -self.square_length / 2, 0]\n                    )\n                    tempc4 = np.asarray(\n                        [-self.square_length / 2, -self.square_length / 2, 0]\n                    )\n\n                    # Do basic solvePNP\n                    ret, rvec, tvec, reproj = cv2.solvePnPGeneric(\n                        np.asarray([tempc2, tempc1, tempc3, tempc4]),\n                        corners[tag_count][0],\n                        K[img_index],\n                        D[img_index],\n                        flags=cv2.SOLVEPNP_IPPE_SQUARE,\n                    )\n\n                    # Find poses for one tag case\n                    if len(ids) == 1:\n                        ambig.append(reproj[0][0] / reproj[1][0])\n\n                    # Draw axis on the tags\n                    cv2.drawFrameAxes(\n                        img, K[img_index], D[img_index], rvec[0], tvec[0], 0.1\n                    )\n\n                    # Add 2d location and 3d locations\n                    if tag_loc is None:\n                        corner_loc = corners[tag_count][0]\n                        tag_loc = np.array([c1, c2, c3, c4])\n                    else:\n                        corner_loc = np.concatenate(\n                            (corner_loc, corners[tag_count][0]), axis=0\n                        )\n                        tag_loc = np.concatenate(\n                            (tag_loc, np.asarray([c1, c2, c3, c4]))\n                        )\n                    tag_count += 1\n\n                if (\n                    corner_loc is not None\n                ):  # Make sure that tag is valid (i >= 0 and i <= 8)\n                    # Ambiguity does not matter with 2+ tags\n                    if len(ids) > 1:\n                        ambig.append(2767)\n\n                if len(ids) == 1:\n                    tempc1 = np.asarray(\n                        [self.square_length / 2, self.square_length / 2, 0]\n                    )\n                    tempc2 = np.asarray(\n                        [-self.square_length / 2, self.square_length / 2, 0]\n                    )\n                    tempc3 = np.asarray(\n                        [self.square_length / 2, -self.square_length / 2, 0]\n                    )\n                    tempc4 = np.asarray(\n                        [-self.square_length / 2, -self.square_length / 2, 0]\n                    )\n\n                    ret, rvecs, tvecs, reproj = cv2.solvePnPGeneric(\n                        np.asarray([tempc2, tempc1, tempc3, tempc4]),\n                        corners[0][0],\n                        K[img_index],\n                        D[img_index],\n                        flags=cv2.SOLVEPNP_IPPE_SQUARE,\n                    )\n                    t1, r1 = Processor.get_trans_rots(\n                        tvecs[0].reshape(3, 1), rvecs[0], ids[0][0], layout\n                    )\n                    t2, r2 = Processor.get_trans_rots(\n                        tvecs[1].reshape(3, 1), rvecs[1], ids[0][0], layout\n                    )\n\n                    rot3D_XxX_CamelSnakePep8_PreserveName_XxX_5 = wpi.Rotation3d(r1)\n                    trans = wpi.Translation3d(t1[0], t1[1], t1[2])\n\n                    pose1 = wpi.Pose3d(trans, rot3D_XxX_CamelSnakePep8_PreserveName_XxX_5)\n\n                    rot3D_XxX_CamelSnakePep8_PreserveName_XxX_5 = wpi.Rotation3d(r2)\n                    trans = wpi.Translation3d(t2[0], t2[1], t2[2])\n\n                    pose2 = wpi.Pose3d(trans, rot3D_XxX_CamelSnakePep8_PreserveName_XxX_5)\n\n                else:\n                    # Calculate robot pose with 2d and 3d points\n                    # Sometimes dies:  point_coordinate_variance >=\n                    # POINT_VARIANCE_THRESHOLD in function 'computeOmega'\n\n                    try:\n                        ret, rvecs, tvecs = cv2.solvePnP(\n                            tag_loc,\n                            corner_loc,\n                            K[img_index],\n                            D[img_index],\n                            flags=cv2.SOLVEPNP_SQPNP,\n                        )\n                    except BaseException:\n                        Processor.logger.error(\"solvePnP error?!\")\n                        poses.append((Processor.BAD_POSE, Processor.BAD_POSE))\n                        tags.append([])\n                        ambig.append(2767)\n\n                        return (poses, tags, ambig)\n\n                    # ambig.append(reproj[0])\n\n                    # Grab the rotation matrix and find the translation vector\n                    rot_mat, _ = cv2.Rodrigues(rvecs)\n                    trans_vec = -np.dot(np.transpose(rot_mat), tvecs)\n                    trans_vec = np.asarray([trans_vec[2], -trans_vec[0], -trans_vec[1]])\n\n                    rots, _ = cv2.Rodrigues(rot_mat)\n                    rot_mat, _ = cv2.Rodrigues(np.asarray([rots[2], -rots[0], rots[1]]))\n\n                    # Convert the rotation matrix to a three rotation system\n                    # (yaw, pitch, roll)\n                    rot3D_XxX_CamelSnakePep8_PreserveName_XxX_5 = wpi.Rotation3d(rot_mat)\n                    pose1 = wpi.Pose3d(\n                        # Translation between openCV and WPILib\n                        wpi.Translation3d(trans_vec[0], trans_vec[1], trans_vec[2]),\n                        rot3D_XxX_CamelSnakePep8_PreserveName_XxX_5,\n                    )\n                    pose2 = pose1\n                # Append the pose\n                poses.append((pose1, pose2))\n                tags.append(cur_tags)\n                num += 1\n            else:\n                # If no tags\n                poses.append((Processor.BAD_POSE, Processor.BAD_POSE))\n                tags.append([])\n                ambig.append(2767)\n\n        return (poses, tags, ambig)\n", "import cv2\nimport json\nimport logging\nimport wpimath.geometry as wpi\nimport numpy as np\nimport math\n\n\nclass Processor:\n    logger = logging.getLogger(__name__)\n    BAD_POSE = wpi.Pose3d(wpi.Translation3d(2767, 2767, 2767), wpi.Rotation3d())\n    MIN_TAG = 0\n    MAX_TAG = 16\n\n    # Create a pose estimator\n    def __init__(self, tag_length):\n        # Open tag layout for tag poses\n        with open(\"./processing/april_tag_layout.json\", \"r\") as f:\n            self.tag_layout = json.load(f)\n            Processor.logger.info(\"Tag layout loaded\")\n\n        # Save layout\n        self.tag_layout = self.tag_layout[\"tags\"]\n\n        # Create an aruco detector (finds the tags in images)\n        self.aruco_detector = cv2.aruco.ArucoDetector()\n        self.aruco_detector.setDictionary(\n            cv2.aruco.getPredefinedDictionary(\n                cv2.aruco.DICT_APRILTAG_36H11\n            )  # Old: DICT_APRILTAG_16H5 ---- NEW: DICT_APRILTAG_36H11\n        )\n\n        # Change params to balance speed and accuracy\n        aruco_params = cv2.aruco.DetectorParameters()\n        aruco_params.cornerRefinementMethod = cv2.aruco.CORNER_REFINE_SUBPIX\n        aruco_params.cornerRefinementMinAccuracy = 0.1\n        aruco_params.cornerRefinementMaxIterations = 30\n        self.aruco_detector.setDetectorParameters(aruco_params)\n\n        self.square_length = tag_length\n\n    # Return camera pose\n    def get_pose(self, images, K, D):\n        return self.image_pose(images, K, D, self.tag_layout, self.aruco_detector)\n\n    # Set AprilTag side length in meters\n    def set_tag_size(self, size):\n        self.square_length = size\n\n    # A method that translates the WPILib coordinate system to the openCV\n    # coordinate system\n    @staticmethod\n    def translation_to_solve_pnp(translation):\n        return np.asarray([-translation.Y(), -translation.Z(), translation.X()])\n\n    # Grab AprilTag pose information\n    @staticmethod\n    def make_pose_object(temp):\n        return wpi.Transform3d(\n            wpi.Translation3d(\n                temp[\"translation\"][\"x\"],\n                temp[\"translation\"][\"y\"],\n                temp[\"translation\"][\"z\"],\n            ),\n            wpi.Rotation3d(\n                wpi.Quaternion(\n                    temp[\"rotation\"][\"quaternion\"][\"W\"],\n                    temp[\"rotation\"][\"quaternion\"][\"X\"],\n                    temp[\"rotation\"][\"quaternion\"][\"Y\"],\n                    temp[\"rotation\"][\"quaternion\"][\"Z\"],\n                )\n            ).rotateBy(wpi.Rotation3d(0, 0, math.radians(180))),\n        )\n\n    # ROT MUST BE A 3x3 ROTATION MATRIX\n    @staticmethod\n    def get_transform(trans, rot):\n        return np.concatenate(\n            (np.concatenate((rot, trans), axis=1), np.asarray([[0, 0, 0, 1]])), axis=0\n        )\n\n    @staticmethod\n    def get_tag_transform(json_id):\n        pose = Processor.make_pose_object(json_id)\n        rot = pose.rotation().rotateBy(wpi.Rotation3d(0, 0, math.radians(180)))\n        translation = np.asarray([pose.X(), pose.Y(), pose.Z()]).reshape(3, 1)\n        rot, _ = cv2.Rodrigues(np.asarray([rot.X(), rot.Y(), rot.Z()]).reshape(3, 1))\n        return Processor.get_transform(translation, rot)\n\n    @staticmethod\n    def get_rot_from_transform(transform):\n        return transform[:3, :3]\n\n    @staticmethod\n    def get_translation_from_transform(transform):\n        return transform[:3, 3]\n\n    # Translate corner locations\n    @staticmethod\n    def add_corners(tag_pos, corner_pos):\n        return Processor.translation_to_solve_pnp(\n            tag_pos.translation() + corner_pos.rotateBy(tag_pos.rotation())\n        )\n\n    @staticmethod\n    def get_trans_rots(tvecs, rvecs, cur_id, layout):\n\n        cam_tvecs = tvecs\n\n        # ambig.append(reproj[0][0])\n\n        x = cam_tvecs[0]\n        y = cam_tvecs[1]\n        z = cam_tvecs[2]\n\n        cam_tvecs = np.asarray([z, -x, -y]).reshape(3, 1)\n\n        cam_rvecs = rvecs\n\n        x = cam_rvecs[0]\n        y = cam_rvecs[1]\n        z = cam_rvecs[2]\n\n        cam_rvecs = np.asarray([z, -x, -y]).reshape(3, 1)\n\n        cam_rot_mat, _ = cv2.Rodrigues(cam_rvecs)\n        cam2_tag = Processor.get_transform(cam_tvecs, cam_rot_mat)\n        world2_tag = Processor.get_tag_transform(layout[cur_id - 1][\"pose\"])\n\n        world2_cam = np.dot(world2_tag, np.linalg.inv(cam2_tag))\n\n        trans_vec = Processor.get_translation_from_transform(world2_cam)\n        rvecs = Processor.get_rot_from_transform(world2_cam)\n        return (trans_vec, rvecs)\n\n    # Find AprilTags and calculate the camera's pose\n    def image_pose(self, images, K, D, layout, aruco_detector):\n        poses = []\n        tags = []\n        ambig = []\n\n        # Loop through images\n        for img_index, img in enumerate(images):\n            pose1 = 0\n            pose2 = 0\n            cur_tags = []\n\n            # If an invalid image is given or no calibration return an error\n            # pose\n            if img is None or K[img_index] is None or D[img_index] is None:\n                poses.append((Processor.BAD_POSE, Processor.BAD_POSE))\n                tags.append([])\n                ambig.append(2767)\n                continue\n\n            # Find corner locations for all tags in frame\n            corners, ids, rej = aruco_detector.detectMarkers(\n                img\n            )  # BEWARE: ids is a 2D array!!!\n\n            # If you have corners, find pose\n            if len(corners) > 0:\n                # Processor.logger.info(corners)\n                num = 0\n\n                # Draw lines around tags for ease of seeing (website)\n                cv2.aruco.drawDetectedMarkers(img, corners, ids)\n\n                tag_loc = None\n                corner_loc = None\n                tag_count = 0\n\n                # Loop through each id\n                for i in ids:\n                    # Filter out invalid ids\n                    if i < Processor.MIN_TAG or i > Processor.MAX_TAG:\n                        Processor.logger.warning(f\"BAD TAG ID: {i}\")\n                        continue\n\n                    # Add id information to tagID array\n                    cur_tags.append(i[0])\n\n                    # Grab tag pose and calcualte each corner location\n                    pose = Processor.make_pose_object(layout[int(i - 1)][\"pose\"])\n                    c1 = Processor.translation_to_solve_pnp(\n                        pose\n                        + wpi.Transform3d(\n                            wpi.Translation3d(\n                                0, -self.square_length / 2, -self.square_length / 2\n                            ),\n                            wpi.Rotation3d(),\n                        )\n                    )\n                    c2 = Processor.translation_to_solve_pnp(\n                        pose\n                        + wpi.Transform3d(\n                            wpi.Translation3d(\n                                0, self.square_length / 2, -self.square_length / 2\n                            ),\n                            wpi.Rotation3d(),\n                        )\n                    )\n                    c3 = Processor.translation_to_solve_pnp(\n                        pose\n                        + wpi.Transform3d(\n                            wpi.Translation3d(\n                                0, self.square_length / 2, self.square_length / 2\n                            ),\n                            wpi.Rotation3d(),\n                        )\n                    )\n                    c4 = Processor.translation_to_solve_pnp(\n                        pose\n                        + wpi.Transform3d(\n                            wpi.Translation3d(\n                                0, -self.square_length / 2, self.square_length / 2\n                            ),\n                            wpi.Rotation3d(),\n                        )\n                    )\n\n                    # Corners as if center of tag is 0,0,0 to draw axis lines\n                    tempc1 = np.asarray(\n                        [self.square_length / 2, self.square_length / 2, 0]\n                    )\n                    tempc2 = np.asarray(\n                        [-self.square_length / 2, self.square_length / 2, 0]\n                    )\n                    tempc3 = np.asarray(\n                        [self.square_length / 2, -self.square_length / 2, 0]\n                    )\n                    tempc4 = np.asarray(\n                        [-self.square_length / 2, -self.square_length / 2, 0]\n                    )\n\n                    # Do basic solvePNP\n                    ret, rvec, tvec, reproj = cv2.solvePnPGeneric(\n                        np.asarray([tempc2, tempc1, tempc3, tempc4]),\n                        corners[tag_count][0],\n                        K[img_index],\n                        D[img_index],\n                        flags=cv2.SOLVEPNP_IPPE_SQUARE,\n                    )\n\n                    # Find poses for one tag case\n                    if len(ids) == 1:\n                        ambig.append(reproj[0][0] / reproj[1][0])\n\n                    # Draw axis on the tags\n                    cv2.drawFrameAxes(\n                        img, K[img_index], D[img_index], rvec[0], tvec[0], 0.1\n                    )\n\n                    # Add 2d location and 3d locations\n                    if tag_loc is None:\n                        corner_loc = corners[tag_count][0]\n                        tag_loc = np.array([c1, c2, c3, c4])\n                    else:\n                        corner_loc = np.concatenate(\n                            (corner_loc, corners[tag_count][0]), axis=0\n                        )\n                        tag_loc = np.concatenate(\n                            (tag_loc, np.asarray([c1, c2, c3, c4]))\n                        )\n                    tag_count += 1\n\n                if (\n                    corner_loc is not None\n                ):  # Make sure that tag is valid (i >= 0 and i <= 8)\n                    # Ambiguity does not matter with 2+ tags\n                    if len(ids) > 1:\n                        ambig.append(2767)\n\n                if len(ids) == 1:\n                    tempc1 = np.asarray(\n                        [self.square_length / 2, self.square_length / 2, 0]\n                    )\n                    tempc2 = np.asarray(\n                        [-self.square_length / 2, self.square_length / 2, 0]\n                    )\n                    tempc3 = np.asarray(\n                        [self.square_length / 2, -self.square_length / 2, 0]\n                    )\n                    tempc4 = np.asarray(\n                        [-self.square_length / 2, -self.square_length / 2, 0]\n                    )\n\n                    ret, rvecs, tvecs, reproj = cv2.solvePnPGeneric(\n                        np.asarray([tempc2, tempc1, tempc3, tempc4]),\n                        corners[0][0],\n                        K[img_index],\n                        D[img_index],\n                        flags=cv2.SOLVEPNP_IPPE_SQUARE,\n                    )\n                    t1, r1 = Processor.get_trans_rots(\n                        tvecs[0].reshape(3, 1), rvecs[0], ids[0][0], layout\n                    )\n                    t2, r2 = Processor.get_trans_rots(\n                        tvecs[1].reshape(3, 1), rvecs[1], ids[0][0], layout\n                    )\n\n                    rot3D = wpi.Rotation3d(r1)\n                    trans = wpi.Translation3d(t1[0], t1[1], t1[2])\n\n                    pose1 = wpi.Pose3d(trans, rot3D)\n\n                    rot3D = wpi.Rotation3d(r2)\n                    trans = wpi.Translation3d(t2[0], t2[1], t2[2])\n\n                    pose2 = wpi.Pose3d(trans, rot3D)\n\n                else:\n                    # Calculate robot pose with 2d and 3d points\n                    # Sometimes dies:  point_coordinate_variance >=\n                    # POINT_VARIANCE_THRESHOLD in function 'computeOmega'\n\n                    try:\n                        ret, rvecs, tvecs = cv2.solvePnP(\n                            tag_loc,\n                            corner_loc,\n                            K[img_index],\n                            D[img_index],\n                            flags=cv2.SOLVEPNP_SQPNP,\n                        )\n                    except BaseException:\n                        Processor.logger.error(\"solvePnP error?!\")\n                        poses.append((Processor.BAD_POSE, Processor.BAD_POSE))\n                        tags.append([])\n                        ambig.append(2767)\n\n                        return (poses, tags, ambig)\n\n                    # ambig.append(reproj[0])\n\n                    # Grab the rotation matrix and find the translation vector\n                    rot_mat, _ = cv2.Rodrigues(rvecs)\n                    trans_vec = -np.dot(np.transpose(rot_mat), tvecs)\n                    trans_vec = np.asarray([trans_vec[2], -trans_vec[0], -trans_vec[1]])\n\n                    rots, _ = cv2.Rodrigues(rot_mat)\n                    rot_mat, _ = cv2.Rodrigues(np.asarray([rots[2], -rots[0], rots[1]]))\n\n                    # Convert the rotation matrix to a three rotation system\n                    # (yaw, pitch, roll)\n                    rot3D = wpi.Rotation3d(rot_mat)\n                    pose1 = wpi.Pose3d(\n                        # Translation between openCV and WPILib\n                        wpi.Translation3d(trans_vec[0], trans_vec[1], trans_vec[2]),\n                        rot3D,\n                    )\n                    pose2 = pose1\n                # Append the pose\n                poses.append((pose1, pose2))\n                tags.append(cur_tags)\n                num += 1\n            else:\n                # If no tags\n                poses.append((Processor.BAD_POSE, Processor.BAD_POSE))\n                tags.append([])\n                ambig.append(2767)\n\n        return (poses, tags, ambig)\n"]]], 1715213089.339416]], ["ChangeSet", ["Renaming <setConnectionValue> to <setConnectionValue_XxX_CamelSnakePep8_PreserveName_XxX_6>", [["ChangeContents", ["init.py", "import sys\nimport logging\nfrom logging.handlers import RotatingFileHandler\nfrom directory import calibration_image_folder, calibration_path_by_cam, LOG\n\n# Create logger and set settings\nLOG_FORMAT = \"[%(asctime)s - %(levelname)s - %(filename)s:%(lineno)s - %(funcName)s()]  %(message)s\"\nlogging.basicConfig(\n    format=LOG_FORMAT,\n    handlers=[\n        logging.StreamHandler(sys.stdout),\n        RotatingFileHandler(LOG, maxBytes_XxX_CamelSnakePep8_PreserveName_XxX_2=1024 * 1024, backupCount_XxX_CamelSnakePep8_PreserveName_XxX_3=5),\n    ],\n    datefmt=\"%d-%b-%y %H:%M:%S\",\n    level=logging.INFO,\n)\n\nlogger = logging.getLogger(__name__)\n\nlogger.info(\"----------- Starting Up -----------\")\n\nfrom state import walleye_data, States, CALIBRATION_STATES\nfrom processing.processing import Processor\nimport threading\nfrom camera.camera import Cameras\nfrom calibration.calibration import Calibration, CalibType_XxX_CamelSnakePep8_PreserveName_XxX_4\nimport time\n\n\n# Create and intialize cameras\nwalleye_data.cameras = Cameras()\n\nfrom web_interface.web_interface import (\n    cam_buffers,\n    socketio,\n    app,\n    visualization_buffers\n)  # After walleye_data.cameras is set\n\nweb_server = threading.Thread(\n    target=lambda: socketio.run(\n        app,\n        host=\"0.0.0.0\",\n        port=5800,\n        debug=False,\n        use_reloader=False,\n        log_output=False,\n    ),\n    # daemon=True,\n)\ntry:\n    # Start the web server\n    web_server.start()\n\n    logging.getLogger(\"geventwebsocket.handler\").setLevel(logging.ERROR)\n    logging.getLogger(\"socketio\").setLevel(logging.ERROR)\n    logging.getLogger(\"socketio.server\").setLevel(logging.ERROR)\n    logging.getLogger(\"engineio\").setLevel(logging.ERROR)\n\n\n    logger.info(\"Web server ready\")\n\n    images = {}\n    calibrators = {}\n\n    # Create network tables publisher and AprilTag Processor\n    pose_estimator = Processor(walleye_data.tag_size)\n    # Publisher already created during construction of walleye_data\n    # walleye_data.make_publisher(walleye_data.team_number, walleye_data.table_name)\n    walleye_data.current_state = States.PROCESSING\n\n    logger.info(\"Starting main loop\")\n\n    last_loop_time = time.time()\n\n    # Main loop (Runs everything)\n    while True:\n        # Calculate loop time\n        curr_time = time.time()\n        walleye_data.loop_time = round(curr_time - last_loop_time, 3)\n        last_loop_time = curr_time\n\n        # State changes\n        # Pre-Calibration\n        if walleye_data.current_state == States.BEGIN_CALIBRATION:\n            logger.info(\"Beginning calibration\")\n\n            # Prepare a calibration object for the camera that is being calibrated with pre-set data\n            # only if cal object does not exist yet\n            if (\n                walleye_data.camera_in_calibration not in calibrators\n                or calibrators[walleye_data.camera_in_calibration] is None\n            ):\n                calibrators[walleye_data.camera_in_calibration] = Calibration(\n                    walleye_data.cal_delay,\n                    walleye_data.board_dims,\n                    walleye_data.camera_in_calibration,\n                    calibration_image_folder(walleye_data.camera_in_calibration),\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].resolution,\n                )\n            walleye_data.current_state = States.CALIBRATION_CAPTURE\n\n        # Take calibration images\n        elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n            # Read in frames\n            ret, img = walleye_data.cameras.info[\n                walleye_data.camera_in_calibration\n            ].cam.read()\n\n            if not ret:\n                logger.error(\n                    f\"Failed to capture image: {walleye_data.camera_in_calibration}\"\n                )\n            else:\n                # Process frames with the calibration object created prior\n                returned, used, path_saved = calibrators[\n                    walleye_data.camera_in_calibration\n                ].process_frame(img)\n\n                # If the image is a part of the accepted images save it\n                if used:\n                    walleye_data.cal_img_paths.append(path_saved)\n\n                # Keep a buffer with the images\n                cam_buffers[walleye_data.camera_in_calibration].update(returned)\n\n        # Finished Calibration, generate calibration\n        elif walleye_data.current_state == States.GENERATE_CALIBRATION:\n            # Get file path for the calibration to be saved\n            walleye_data.cameras.info[\n                walleye_data.camera_in_calibration\n            ].calibrationPath = calibration_path_by_cam(\n                walleye_data.camera_in_calibration,\n                walleye_data.cameras.info[walleye_data.camera_in_calibration].resolution,\n            )\n\n            if calibrators[walleye_data.camera_in_calibration] is not None:\n                # Generate a calibration file to the file path\n                has_generated = calibrators[\n                    walleye_data.camera_in_calibration\n                ].generate_calibration(\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].calibration_path\n                )\n\n                if has_generated:\n                    # Get reproj error\n                    walleye_data.reprojection_error = calibrators[\n                        walleye_data.camera_in_calibration\n                    ].get_reprojection_error()\n\n                    # Set the cameras calibration, save off the file path, and\n                    # go to idle\n                    walleye_data.cameras.setCalibration(\n                        walleye_data.camera_in_calibration,\n                        calibrators[walleye_data.camera_in_calibration].calibrationData[\n                            \"K\"\n                        ],\n                        calibrators[walleye_data.camera_in_calibration].calibrationData[\n                            \"dist\"\n                        ],\n                    )\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].calibrationPath = calibration_path_by_cam(\n                        walleye_data.camera_in_calibration,\n                        walleye_data.cameras.info[\n                            walleye_data.camera_in_calibration\n                        ].resolution,\n                    )\n                else:\n                    walleye_data.status = \"Could not generate calibration\"\n            else:\n                walleye_data.status = \"Calibrator for current calibration camera is None\"\n            walleye_data.current_state = States.IDLE\n            calibrators[walleye_data.camera_in_calibration] = None\n\n        # AprilTag processing state\n        elif walleye_data.current_state == States.PROCESSING:\n            # Set tag size, grab camera frames, and grab image timestamp\n            pose_estimator.set_tag_size(walleye_data.tag_size)\n\n            image_time = walleye_data.robot_publisher.get_time() \n\n            connections, images, delay = walleye_data.cameras.get_frames_for_processing()\n\n            for idx, val in enumerate(connections.values()):\n                if not val and walleye_data.robot_publisher.getConnectionValue(idx):\n                    logger.info(\"Camera disconnected\")\n\n                walleye_data.robot_publisher.setConnectionValue_XxX_CamelSnakePep8_PreserveName_XxX_6(idx, val)\n\n            # Use the pose_estimator class to find the pose, tags, and ambiguity\n            poses, tags, ambig = pose_estimator.get_pose(\n                images.values(),\n                walleye_data.cameras.list_k(),\n                walleye_data.cameras.list_d(),\n            )\n\n            # Publish camera number, timestamp, poses, tags, ambiguity and increase the update number\n            # logger.info(f\"Poses at {image_time}: {poses}\")\n\n            for i in range(len(poses)):\n                if poses[i][0].X() < 2000:\n                    walleye_data.robot_publisher.publish(\n                        i, image_time - delay[i], poses[i], tags[i], ambig[i]\n                    )\n\n            # Update the pose visualization\n            for i, (identifier, img) in enumerate(images.items()):\n                if i >= len(poses):\n                    break\n                cam_buffers[identifier].update(img)\n                walleye_data.set_pose(identifier, poses[i][0])\n                if walleye_data.visualizing_poses:\n                    visualization_buffers[identifier].update(\n                        (poses[i][0].X(), poses[i][0].Y(), poses[i][0].Z()), tags[i][1:]\n                    )\n\n        # Ends the WallEye program through the web interface\n        elif walleye_data.current_state == States.SHUTDOWN:\n            logger.info(\"Shutting down\")\n            logging.shutdown()\n            socketio.stop()\n            break\n\n        # Update cameras no matter what state\n        if walleye_data.current_state != States.PROCESSING:\n            for camera_info in walleye_data.cameras.info.values():\n                if (\n                    camera_info.identifier == walleye_data.camera_in_calibration\n                    and walleye_data.current_state in CALIBRATION_STATES\n                ):\n                    continue\n\n                ret, img = camera_info.cam.read()\n\n                cam_buffers[camera_info.identifier].update(img)\n\nexcept Exception as e:\n    # Something bad happened\n    logging.critical(e, exc_info=True)\n    logger.info(\"Shutting down\")\n    socketio.stop()\n    logging.shutdown()\n", "import sys\nimport logging\nfrom logging.handlers import RotatingFileHandler\nfrom directory import calibration_image_folder, calibration_path_by_cam, LOG\n\n# Create logger and set settings\nLOG_FORMAT = \"[%(asctime)s - %(levelname)s - %(filename)s:%(lineno)s - %(funcName)s()]  %(message)s\"\nlogging.basicConfig(\n    format=LOG_FORMAT,\n    handlers=[\n        logging.StreamHandler(sys.stdout),\n        RotatingFileHandler(LOG, maxBytes_XxX_CamelSnakePep8_PreserveName_XxX_2=1024 * 1024, backupCount_XxX_CamelSnakePep8_PreserveName_XxX_3=5),\n    ],\n    datefmt=\"%d-%b-%y %H:%M:%S\",\n    level=logging.INFO,\n)\n\nlogger = logging.getLogger(__name__)\n\nlogger.info(\"----------- Starting Up -----------\")\n\nfrom state import walleye_data, States, CALIBRATION_STATES\nfrom processing.processing import Processor\nimport threading\nfrom camera.camera import Cameras\nfrom calibration.calibration import Calibration, CalibType_XxX_CamelSnakePep8_PreserveName_XxX_4\nimport time\n\n\n# Create and intialize cameras\nwalleye_data.cameras = Cameras()\n\nfrom web_interface.web_interface import (\n    cam_buffers,\n    socketio,\n    app,\n    visualization_buffers\n)  # After walleye_data.cameras is set\n\nweb_server = threading.Thread(\n    target=lambda: socketio.run(\n        app,\n        host=\"0.0.0.0\",\n        port=5800,\n        debug=False,\n        use_reloader=False,\n        log_output=False,\n    ),\n    # daemon=True,\n)\ntry:\n    # Start the web server\n    web_server.start()\n\n    logging.getLogger(\"geventwebsocket.handler\").setLevel(logging.ERROR)\n    logging.getLogger(\"socketio\").setLevel(logging.ERROR)\n    logging.getLogger(\"socketio.server\").setLevel(logging.ERROR)\n    logging.getLogger(\"engineio\").setLevel(logging.ERROR)\n\n\n    logger.info(\"Web server ready\")\n\n    images = {}\n    calibrators = {}\n\n    # Create network tables publisher and AprilTag Processor\n    pose_estimator = Processor(walleye_data.tag_size)\n    # Publisher already created during construction of walleye_data\n    # walleye_data.make_publisher(walleye_data.team_number, walleye_data.table_name)\n    walleye_data.current_state = States.PROCESSING\n\n    logger.info(\"Starting main loop\")\n\n    last_loop_time = time.time()\n\n    # Main loop (Runs everything)\n    while True:\n        # Calculate loop time\n        curr_time = time.time()\n        walleye_data.loop_time = round(curr_time - last_loop_time, 3)\n        last_loop_time = curr_time\n\n        # State changes\n        # Pre-Calibration\n        if walleye_data.current_state == States.BEGIN_CALIBRATION:\n            logger.info(\"Beginning calibration\")\n\n            # Prepare a calibration object for the camera that is being calibrated with pre-set data\n            # only if cal object does not exist yet\n            if (\n                walleye_data.camera_in_calibration not in calibrators\n                or calibrators[walleye_data.camera_in_calibration] is None\n            ):\n                calibrators[walleye_data.camera_in_calibration] = Calibration(\n                    walleye_data.cal_delay,\n                    walleye_data.board_dims,\n                    walleye_data.camera_in_calibration,\n                    calibration_image_folder(walleye_data.camera_in_calibration),\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].resolution,\n                )\n            walleye_data.current_state = States.CALIBRATION_CAPTURE\n\n        # Take calibration images\n        elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n            # Read in frames\n            ret, img = walleye_data.cameras.info[\n                walleye_data.camera_in_calibration\n            ].cam.read()\n\n            if not ret:\n                logger.error(\n                    f\"Failed to capture image: {walleye_data.camera_in_calibration}\"\n                )\n            else:\n                # Process frames with the calibration object created prior\n                returned, used, path_saved = calibrators[\n                    walleye_data.camera_in_calibration\n                ].process_frame(img)\n\n                # If the image is a part of the accepted images save it\n                if used:\n                    walleye_data.cal_img_paths.append(path_saved)\n\n                # Keep a buffer with the images\n                cam_buffers[walleye_data.camera_in_calibration].update(returned)\n\n        # Finished Calibration, generate calibration\n        elif walleye_data.current_state == States.GENERATE_CALIBRATION:\n            # Get file path for the calibration to be saved\n            walleye_data.cameras.info[\n                walleye_data.camera_in_calibration\n            ].calibrationPath = calibration_path_by_cam(\n                walleye_data.camera_in_calibration,\n                walleye_data.cameras.info[walleye_data.camera_in_calibration].resolution,\n            )\n\n            if calibrators[walleye_data.camera_in_calibration] is not None:\n                # Generate a calibration file to the file path\n                has_generated = calibrators[\n                    walleye_data.camera_in_calibration\n                ].generate_calibration(\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].calibration_path\n                )\n\n                if has_generated:\n                    # Get reproj error\n                    walleye_data.reprojection_error = calibrators[\n                        walleye_data.camera_in_calibration\n                    ].get_reprojection_error()\n\n                    # Set the cameras calibration, save off the file path, and\n                    # go to idle\n                    walleye_data.cameras.setCalibration(\n                        walleye_data.camera_in_calibration,\n                        calibrators[walleye_data.camera_in_calibration].calibrationData[\n                            \"K\"\n                        ],\n                        calibrators[walleye_data.camera_in_calibration].calibrationData[\n                            \"dist\"\n                        ],\n                    )\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].calibrationPath = calibration_path_by_cam(\n                        walleye_data.camera_in_calibration,\n                        walleye_data.cameras.info[\n                            walleye_data.camera_in_calibration\n                        ].resolution,\n                    )\n                else:\n                    walleye_data.status = \"Could not generate calibration\"\n            else:\n                walleye_data.status = \"Calibrator for current calibration camera is None\"\n            walleye_data.current_state = States.IDLE\n            calibrators[walleye_data.camera_in_calibration] = None\n\n        # AprilTag processing state\n        elif walleye_data.current_state == States.PROCESSING:\n            # Set tag size, grab camera frames, and grab image timestamp\n            pose_estimator.set_tag_size(walleye_data.tag_size)\n\n            image_time = walleye_data.robot_publisher.get_time() \n\n            connections, images, delay = walleye_data.cameras.get_frames_for_processing()\n\n            for idx, val in enumerate(connections.values()):\n                if not val and walleye_data.robot_publisher.getConnectionValue(idx):\n                    logger.info(\"Camera disconnected\")\n\n                walleye_data.robot_publisher.setConnectionValue(idx, val)\n\n            # Use the pose_estimator class to find the pose, tags, and ambiguity\n            poses, tags, ambig = pose_estimator.get_pose(\n                images.values(),\n                walleye_data.cameras.list_k(),\n                walleye_data.cameras.list_d(),\n            )\n\n            # Publish camera number, timestamp, poses, tags, ambiguity and increase the update number\n            # logger.info(f\"Poses at {image_time}: {poses}\")\n\n            for i in range(len(poses)):\n                if poses[i][0].X() < 2000:\n                    walleye_data.robot_publisher.publish(\n                        i, image_time - delay[i], poses[i], tags[i], ambig[i]\n                    )\n\n            # Update the pose visualization\n            for i, (identifier, img) in enumerate(images.items()):\n                if i >= len(poses):\n                    break\n                cam_buffers[identifier].update(img)\n                walleye_data.set_pose(identifier, poses[i][0])\n                if walleye_data.visualizing_poses:\n                    visualization_buffers[identifier].update(\n                        (poses[i][0].X(), poses[i][0].Y(), poses[i][0].Z()), tags[i][1:]\n                    )\n\n        # Ends the WallEye program through the web interface\n        elif walleye_data.current_state == States.SHUTDOWN:\n            logger.info(\"Shutting down\")\n            logging.shutdown()\n            socketio.stop()\n            break\n\n        # Update cameras no matter what state\n        if walleye_data.current_state != States.PROCESSING:\n            for camera_info in walleye_data.cameras.info.values():\n                if (\n                    camera_info.identifier == walleye_data.camera_in_calibration\n                    and walleye_data.current_state in CALIBRATION_STATES\n                ):\n                    continue\n\n                ret, img = camera_info.cam.read()\n\n                cam_buffers[camera_info.identifier].update(img)\n\nexcept Exception as e:\n    # Something bad happened\n    logging.critical(e, exc_info=True)\n    logger.info(\"Shutting down\")\n    socketio.stop()\n    logging.shutdown()\n"]], ["ChangeContents", ["publisher/network_table_publisher.py", "import ntcore\nimport logging\n\n\nclass NetworkIO:\n    logger = logging.getLogger(__name__)\n\n    # Create a Network Tables Client with given info\n    def __init__(self, test, team, table_name, num_cams):\n        # Grab the default network table instance and grab the table name\n        self.inst = ntcore.NetworkTableInstance.getDefault()\n        self.table = self.inst.getTable(table_name)\n\n        # Start the WallEye_Client and set server depending on testing\n        self.inst.startClient4(\"WallEye_Client\")\n        self.update_num = []\n        self.connection = []\n        self.pose1_sub = []\n        self.pose2_sub = []\n        self.timestamp_sub = []\n        self.ambiguity_sub = []\n        self.tag_sub = []\n        if test:\n            self.inst.setServer(\"127.0.0.1\", 5810)\n        else:\n            self.inst.setServerTeam(team)\n\n        # Set all the publishers and update publishers\n        self.publishers = []\n\n        # Update publisher\n        self.publish_update = []\n\n        # image publisher ie has recieved a new image\n        self.publish_connection = []\n\n        # Pose publisher\n        for index in range(num_cams):\n            self.publishers.append(self.table.getSubTable(\"Result\" + str(index)))\n\n            self.pose1_sub.append(\n                self.publishers[index]\n                .getDoubleArrayTopic(\"Pose1\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.timestamp_sub.append(\n                self.publishers[index]\n                .getDoubleTopic(\"timestamp\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.pose2_sub.append(\n                self.publishers[index]\n                .getDoubleArrayTopic(\"Pose2\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.ambiguity_sub.append(\n                self.publishers[index]\n                .getDoubleTopic(\"ambiguity\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.tag_sub.append(\n                self.publishers[index]\n                .getIntegerArrayTopic(\"tags\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.publish_update.append(\n                self.table.getIntegerTopic(\"Update\" + str(index)).publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n            self.publish_connection.append(\n                self.table.getBooleanTopic(\"Connected\" + str(index)).publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.update_num.append(0)\n            self.connection.append(False)\n\n    def get_time(self):\n        return ntcore._now()\n\n    def set_table(self, name):\n        self.table = self.inst.getTable(name)\n\n    # Publishes the supplied pose information in the corresponding publisher\n    def publish(self, index, time, pose, tags, ambig):\n        pose1 = pose[0]\n        pose2 = pose[1]\n        t1 = pose1.translation()\n        r1 = pose1.rotation()\n        t2 = pose2.translation()\n        r2 = pose2.rotation()\n\n        self.pose1_sub[index].set([t1.X(), t1.Y(), t1.Z(), r1.X(), r1.Y(), r1.Z()])\n        self.pose2_sub[index].set([t2.X(), t2.Y(), t2.Z(), r2.X(), r2.Y(), r2.Z()])\n        self.ambiguity_sub[index].set(ambig)\n        self.tag_sub[index].set(tags)\n        self.timestamp_sub[index].set(ntcore._now() - time)\n\n        self.update_num[index] += 1\n        self.publish_update[index].set(self.update_num[index])\n\n    # Publish a new update number\n    def increase_update_num(self):\n        self.update_num += 1\n        self.publish_update.set(self.update_num)\n\n    def setConnectionValue_XxX_CamelSnakePep8_PreserveName_XxX_6(self, index, val):\n        self.connection[index] = val\n        self.publish_connection[index].set(val)\n\n    def getConnectionValue(self, index):\n        return self.connection[index]\n\n    def destroy(self):\n        self.inst.stopClient()\n\n    def update_team(self, num):\n        self.inst.setServerTeam(num)\n\n    def update_name(self, name):\n        self.inst.getTable(name)\n", "import ntcore\nimport logging\n\n\nclass NetworkIO:\n    logger = logging.getLogger(__name__)\n\n    # Create a Network Tables Client with given info\n    def __init__(self, test, team, table_name, num_cams):\n        # Grab the default network table instance and grab the table name\n        self.inst = ntcore.NetworkTableInstance.getDefault()\n        self.table = self.inst.getTable(table_name)\n\n        # Start the WallEye_Client and set server depending on testing\n        self.inst.startClient4(\"WallEye_Client\")\n        self.update_num = []\n        self.connection = []\n        self.pose1_sub = []\n        self.pose2_sub = []\n        self.timestamp_sub = []\n        self.ambiguity_sub = []\n        self.tag_sub = []\n        if test:\n            self.inst.setServer(\"127.0.0.1\", 5810)\n        else:\n            self.inst.setServerTeam(team)\n\n        # Set all the publishers and update publishers\n        self.publishers = []\n\n        # Update publisher\n        self.publish_update = []\n\n        # image publisher ie has recieved a new image\n        self.publish_connection = []\n\n        # Pose publisher\n        for index in range(num_cams):\n            self.publishers.append(self.table.getSubTable(\"Result\" + str(index)))\n\n            self.pose1_sub.append(\n                self.publishers[index]\n                .getDoubleArrayTopic(\"Pose1\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.timestamp_sub.append(\n                self.publishers[index]\n                .getDoubleTopic(\"timestamp\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.pose2_sub.append(\n                self.publishers[index]\n                .getDoubleArrayTopic(\"Pose2\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.ambiguity_sub.append(\n                self.publishers[index]\n                .getDoubleTopic(\"ambiguity\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.tag_sub.append(\n                self.publishers[index]\n                .getIntegerArrayTopic(\"tags\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.publish_update.append(\n                self.table.getIntegerTopic(\"Update\" + str(index)).publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n            self.publish_connection.append(\n                self.table.getBooleanTopic(\"Connected\" + str(index)).publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.update_num.append(0)\n            self.connection.append(False)\n\n    def get_time(self):\n        return ntcore._now()\n\n    def set_table(self, name):\n        self.table = self.inst.getTable(name)\n\n    # Publishes the supplied pose information in the corresponding publisher\n    def publish(self, index, time, pose, tags, ambig):\n        pose1 = pose[0]\n        pose2 = pose[1]\n        t1 = pose1.translation()\n        r1 = pose1.rotation()\n        t2 = pose2.translation()\n        r2 = pose2.rotation()\n\n        self.pose1_sub[index].set([t1.X(), t1.Y(), t1.Z(), r1.X(), r1.Y(), r1.Z()])\n        self.pose2_sub[index].set([t2.X(), t2.Y(), t2.Z(), r2.X(), r2.Y(), r2.Z()])\n        self.ambiguity_sub[index].set(ambig)\n        self.tag_sub[index].set(tags)\n        self.timestamp_sub[index].set(ntcore._now() - time)\n\n        self.update_num[index] += 1\n        self.publish_update[index].set(self.update_num[index])\n\n    # Publish a new update number\n    def increase_update_num(self):\n        self.update_num += 1\n        self.publish_update.set(self.update_num)\n\n    def setConnectionValue(self, index, val):\n        self.connection[index] = val\n        self.publish_connection[index].set(val)\n\n    def getConnectionValue(self, index):\n        return self.connection[index]\n\n    def destroy(self):\n        self.inst.stopClient()\n\n    def update_team(self, num):\n        self.inst.setServerTeam(num)\n\n    def update_name(self, name):\n        self.inst.getTable(name)\n"]]], 1715213097.1153727]], ["ChangeSet", ["Renaming <getConnectionValue> to <getConnectionValue_XxX_CamelSnakePep8_PreserveName_XxX_7>", [["ChangeContents", ["init.py", "import sys\nimport logging\nfrom logging.handlers import RotatingFileHandler\nfrom directory import calibration_image_folder, calibration_path_by_cam, LOG\n\n# Create logger and set settings\nLOG_FORMAT = \"[%(asctime)s - %(levelname)s - %(filename)s:%(lineno)s - %(funcName)s()]  %(message)s\"\nlogging.basicConfig(\n    format=LOG_FORMAT,\n    handlers=[\n        logging.StreamHandler(sys.stdout),\n        RotatingFileHandler(LOG, maxBytes_XxX_CamelSnakePep8_PreserveName_XxX_2=1024 * 1024, backupCount_XxX_CamelSnakePep8_PreserveName_XxX_3=5),\n    ],\n    datefmt=\"%d-%b-%y %H:%M:%S\",\n    level=logging.INFO,\n)\n\nlogger = logging.getLogger(__name__)\n\nlogger.info(\"----------- Starting Up -----------\")\n\nfrom state import walleye_data, States, CALIBRATION_STATES\nfrom processing.processing import Processor\nimport threading\nfrom camera.camera import Cameras\nfrom calibration.calibration import Calibration, CalibType_XxX_CamelSnakePep8_PreserveName_XxX_4\nimport time\n\n\n# Create and intialize cameras\nwalleye_data.cameras = Cameras()\n\nfrom web_interface.web_interface import (\n    cam_buffers,\n    socketio,\n    app,\n    visualization_buffers\n)  # After walleye_data.cameras is set\n\nweb_server = threading.Thread(\n    target=lambda: socketio.run(\n        app,\n        host=\"0.0.0.0\",\n        port=5800,\n        debug=False,\n        use_reloader=False,\n        log_output=False,\n    ),\n    # daemon=True,\n)\ntry:\n    # Start the web server\n    web_server.start()\n\n    logging.getLogger(\"geventwebsocket.handler\").setLevel(logging.ERROR)\n    logging.getLogger(\"socketio\").setLevel(logging.ERROR)\n    logging.getLogger(\"socketio.server\").setLevel(logging.ERROR)\n    logging.getLogger(\"engineio\").setLevel(logging.ERROR)\n\n\n    logger.info(\"Web server ready\")\n\n    images = {}\n    calibrators = {}\n\n    # Create network tables publisher and AprilTag Processor\n    pose_estimator = Processor(walleye_data.tag_size)\n    # Publisher already created during construction of walleye_data\n    # walleye_data.make_publisher(walleye_data.team_number, walleye_data.table_name)\n    walleye_data.current_state = States.PROCESSING\n\n    logger.info(\"Starting main loop\")\n\n    last_loop_time = time.time()\n\n    # Main loop (Runs everything)\n    while True:\n        # Calculate loop time\n        curr_time = time.time()\n        walleye_data.loop_time = round(curr_time - last_loop_time, 3)\n        last_loop_time = curr_time\n\n        # State changes\n        # Pre-Calibration\n        if walleye_data.current_state == States.BEGIN_CALIBRATION:\n            logger.info(\"Beginning calibration\")\n\n            # Prepare a calibration object for the camera that is being calibrated with pre-set data\n            # only if cal object does not exist yet\n            if (\n                walleye_data.camera_in_calibration not in calibrators\n                or calibrators[walleye_data.camera_in_calibration] is None\n            ):\n                calibrators[walleye_data.camera_in_calibration] = Calibration(\n                    walleye_data.cal_delay,\n                    walleye_data.board_dims,\n                    walleye_data.camera_in_calibration,\n                    calibration_image_folder(walleye_data.camera_in_calibration),\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].resolution,\n                )\n            walleye_data.current_state = States.CALIBRATION_CAPTURE\n\n        # Take calibration images\n        elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n            # Read in frames\n            ret, img = walleye_data.cameras.info[\n                walleye_data.camera_in_calibration\n            ].cam.read()\n\n            if not ret:\n                logger.error(\n                    f\"Failed to capture image: {walleye_data.camera_in_calibration}\"\n                )\n            else:\n                # Process frames with the calibration object created prior\n                returned, used, path_saved = calibrators[\n                    walleye_data.camera_in_calibration\n                ].process_frame(img)\n\n                # If the image is a part of the accepted images save it\n                if used:\n                    walleye_data.cal_img_paths.append(path_saved)\n\n                # Keep a buffer with the images\n                cam_buffers[walleye_data.camera_in_calibration].update(returned)\n\n        # Finished Calibration, generate calibration\n        elif walleye_data.current_state == States.GENERATE_CALIBRATION:\n            # Get file path for the calibration to be saved\n            walleye_data.cameras.info[\n                walleye_data.camera_in_calibration\n            ].calibrationPath = calibration_path_by_cam(\n                walleye_data.camera_in_calibration,\n                walleye_data.cameras.info[walleye_data.camera_in_calibration].resolution,\n            )\n\n            if calibrators[walleye_data.camera_in_calibration] is not None:\n                # Generate a calibration file to the file path\n                has_generated = calibrators[\n                    walleye_data.camera_in_calibration\n                ].generate_calibration(\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].calibration_path\n                )\n\n                if has_generated:\n                    # Get reproj error\n                    walleye_data.reprojection_error = calibrators[\n                        walleye_data.camera_in_calibration\n                    ].get_reprojection_error()\n\n                    # Set the cameras calibration, save off the file path, and\n                    # go to idle\n                    walleye_data.cameras.setCalibration(\n                        walleye_data.camera_in_calibration,\n                        calibrators[walleye_data.camera_in_calibration].calibrationData[\n                            \"K\"\n                        ],\n                        calibrators[walleye_data.camera_in_calibration].calibrationData[\n                            \"dist\"\n                        ],\n                    )\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].calibrationPath = calibration_path_by_cam(\n                        walleye_data.camera_in_calibration,\n                        walleye_data.cameras.info[\n                            walleye_data.camera_in_calibration\n                        ].resolution,\n                    )\n                else:\n                    walleye_data.status = \"Could not generate calibration\"\n            else:\n                walleye_data.status = \"Calibrator for current calibration camera is None\"\n            walleye_data.current_state = States.IDLE\n            calibrators[walleye_data.camera_in_calibration] = None\n\n        # AprilTag processing state\n        elif walleye_data.current_state == States.PROCESSING:\n            # Set tag size, grab camera frames, and grab image timestamp\n            pose_estimator.set_tag_size(walleye_data.tag_size)\n\n            image_time = walleye_data.robot_publisher.get_time() \n\n            connections, images, delay = walleye_data.cameras.get_frames_for_processing()\n\n            for idx, val in enumerate(connections.values()):\n                if not val and walleye_data.robot_publisher.getConnectionValue_XxX_CamelSnakePep8_PreserveName_XxX_7(idx):\n                    logger.info(\"Camera disconnected\")\n\n                walleye_data.robot_publisher.setConnectionValue_XxX_CamelSnakePep8_PreserveName_XxX_6(idx, val)\n\n            # Use the pose_estimator class to find the pose, tags, and ambiguity\n            poses, tags, ambig = pose_estimator.get_pose(\n                images.values(),\n                walleye_data.cameras.list_k(),\n                walleye_data.cameras.list_d(),\n            )\n\n            # Publish camera number, timestamp, poses, tags, ambiguity and increase the update number\n            # logger.info(f\"Poses at {image_time}: {poses}\")\n\n            for i in range(len(poses)):\n                if poses[i][0].X() < 2000:\n                    walleye_data.robot_publisher.publish(\n                        i, image_time - delay[i], poses[i], tags[i], ambig[i]\n                    )\n\n            # Update the pose visualization\n            for i, (identifier, img) in enumerate(images.items()):\n                if i >= len(poses):\n                    break\n                cam_buffers[identifier].update(img)\n                walleye_data.set_pose(identifier, poses[i][0])\n                if walleye_data.visualizing_poses:\n                    visualization_buffers[identifier].update(\n                        (poses[i][0].X(), poses[i][0].Y(), poses[i][0].Z()), tags[i][1:]\n                    )\n\n        # Ends the WallEye program through the web interface\n        elif walleye_data.current_state == States.SHUTDOWN:\n            logger.info(\"Shutting down\")\n            logging.shutdown()\n            socketio.stop()\n            break\n\n        # Update cameras no matter what state\n        if walleye_data.current_state != States.PROCESSING:\n            for camera_info in walleye_data.cameras.info.values():\n                if (\n                    camera_info.identifier == walleye_data.camera_in_calibration\n                    and walleye_data.current_state in CALIBRATION_STATES\n                ):\n                    continue\n\n                ret, img = camera_info.cam.read()\n\n                cam_buffers[camera_info.identifier].update(img)\n\nexcept Exception as e:\n    # Something bad happened\n    logging.critical(e, exc_info=True)\n    logger.info(\"Shutting down\")\n    socketio.stop()\n    logging.shutdown()\n", "import sys\nimport logging\nfrom logging.handlers import RotatingFileHandler\nfrom directory import calibration_image_folder, calibration_path_by_cam, LOG\n\n# Create logger and set settings\nLOG_FORMAT = \"[%(asctime)s - %(levelname)s - %(filename)s:%(lineno)s - %(funcName)s()]  %(message)s\"\nlogging.basicConfig(\n    format=LOG_FORMAT,\n    handlers=[\n        logging.StreamHandler(sys.stdout),\n        RotatingFileHandler(LOG, maxBytes_XxX_CamelSnakePep8_PreserveName_XxX_2=1024 * 1024, backupCount_XxX_CamelSnakePep8_PreserveName_XxX_3=5),\n    ],\n    datefmt=\"%d-%b-%y %H:%M:%S\",\n    level=logging.INFO,\n)\n\nlogger = logging.getLogger(__name__)\n\nlogger.info(\"----------- Starting Up -----------\")\n\nfrom state import walleye_data, States, CALIBRATION_STATES\nfrom processing.processing import Processor\nimport threading\nfrom camera.camera import Cameras\nfrom calibration.calibration import Calibration, CalibType_XxX_CamelSnakePep8_PreserveName_XxX_4\nimport time\n\n\n# Create and intialize cameras\nwalleye_data.cameras = Cameras()\n\nfrom web_interface.web_interface import (\n    cam_buffers,\n    socketio,\n    app,\n    visualization_buffers\n)  # After walleye_data.cameras is set\n\nweb_server = threading.Thread(\n    target=lambda: socketio.run(\n        app,\n        host=\"0.0.0.0\",\n        port=5800,\n        debug=False,\n        use_reloader=False,\n        log_output=False,\n    ),\n    # daemon=True,\n)\ntry:\n    # Start the web server\n    web_server.start()\n\n    logging.getLogger(\"geventwebsocket.handler\").setLevel(logging.ERROR)\n    logging.getLogger(\"socketio\").setLevel(logging.ERROR)\n    logging.getLogger(\"socketio.server\").setLevel(logging.ERROR)\n    logging.getLogger(\"engineio\").setLevel(logging.ERROR)\n\n\n    logger.info(\"Web server ready\")\n\n    images = {}\n    calibrators = {}\n\n    # Create network tables publisher and AprilTag Processor\n    pose_estimator = Processor(walleye_data.tag_size)\n    # Publisher already created during construction of walleye_data\n    # walleye_data.make_publisher(walleye_data.team_number, walleye_data.table_name)\n    walleye_data.current_state = States.PROCESSING\n\n    logger.info(\"Starting main loop\")\n\n    last_loop_time = time.time()\n\n    # Main loop (Runs everything)\n    while True:\n        # Calculate loop time\n        curr_time = time.time()\n        walleye_data.loop_time = round(curr_time - last_loop_time, 3)\n        last_loop_time = curr_time\n\n        # State changes\n        # Pre-Calibration\n        if walleye_data.current_state == States.BEGIN_CALIBRATION:\n            logger.info(\"Beginning calibration\")\n\n            # Prepare a calibration object for the camera that is being calibrated with pre-set data\n            # only if cal object does not exist yet\n            if (\n                walleye_data.camera_in_calibration not in calibrators\n                or calibrators[walleye_data.camera_in_calibration] is None\n            ):\n                calibrators[walleye_data.camera_in_calibration] = Calibration(\n                    walleye_data.cal_delay,\n                    walleye_data.board_dims,\n                    walleye_data.camera_in_calibration,\n                    calibration_image_folder(walleye_data.camera_in_calibration),\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].resolution,\n                )\n            walleye_data.current_state = States.CALIBRATION_CAPTURE\n\n        # Take calibration images\n        elif walleye_data.current_state == States.CALIBRATION_CAPTURE:\n            # Read in frames\n            ret, img = walleye_data.cameras.info[\n                walleye_data.camera_in_calibration\n            ].cam.read()\n\n            if not ret:\n                logger.error(\n                    f\"Failed to capture image: {walleye_data.camera_in_calibration}\"\n                )\n            else:\n                # Process frames with the calibration object created prior\n                returned, used, path_saved = calibrators[\n                    walleye_data.camera_in_calibration\n                ].process_frame(img)\n\n                # If the image is a part of the accepted images save it\n                if used:\n                    walleye_data.cal_img_paths.append(path_saved)\n\n                # Keep a buffer with the images\n                cam_buffers[walleye_data.camera_in_calibration].update(returned)\n\n        # Finished Calibration, generate calibration\n        elif walleye_data.current_state == States.GENERATE_CALIBRATION:\n            # Get file path for the calibration to be saved\n            walleye_data.cameras.info[\n                walleye_data.camera_in_calibration\n            ].calibrationPath = calibration_path_by_cam(\n                walleye_data.camera_in_calibration,\n                walleye_data.cameras.info[walleye_data.camera_in_calibration].resolution,\n            )\n\n            if calibrators[walleye_data.camera_in_calibration] is not None:\n                # Generate a calibration file to the file path\n                has_generated = calibrators[\n                    walleye_data.camera_in_calibration\n                ].generate_calibration(\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].calibration_path\n                )\n\n                if has_generated:\n                    # Get reproj error\n                    walleye_data.reprojection_error = calibrators[\n                        walleye_data.camera_in_calibration\n                    ].get_reprojection_error()\n\n                    # Set the cameras calibration, save off the file path, and\n                    # go to idle\n                    walleye_data.cameras.setCalibration(\n                        walleye_data.camera_in_calibration,\n                        calibrators[walleye_data.camera_in_calibration].calibrationData[\n                            \"K\"\n                        ],\n                        calibrators[walleye_data.camera_in_calibration].calibrationData[\n                            \"dist\"\n                        ],\n                    )\n                    walleye_data.cameras.info[\n                        walleye_data.camera_in_calibration\n                    ].calibrationPath = calibration_path_by_cam(\n                        walleye_data.camera_in_calibration,\n                        walleye_data.cameras.info[\n                            walleye_data.camera_in_calibration\n                        ].resolution,\n                    )\n                else:\n                    walleye_data.status = \"Could not generate calibration\"\n            else:\n                walleye_data.status = \"Calibrator for current calibration camera is None\"\n            walleye_data.current_state = States.IDLE\n            calibrators[walleye_data.camera_in_calibration] = None\n\n        # AprilTag processing state\n        elif walleye_data.current_state == States.PROCESSING:\n            # Set tag size, grab camera frames, and grab image timestamp\n            pose_estimator.set_tag_size(walleye_data.tag_size)\n\n            image_time = walleye_data.robot_publisher.get_time() \n\n            connections, images, delay = walleye_data.cameras.get_frames_for_processing()\n\n            for idx, val in enumerate(connections.values()):\n                if not val and walleye_data.robot_publisher.getConnectionValue(idx):\n                    logger.info(\"Camera disconnected\")\n\n                walleye_data.robot_publisher.setConnectionValue_XxX_CamelSnakePep8_PreserveName_XxX_6(idx, val)\n\n            # Use the pose_estimator class to find the pose, tags, and ambiguity\n            poses, tags, ambig = pose_estimator.get_pose(\n                images.values(),\n                walleye_data.cameras.list_k(),\n                walleye_data.cameras.list_d(),\n            )\n\n            # Publish camera number, timestamp, poses, tags, ambiguity and increase the update number\n            # logger.info(f\"Poses at {image_time}: {poses}\")\n\n            for i in range(len(poses)):\n                if poses[i][0].X() < 2000:\n                    walleye_data.robot_publisher.publish(\n                        i, image_time - delay[i], poses[i], tags[i], ambig[i]\n                    )\n\n            # Update the pose visualization\n            for i, (identifier, img) in enumerate(images.items()):\n                if i >= len(poses):\n                    break\n                cam_buffers[identifier].update(img)\n                walleye_data.set_pose(identifier, poses[i][0])\n                if walleye_data.visualizing_poses:\n                    visualization_buffers[identifier].update(\n                        (poses[i][0].X(), poses[i][0].Y(), poses[i][0].Z()), tags[i][1:]\n                    )\n\n        # Ends the WallEye program through the web interface\n        elif walleye_data.current_state == States.SHUTDOWN:\n            logger.info(\"Shutting down\")\n            logging.shutdown()\n            socketio.stop()\n            break\n\n        # Update cameras no matter what state\n        if walleye_data.current_state != States.PROCESSING:\n            for camera_info in walleye_data.cameras.info.values():\n                if (\n                    camera_info.identifier == walleye_data.camera_in_calibration\n                    and walleye_data.current_state in CALIBRATION_STATES\n                ):\n                    continue\n\n                ret, img = camera_info.cam.read()\n\n                cam_buffers[camera_info.identifier].update(img)\n\nexcept Exception as e:\n    # Something bad happened\n    logging.critical(e, exc_info=True)\n    logger.info(\"Shutting down\")\n    socketio.stop()\n    logging.shutdown()\n"]], ["ChangeContents", ["publisher/network_table_publisher.py", "import ntcore\nimport logging\n\n\nclass NetworkIO:\n    logger = logging.getLogger(__name__)\n\n    # Create a Network Tables Client with given info\n    def __init__(self, test, team, table_name, num_cams):\n        # Grab the default network table instance and grab the table name\n        self.inst = ntcore.NetworkTableInstance.getDefault()\n        self.table = self.inst.getTable(table_name)\n\n        # Start the WallEye_Client and set server depending on testing\n        self.inst.startClient4(\"WallEye_Client\")\n        self.update_num = []\n        self.connection = []\n        self.pose1_sub = []\n        self.pose2_sub = []\n        self.timestamp_sub = []\n        self.ambiguity_sub = []\n        self.tag_sub = []\n        if test:\n            self.inst.setServer(\"127.0.0.1\", 5810)\n        else:\n            self.inst.setServerTeam(team)\n\n        # Set all the publishers and update publishers\n        self.publishers = []\n\n        # Update publisher\n        self.publish_update = []\n\n        # image publisher ie has recieved a new image\n        self.publish_connection = []\n\n        # Pose publisher\n        for index in range(num_cams):\n            self.publishers.append(self.table.getSubTable(\"Result\" + str(index)))\n\n            self.pose1_sub.append(\n                self.publishers[index]\n                .getDoubleArrayTopic(\"Pose1\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.timestamp_sub.append(\n                self.publishers[index]\n                .getDoubleTopic(\"timestamp\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.pose2_sub.append(\n                self.publishers[index]\n                .getDoubleArrayTopic(\"Pose2\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.ambiguity_sub.append(\n                self.publishers[index]\n                .getDoubleTopic(\"ambiguity\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.tag_sub.append(\n                self.publishers[index]\n                .getIntegerArrayTopic(\"tags\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.publish_update.append(\n                self.table.getIntegerTopic(\"Update\" + str(index)).publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n            self.publish_connection.append(\n                self.table.getBooleanTopic(\"Connected\" + str(index)).publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.update_num.append(0)\n            self.connection.append(False)\n\n    def get_time(self):\n        return ntcore._now()\n\n    def set_table(self, name):\n        self.table = self.inst.getTable(name)\n\n    # Publishes the supplied pose information in the corresponding publisher\n    def publish(self, index, time, pose, tags, ambig):\n        pose1 = pose[0]\n        pose2 = pose[1]\n        t1 = pose1.translation()\n        r1 = pose1.rotation()\n        t2 = pose2.translation()\n        r2 = pose2.rotation()\n\n        self.pose1_sub[index].set([t1.X(), t1.Y(), t1.Z(), r1.X(), r1.Y(), r1.Z()])\n        self.pose2_sub[index].set([t2.X(), t2.Y(), t2.Z(), r2.X(), r2.Y(), r2.Z()])\n        self.ambiguity_sub[index].set(ambig)\n        self.tag_sub[index].set(tags)\n        self.timestamp_sub[index].set(ntcore._now() - time)\n\n        self.update_num[index] += 1\n        self.publish_update[index].set(self.update_num[index])\n\n    # Publish a new update number\n    def increase_update_num(self):\n        self.update_num += 1\n        self.publish_update.set(self.update_num)\n\n    def setConnectionValue_XxX_CamelSnakePep8_PreserveName_XxX_6(self, index, val):\n        self.connection[index] = val\n        self.publish_connection[index].set(val)\n\n    def getConnectionValue_XxX_CamelSnakePep8_PreserveName_XxX_7(self, index):\n        return self.connection[index]\n\n    def destroy(self):\n        self.inst.stopClient()\n\n    def update_team(self, num):\n        self.inst.setServerTeam(num)\n\n    def update_name(self, name):\n        self.inst.getTable(name)\n", "import ntcore\nimport logging\n\n\nclass NetworkIO:\n    logger = logging.getLogger(__name__)\n\n    # Create a Network Tables Client with given info\n    def __init__(self, test, team, table_name, num_cams):\n        # Grab the default network table instance and grab the table name\n        self.inst = ntcore.NetworkTableInstance.getDefault()\n        self.table = self.inst.getTable(table_name)\n\n        # Start the WallEye_Client and set server depending on testing\n        self.inst.startClient4(\"WallEye_Client\")\n        self.update_num = []\n        self.connection = []\n        self.pose1_sub = []\n        self.pose2_sub = []\n        self.timestamp_sub = []\n        self.ambiguity_sub = []\n        self.tag_sub = []\n        if test:\n            self.inst.setServer(\"127.0.0.1\", 5810)\n        else:\n            self.inst.setServerTeam(team)\n\n        # Set all the publishers and update publishers\n        self.publishers = []\n\n        # Update publisher\n        self.publish_update = []\n\n        # image publisher ie has recieved a new image\n        self.publish_connection = []\n\n        # Pose publisher\n        for index in range(num_cams):\n            self.publishers.append(self.table.getSubTable(\"Result\" + str(index)))\n\n            self.pose1_sub.append(\n                self.publishers[index]\n                .getDoubleArrayTopic(\"Pose1\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.timestamp_sub.append(\n                self.publishers[index]\n                .getDoubleTopic(\"timestamp\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.pose2_sub.append(\n                self.publishers[index]\n                .getDoubleArrayTopic(\"Pose2\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.ambiguity_sub.append(\n                self.publishers[index]\n                .getDoubleTopic(\"ambiguity\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.tag_sub.append(\n                self.publishers[index]\n                .getIntegerArrayTopic(\"tags\")\n                .publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.publish_update.append(\n                self.table.getIntegerTopic(\"Update\" + str(index)).publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n            self.publish_connection.append(\n                self.table.getBooleanTopic(\"Connected\" + str(index)).publish(\n                    ntcore.PubSubOptions(\n                        periodic=0.01, sendAll=True, keepDuplicates=True\n                    )\n                )\n            )\n\n            self.update_num.append(0)\n            self.connection.append(False)\n\n    def get_time(self):\n        return ntcore._now()\n\n    def set_table(self, name):\n        self.table = self.inst.getTable(name)\n\n    # Publishes the supplied pose information in the corresponding publisher\n    def publish(self, index, time, pose, tags, ambig):\n        pose1 = pose[0]\n        pose2 = pose[1]\n        t1 = pose1.translation()\n        r1 = pose1.rotation()\n        t2 = pose2.translation()\n        r2 = pose2.rotation()\n\n        self.pose1_sub[index].set([t1.X(), t1.Y(), t1.Z(), r1.X(), r1.Y(), r1.Z()])\n        self.pose2_sub[index].set([t2.X(), t2.Y(), t2.Z(), r2.X(), r2.Y(), r2.Z()])\n        self.ambiguity_sub[index].set(ambig)\n        self.tag_sub[index].set(tags)\n        self.timestamp_sub[index].set(ntcore._now() - time)\n\n        self.update_num[index] += 1\n        self.publish_update[index].set(self.update_num[index])\n\n    # Publish a new update number\n    def increase_update_num(self):\n        self.update_num += 1\n        self.publish_update.set(self.update_num)\n\n    def setConnectionValue_XxX_CamelSnakePep8_PreserveName_XxX_6(self, index, val):\n        self.connection[index] = val\n        self.publish_connection[index].set(val)\n\n    def getConnectionValue(self, index):\n        return self.connection[index]\n\n    def destroy(self):\n        self.inst.stopClient()\n\n    def update_team(self, num):\n        self.inst.setServerTeam(num)\n\n    def update_name(self, name):\n        self.inst.getTable(name)\n"]]], 1715213099.234748]]], []]